<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::BufOverflowDetector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="classSVF_1_1BufOverflowDetector.html">BufOverflowDetector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSVF_1_1BufOverflowDetector-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">SVF::BufOverflowDetector Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Detector for identifying buffer overflow issues.  
 <a href="classSVF_1_1BufOverflowDetector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SVF::BufOverflowDetector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classSVF_1_1BufOverflowDetector.png" usemap="#SVF::BufOverflowDetector_map" alt=""/>
  <map id="SVF::BufOverflowDetector_map" name="SVF::BufOverflowDetector_map">
<area href="classSVF_1_1AEDetector.html" title="Base class for all detectors." alt="SVF::AEDetector" shape="rect" coords="0,0,162,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6323e92b296bd641b0a09c3a8dd0e990" id="r_a6323e92b296bd641b0a09c3a8dd0e990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a6323e92b296bd641b0a09c3a8dd0e990">BufOverflowDetector</a> ()</td></tr>
<tr class="memdesc:a6323e92b296bd641b0a09c3a8dd0e990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializes the detector kind to BUF_OVERFLOW and sets up external API buffer overflow rules.  <br /></td></tr>
<tr class="separator:a6323e92b296bd641b0a09c3a8dd0e990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2571e15f0850e3c77298a2349ea22ddf" id="r_a2571e15f0850e3c77298a2349ea22ddf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a2571e15f0850e3c77298a2349ea22ddf">~BufOverflowDetector</a> ()=<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">default</a></td></tr>
<tr class="memdesc:a2571e15f0850e3c77298a2349ea22ddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:a2571e15f0850e3c77298a2349ea22ddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae254384e3dbe204c07b5f0776f7d07d" id="r_aae254384e3dbe204c07b5f0776f7d07d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#aae254384e3dbe204c07b5f0776f7d07d">updateGepObjOffsetFromBase</a> (<a class="el" href="classSVF_1_1AddressValue.html">AddressValue</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddrs</a>, <a class="el" href="classSVF_1_1AddressValue.html">AddressValue</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddrs</a>, <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="el" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>)</td></tr>
<tr class="memdesc:aae254384e3dbe204c07b5f0776f7d07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the offset of a GEP object from its base.  <br /></td></tr>
<tr class="separator:aae254384e3dbe204c07b5f0776f7d07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437da08394623067ff14782f7de20375" id="r_a437da08394623067ff14782f7de20375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a437da08394623067ff14782f7de20375">detect</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *)</td></tr>
<tr class="memdesc:a437da08394623067ff14782f7de20375"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detect buffer overflow issues within a node.  <br /></td></tr>
<tr class="separator:a437da08394623067ff14782f7de20375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47ba77eb81cdc9f634dfaae7344a3dc" id="r_aa47ba77eb81cdc9f634dfaae7344a3dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#aa47ba77eb81cdc9f634dfaae7344a3dc">handleStubFunctions</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *)</td></tr>
<tr class="memdesc:aa47ba77eb81cdc9f634dfaae7344a3dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles external API calls related to buffer overflow detection.  <br /></td></tr>
<tr class="separator:aa47ba77eb81cdc9f634dfaae7344a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c55cec78c768443052cecea69a6c203" id="r_a0c55cec78c768443052cecea69a6c203"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a0c55cec78c768443052cecea69a6c203">addToGepObjOffsetFromBase</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> &amp;<a class="el" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>)</td></tr>
<tr class="memdesc:a0c55cec78c768443052cecea69a6c203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an offset to a GEP object.  <br /></td></tr>
<tr class="separator:a0c55cec78c768443052cecea69a6c203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6a7f125d4d5dc3659edc2f0f950c57" id="r_aad6a7f125d4d5dc3659edc2f0f950c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#aad6a7f125d4d5dc3659edc2f0f950c57">hasGepObjOffsetFromBase</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>) <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a></td></tr>
<tr class="memdesc:aad6a7f125d4d5dc3659edc2f0f950c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a GEP object has an associated offset.  <br /></td></tr>
<tr class="separator:aad6a7f125d4d5dc3659edc2f0f950c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd23cec47be6d202ab2fc5dce3f664b" id="r_a6cd23cec47be6d202ab2fc5dce3f664b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a6cd23cec47be6d202ab2fc5dce3f664b">getGepObjOffsetFromBase</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>) <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a></td></tr>
<tr class="memdesc:a6cd23cec47be6d202ab2fc5dce3f664b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the offset of a GEP object from its base.  <br /></td></tr>
<tr class="separator:a6cd23cec47be6d202ab2fc5dce3f664b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c39879a8c2cf7e2aff839fe5a7f8f3d" id="r_a0c39879a8c2cf7e2aff839fe5a7f8f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a0c39879a8c2cf7e2aff839fe5a7f8f3d">getAccessOffset</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepStmt.html">GepStmt</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>)</td></tr>
<tr class="memdesc:a0c39879a8c2cf7e2aff839fe5a7f8f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the access offset for a given object and GEP statement.  <br /></td></tr>
<tr class="separator:a0c39879a8c2cf7e2aff839fe5a7f8f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fe081d8a287976c6b02e0b5030bc6b" id="r_ae8fe081d8a287976c6b02e0b5030bc6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1AEException.html">AEException</a> &amp;e, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="memdesc:ae8fe081d8a287976c6b02e0b5030bc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bug to the reporter based on an exception.  <br /></td></tr>
<tr class="separator:ae8fe081d8a287976c6b02e0b5030bc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5cb9af3b1e74d10f11b36d88552b01" id="r_a9c5cb9af3b1e74d10f11b36d88552b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a9c5cb9af3b1e74d10f11b36d88552b01">reportBug</a> ()</td></tr>
<tr class="memdesc:a9c5cb9af3b1e74d10f11b36d88552b01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all detected buffer overflow bugs.  <br /></td></tr>
<tr class="separator:a9c5cb9af3b1e74d10f11b36d88552b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd940b41cca8134a59e87491ff0d0162" id="r_abd940b41cca8134a59e87491ff0d0162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#abd940b41cca8134a59e87491ff0d0162">initExtAPIBufOverflowCheckRules</a> ()</td></tr>
<tr class="memdesc:abd940b41cca8134a59e87491ff0d0162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes external API buffer overflow check rules.  <br /></td></tr>
<tr class="separator:abd940b41cca8134a59e87491ff0d0162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6844230bf29cccc3b44cfb17915a13b" id="r_ac6844230bf29cccc3b44cfb17915a13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#ac6844230bf29cccc3b44cfb17915a13b">detectExtAPI</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *call)</td></tr>
<tr class="memdesc:ac6844230bf29cccc3b44cfb17915a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles external API calls related to buffer overflow detection.  <br /></td></tr>
<tr class="separator:ac6844230bf29cccc3b44cfb17915a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76fcd4f6b7e832f56e918a811532173" id="r_ab76fcd4f6b7e832f56e918a811532173"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1SVFVar.html">SVFVar</a> *value, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">len</a>)</td></tr>
<tr class="memdesc:ab76fcd4f6b7e832f56e918a811532173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if memory can be safely accessed.  <br /></td></tr>
<tr class="separator:ab76fcd4f6b7e832f56e918a811532173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classSVF_1_1AEDetector"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classSVF_1_1AEDetector')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classSVF_1_1AEDetector.html">SVF::AEDetector</a></td></tr>
<tr class="memitem:a9450ffaff264702c671c9fa028040b4d inherit pub_methods_classSVF_1_1AEDetector" id="r_a9450ffaff264702c671c9fa028040b4d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#a9450ffaff264702c671c9fa028040b4d">AEDetector</a> ()</td></tr>
<tr class="memdesc:a9450ffaff264702c671c9fa028040b4d inherit pub_methods_classSVF_1_1AEDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor initializes the detector kind to UNKNOWN.  <br /></td></tr>
<tr class="separator:a9450ffaff264702c671c9fa028040b4d inherit pub_methods_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a5aa99492818e3b04e3e2bb108d04d inherit pub_methods_classSVF_1_1AEDetector" id="r_a99a5aa99492818e3b04e3e2bb108d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">virtual</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#a99a5aa99492818e3b04e3e2bb108d04d">~AEDetector</a> ()=<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">default</a></td></tr>
<tr class="memdesc:a99a5aa99492818e3b04e3e2bb108d04d inherit pub_methods_classSVF_1_1AEDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor for safe polymorphic use.  <br /></td></tr>
<tr class="separator:a99a5aa99492818e3b04e3e2bb108d04d inherit pub_methods_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3c15c5531c97e5e84acfabcbb2062a inherit pub_methods_classSVF_1_1AEDetector" id="r_abf3c15c5531c97e5e84acfabcbb2062a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8be">DetectorKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#abf3c15c5531c97e5e84acfabcbb2062a">getKind</a> () <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a></td></tr>
<tr class="memdesc:abf3c15c5531c97e5e84acfabcbb2062a inherit pub_methods_classSVF_1_1AEDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the kind of the detector.  <br /></td></tr>
<tr class="separator:abf3c15c5531c97e5e84acfabcbb2062a inherit pub_methods_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7b134618ae6f2d1523d29f7bd92db5d7" id="r_a7b134618ae6f2d1523d29f7bd92db5d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">static</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a7b134618ae6f2d1523d29f7bd92db5d7">classof</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1AEDetector.html">AEDetector</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">detector</a>)</td></tr>
<tr class="memdesc:a7b134618ae6f2d1523d29f7bd92db5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the detector is of the BUF_OVERFLOW kind.  <br /></td></tr>
<tr class="separator:a7b134618ae6f2d1523d29f7bd92db5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classSVF_1_1AEDetector"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classSVF_1_1AEDetector')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classSVF_1_1AEDetector.html">SVF::AEDetector</a></td></tr>
<tr class="memitem:a0869b876739ae93701b4289596d4845d inherit pub_static_methods_classSVF_1_1AEDetector" id="r_a0869b876739ae93701b4289596d4845d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">static</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#a0869b876739ae93701b4289596d4845d">classof</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1AEDetector.html">AEDetector</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">detector</a>)</td></tr>
<tr class="memdesc:a0869b876739ae93701b4289596d4845d inherit pub_static_methods_classSVF_1_1AEDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the detector is of the UNKNOWN kind.  <br /></td></tr>
<tr class="separator:a0869b876739ae93701b4289596d4845d inherit pub_static_methods_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6332a437555eb3b503741d420f633292" id="r_a6332a437555eb3b503741d420f633292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a6332a437555eb3b503741d420f633292">detectStrcat</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *call)</td></tr>
<tr class="memdesc:a6332a437555eb3b503741d420f633292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects buffer overflow in 'strcat' function calls.  <br /></td></tr>
<tr class="separator:a6332a437555eb3b503741d420f633292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492568641edcdd0f882bed1a0bbe3b5" id="r_a4492568641edcdd0f882bed1a0bbe3b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a4492568641edcdd0f882bed1a0bbe3b5">detectStrcpy</a> (<a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *call)</td></tr>
<tr class="memdesc:a4492568641edcdd0f882bed1a0bbe3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detects buffer overflow in 'strcpy' function calls.  <br /></td></tr>
<tr class="separator:a4492568641edcdd0f882bed1a0bbe3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3cd11f8d87ca8a2aa971349a5446f1cd" id="r_a3cd11f8d87ca8a2aa971349a5446f1cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *, <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">gepObjOffsetFromBase</a></td></tr>
<tr class="memdesc:a3cd11f8d87ca8a2aa971349a5446f1cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps GEP objects to their offsets from the base.  <br /></td></tr>
<tr class="separator:a3cd11f8d87ca8a2aa971349a5446f1cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416ec25c8bb80b8bb241adc0e5216bc0" id="r_a416ec25c8bb80b8bb241adc0e5216bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; std::string, std::vector&lt; std::pair&lt; <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a></td></tr>
<tr class="memdesc:a416ec25c8bb80b8bb241adc0e5216bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rules for checking buffer overflows in external APIs.  <br /></td></tr>
<tr class="separator:a416ec25c8bb80b8bb241adc0e5216bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f1738ad44d9d07e1dcf911858ced04" id="r_a63f1738ad44d9d07e1dcf911858ced04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a63f1738ad44d9d07e1dcf911858ced04">bugLoc</a></td></tr>
<tr class="memdesc:a63f1738ad44d9d07e1dcf911858ced04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of locations where bugs have been reported.  <br /></td></tr>
<tr class="separator:a63f1738ad44d9d07e1dcf911858ced04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0f8f9afa5723d016abf2199512d921" id="r_a4c0f8f9afa5723d016abf2199512d921"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1SVFBugReport.html">SVFBugReport</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a4c0f8f9afa5723d016abf2199512d921">recoder</a></td></tr>
<tr class="memdesc:a4c0f8f9afa5723d016abf2199512d921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recorder for abstract execution bugs.  <br /></td></tr>
<tr class="separator:a4c0f8f9afa5723d016abf2199512d921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0a7fa63e5898380111edef2c748ce8" id="r_a9d0a7fa63e5898380111edef2c748ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">nodeToBugInfo</a></td></tr>
<tr class="memdesc:a9d0a7fa63e5898380111edef2c748ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> nodes to bug information.  <br /></td></tr>
<tr class="separator:a9d0a7fa63e5898380111edef2c748ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8bd63bb97cf4c121c55244249726ee25" id="r_a8bd63bb97cf4c121c55244249726ee25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1BufOverflowDetector.html#a8bd63bb97cf4c121c55244249726ee25">AbstractInterpretation</a></td></tr>
<tr class="separator:a8bd63bb97cf4c121c55244249726ee25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classSVF_1_1AEDetector"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classSVF_1_1AEDetector')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classSVF_1_1AEDetector.html">SVF::AEDetector</a></td></tr>
<tr class="memitem:a1666c7c2ee82415603bde7ef5c75a8be inherit pub_types_classSVF_1_1AEDetector" id="r_a1666c7c2ee82415603bde7ef5c75a8be"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8be">DetectorKind</a> { <a class="el" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8beaf04a46a640c280f4380ddc48f8ee375b">BUF_OVERFLOW</a>
, <a class="el" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8bead62d303c8d623dc3a31e49fca5967c17">UNKNOWN</a>
 }</td></tr>
<tr class="memdesc:a1666c7c2ee82415603bde7ef5c75a8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the types of detectors available.  <a href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8be">More...</a><br /></td></tr>
<tr class="separator:a1666c7c2ee82415603bde7ef5c75a8be inherit pub_types_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classSVF_1_1AEDetector"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classSVF_1_1AEDetector')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classSVF_1_1AEDetector.html">SVF::AEDetector</a></td></tr>
<tr class="memitem:a3947d2ab84f861c484a80e060a875a13 inherit pro_attribs_classSVF_1_1AEDetector" id="r_a3947d2ab84f861c484a80e060a875a13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8be">DetectorKind</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1AEDetector.html#a3947d2ab84f861c484a80e060a875a13">kind</a></td></tr>
<tr class="memdesc:a3947d2ab84f861c484a80e060a875a13 inherit pro_attribs_classSVF_1_1AEDetector"><td class="mdescLeft">&#160;</td><td class="mdescRight">The kind of the detector.  <br /></td></tr>
<tr class="separator:a3947d2ab84f861c484a80e060a875a13 inherit pro_attribs_classSVF_1_1AEDetector"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Detector for identifying buffer overflow issues. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00133">133</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6323e92b296bd641b0a09c3a8dd0e990" name="a6323e92b296bd641b0a09c3a8dd0e990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6323e92b296bd641b0a09c3a8dd0e990">&#9670;&#160;</a></span>BufOverflowDetector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVF::BufOverflowDetector::BufOverflowDetector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor initializes the detector kind to BUF_OVERFLOW and sets up external API buffer overflow rules. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00140">140</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  141</span>    {</div>
<div class="line"><span class="lineno">  142</span>        <a class="code hl_variable" href="classSVF_1_1AEDetector.html#a3947d2ab84f861c484a80e060a875a13">kind</a> = <a class="code hl_enumvalue" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8beaf04a46a640c280f4380ddc48f8ee375b">BUF_OVERFLOW</a>;</div>
<div class="line"><span class="lineno">  143</span>        <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#abd940b41cca8134a59e87491ff0d0162">initExtAPIBufOverflowCheckRules</a>();</div>
<div class="line"><span class="lineno">  144</span>    }</div>
<div class="ttc" id="aclassSVF_1_1AEDetector_html_a1666c7c2ee82415603bde7ef5c75a8beaf04a46a640c280f4380ddc48f8ee375b"><div class="ttname"><a href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8beaf04a46a640c280f4380ddc48f8ee375b">SVF::AEDetector::BUF_OVERFLOW</a></div><div class="ttdeci">@ BUF_OVERFLOW</div><div class="ttdoc">Detector for buffer overflow issues.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00047">AEDetector.h:47</a></div></div>
<div class="ttc" id="aclassSVF_1_1AEDetector_html_a3947d2ab84f861c484a80e060a875a13"><div class="ttname"><a href="classSVF_1_1AEDetector.html#a3947d2ab84f861c484a80e060a875a13">SVF::AEDetector::kind</a></div><div class="ttdeci">DetectorKind kind</div><div class="ttdoc">The kind of the detector.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00099">AEDetector.h:99</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_abd940b41cca8134a59e87491ff0d0162"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#abd940b41cca8134a59e87491ff0d0162">SVF::BufOverflowDetector::initExtAPIBufOverflowCheckRules</a></div><div class="ttdeci">void initExtAPIBufOverflowCheckRules()</div><div class="ttdoc">Initializes external API buffer overflow check rules.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00185">AEDetector.cpp:185</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2571e15f0850e3c77298a2349ea22ddf" name="a2571e15f0850e3c77298a2349ea22ddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2571e15f0850e3c77298a2349ea22ddf">&#9670;&#160;</a></span>~BufOverflowDetector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SVF::BufOverflowDetector::~BufOverflowDetector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae8fe081d8a287976c6b02e0b5030bc6b" name="ae8fe081d8a287976c6b02e0b5030bc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fe081d8a287976c6b02e0b5030bc6b">&#9670;&#160;</a></span>addBugToReporter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::BufOverflowDetector::addBugToReporter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1AEException.html">AEException</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a bug to the reporter based on an exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The exception that was thrown. </td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node where the bug was detected. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00232">232</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  233</span>    {</div>
<div class="line"><span class="lineno">  234</span> </div>
<div class="line"><span class="lineno">  235</span>        <a class="code hl_typedef" href="classSVF_1_1GenericBug.html#acc65b033bfd61257d5b6fdbf932dfafe">GenericBug::EventStack</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eventStack</a>;</div>
<div class="line"><span class="lineno">  236</span>        SVFBugEvent <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">sourceInstEvent</a>(<a class="code hl_enumvalue" href="classSVF_1_1SVFBugEvent.html#a4d0c0744525bc445a64176c3808377f3ace4540f37504bfbfab8451b8823fe999">SVFBugEvent::EventType::SourceInst</a>, node);</div>
<div class="line"><span class="lineno">  237</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eventStack</a>.push_back(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">sourceInstEvent</a>); <span class="comment">// Add the source instruction event to the event stack</span></div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eventStack</a>.empty())</div>
<div class="line"><span class="lineno">  240</span>        {</div>
<div class="line"><span class="lineno">  241</span>            <span class="keywordflow">return</span>; <span class="comment">// If the event stack is empty, return early</span></div>
<div class="line"><span class="lineno">  242</span>        }</div>
<div class="line"><span class="lineno">  243</span> </div>
<div class="line"><span class="lineno">  244</span>        std::string <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">loc</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eventStack</a>.back().getEventLoc(); <span class="comment">// Get the location of the last event in the stack</span></div>
<div class="line"><span class="lineno">  245</span> </div>
<div class="line"><span class="lineno">  246</span>        <span class="comment">// Check if the bug at this location has already been reported</span></div>
<div class="line"><span class="lineno">  247</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a63f1738ad44d9d07e1dcf911858ced04">bugLoc</a>.find(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">loc</a>) != <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a63f1738ad44d9d07e1dcf911858ced04">bugLoc</a>.end())</div>
<div class="line"><span class="lineno">  248</span>        {</div>
<div class="line"><span class="lineno">  249</span>            <span class="keywordflow">return</span>; <span class="comment">// If the bug location is already reported, return early</span></div>
<div class="line"><span class="lineno">  250</span>        }</div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  252</span>        {</div>
<div class="line"><span class="lineno">  253</span>            <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a63f1738ad44d9d07e1dcf911858ced04">bugLoc</a>.insert(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">loc</a>); <span class="comment">// Otherwise, mark this location as reported</span></div>
<div class="line"><span class="lineno">  254</span>        }</div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>        <span class="comment">// Add the bug to the recorder with details from the event stack</span></div>
<div class="line"><span class="lineno">  257</span>        <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a4c0f8f9afa5723d016abf2199512d921">recoder</a>.<a class="code hl_function" href="classSVF_1_1SVFBugReport.html#a05f395eff23619ed10c31c0acda949e2">addAbsExecBug</a>(<a class="code hl_enumvalue" href="classSVF_1_1GenericBug.html#a7aeeb33097bca5f7fe6747f90f5cecacac88ddac03bb8ae09a72058e4ad7af747">GenericBug::FULLBUFOVERFLOW</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eventStack</a>, 0, 0, 0, 0);</div>
<div class="line"><span class="lineno">  258</span>        <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">nodeToBugInfo</a>[node] = e.what(); <span class="comment">// Record the exception information for the node</span></div>
<div class="line"><span class="lineno">  259</span>    }</div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a4c0f8f9afa5723d016abf2199512d921"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a4c0f8f9afa5723d016abf2199512d921">SVF::BufOverflowDetector::recoder</a></div><div class="ttdeci">SVFBugReport recoder</div><div class="ttdoc">Recorder for abstract execution bugs.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00320">AEDetector.h:320</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a63f1738ad44d9d07e1dcf911858ced04"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a63f1738ad44d9d07e1dcf911858ced04">SVF::BufOverflowDetector::bugLoc</a></div><div class="ttdeci">Set&lt; std::string &gt; bugLoc</div><div class="ttdoc">Set of locations where bugs have been reported.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00319">AEDetector.h:319</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a9d0a7fa63e5898380111edef2c748ce8"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">SVF::BufOverflowDetector::nodeToBugInfo</a></div><div class="ttdeci">Map&lt; const ICFGNode *, std::string &gt; nodeToBugInfo</div><div class="ttdoc">Maps ICFG nodes to bug information.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00321">AEDetector.h:321</a></div></div>
<div class="ttc" id="aclassSVF_1_1GenericBug_html_a7aeeb33097bca5f7fe6747f90f5cecacac88ddac03bb8ae09a72058e4ad7af747"><div class="ttname"><a href="classSVF_1_1GenericBug.html#a7aeeb33097bca5f7fe6747f90f5cecacac88ddac03bb8ae09a72058e4ad7af747">SVF::GenericBug::FULLBUFOVERFLOW</a></div><div class="ttdeci">@ FULLBUFOVERFLOW</div><div class="ttdef"><b>Definition</b> <a href="SVFBugReport_8h_source.html#l00086">SVFBugReport.h:86</a></div></div>
<div class="ttc" id="aclassSVF_1_1GenericBug_html_acc65b033bfd61257d5b6fdbf932dfafe"><div class="ttname"><a href="classSVF_1_1GenericBug.html#acc65b033bfd61257d5b6fdbf932dfafe">SVF::GenericBug::EventStack</a></div><div class="ttdeci">std::vector&lt; SVFBugEvent &gt; EventStack</div><div class="ttdef"><b>Definition</b> <a href="SVFBugReport_8h_source.html#l00083">SVFBugReport.h:83</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFBugEvent_html_a4d0c0744525bc445a64176c3808377f3ace4540f37504bfbfab8451b8823fe999"><div class="ttname"><a href="classSVF_1_1SVFBugEvent.html#a4d0c0744525bc445a64176c3808377f3ace4540f37504bfbfab8451b8823fe999">SVF::SVFBugEvent::SourceInst</a></div><div class="ttdeci">@ SourceInst</div><div class="ttdef"><b>Definition</b> <a href="SVFBugReport_8h_source.html#l00061">SVFBugReport.h:60</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFBugReport_html_a05f395eff23619ed10c31c0acda949e2"><div class="ttname"><a href="classSVF_1_1SVFBugReport.html#a05f395eff23619ed10c31c0acda949e2">SVF::SVFBugReport::addAbsExecBug</a></div><div class="ttdeci">void addAbsExecBug(GenericBug::BugType bugType, const GenericBug::EventStack &amp;eventStack, s64_t allocLowerBound, s64_t allocUpperBound, s64_t accessLowerBound, s64_t accessUpperBound)</div><div class="ttdef"><b>Definition</b> <a href="SVFBugReport_8h_source.html#l00367">SVFBugReport.h:367</a></div></div>
<div class="ttc" id="anamespaceSVF_html_a94824519e439aeef1568d415b6f7331c"><div class="ttname"><a href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">SVF::IRBuilder</a></div><div class="ttdeci">llvm::IRBuilder IRBuilder</div><div class="ttdef"><b>Definition</b> <a href="BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c55cec78c768443052cecea69a6c203" name="a0c55cec78c768443052cecea69a6c203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c55cec78c768443052cecea69a6c203">&#9670;&#160;</a></span>addToGepObjOffsetFromBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::BufOverflowDetector::addToGepObjOffsetFromBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an offset to a GEP object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the GEP object. </td></tr>
    <tr><td class="paramname">offset</td><td>The interval value of the offset. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00190">190</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  191</span>    {</div>
<div class="line"><span class="lineno">  192</span>        <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">gepObjOffsetFromBase</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>] = <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>;</div>
<div class="line"><span class="lineno">  193</span>    }</div>
<div class="ttc" id="acJSON_8cpp_html_a95bf816579e97b6f33bdb5e25ed6d5de"><div class="ttname"><a href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a></div><div class="ttdeci">buffer offset</div><div class="ttdef"><b>Definition</b> <a href="cJSON_8cpp_source.html#l01113">cJSON.cpp:1113</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a3cd11f8d87ca8a2aa971349a5446f1cd"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">SVF::BufOverflowDetector::gepObjOffsetFromBase</a></div><div class="ttdeci">Map&lt; const GepObjVar *, IntervalValue &gt; gepObjOffsetFromBase</div><div class="ttdoc">Maps GEP objects to their offsets from the base.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00317">AEDetector.h:317</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab76fcd4f6b7e832f56e918a811532173" name="ab76fcd4f6b7e832f56e918a811532173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76fcd4f6b7e832f56e918a811532173">&#9670;&#160;</a></span>canSafelyAccessMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> BufOverflowDetector::canSafelyAccessMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1SVFVar.html">SVFVar</a> *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> &amp;&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if memory can be safely accessed. </p>
<p>Checks if a memory access is safe given a specific buffer length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the <a class="el" href="namespaceSVF.html" title="for isBitcode">SVF</a> var. </td></tr>
    <tr><td class="paramname">len</td><td>The interval value representing the length of the memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the memory access is safe, false otherwise.</dd></dl>
<p>This function ensures that a given memory access, starting at a specific value, does not exceed the allocated size of the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">value</td><td>Pointer to the <a class="el" href="namespaceSVF.html" title="for isBitcode">SVF</a> var. </td></tr>
    <tr><td class="paramname">len</td><td>The interval value representing the length of the memory access. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the memory access is safe, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00455">455</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  456</span>{</div>
<div class="line"><span class="lineno">  457</span>    <a class="code hl_class" href="classSVF_1_1SVFIR.html">SVFIR</a>* svfir = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>();</div>
<div class="line"><span class="lineno">  458</span>    <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">value_id</a> = value-&gt;<a class="code hl_function" href="classSVF_1_1SVFBaseNode.html#ab2211bc249e7cc9f26255fb184fd4eae">getId</a>();</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">value_id</a>].isAddr());</div>
<div class="line"><span class="lineno">  461</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addr</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">value_id</a>].getAddrs())</div>
<div class="line"><span class="lineno">  462</span>    {</div>
<div class="line"><span class="lineno">  463</span>        <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a> = <a class="code hl_function" href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">AbstractState::getInternalID</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addr</a>);</div>
<div class="line"><span class="lineno">  464</span>        <a class="code hl_typedef" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> size = 0;</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>        <span class="comment">// if the object is a constant size object, get the size directly</span></div>
<div class="line"><span class="lineno">  467</span>        <span class="keywordflow">if</span> (svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#aa7fd696ea4a8a8ad505294727f894802">isConstantByteSize</a>())</div>
<div class="line"><span class="lineno">  468</span>        {</div>
<div class="line"><span class="lineno">  469</span>            size = svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#aa85a3d18980860c01ebe190a16039af7">getByteSizeOfObj</a>();</div>
<div class="line"><span class="lineno">  470</span>        }</div>
<div class="line"><span class="lineno">  471</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  472</span>        {</div>
<div class="line"><span class="lineno">  473</span>            <span class="comment">// if the object is not a constant size object, get the size from the addrStmt</span></div>
<div class="line"><span class="lineno">  474</span>            <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1ICFGNode.html">ICFGNode</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrNode</a> = svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#a95cafb75a7ae4879dee6949a158fe0c6">getICFGNode</a>();</div>
<div class="line"><span class="lineno">  475</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFStmt.html">SVFStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt2</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrNode</a>-&gt;getSVFStmts())</div>
<div class="line"><span class="lineno">  476</span>            {</div>
<div class="line"><span class="lineno">  477</span>                <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1AddrStmt.html">AddrStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrStmt</a> = SVFUtil::dyn_cast&lt;AddrStmt&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt2</a>))</div>
<div class="line"><span class="lineno">  478</span>                {</div>
<div class="line"><span class="lineno">  479</span>                    size = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>.getAllocaInstByteSize(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrStmt</a>);</div>
<div class="line"><span class="lineno">  480</span>                }</div>
<div class="line"><span class="lineno">  481</span>            }</div>
<div class="line"><span class="lineno">  482</span>        }</div>
<div class="line"><span class="lineno">  483</span> </div>
<div class="line"><span class="lineno">  484</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>(0);</div>
<div class="line"><span class="lineno">  485</span>        <span class="comment">// if the object is a GepObjVar, get the offset from the base object</span></div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordflow">if</span> (SVFUtil::isa&lt;GepObjVar&gt;(svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)))</div>
<div class="line"><span class="lineno">  487</span>        {</div>
<div class="line"><span class="lineno">  488</span>            <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a> = <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a6cd23cec47be6d202ab2fc5dce3f664b">getGepObjOffsetFromBase</a>(SVFUtil::cast&lt;GepObjVar&gt;(svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>))) + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">len</a>;</div>
<div class="line"><span class="lineno">  489</span>        }</div>
<div class="line"><span class="lineno">  490</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  491</span>        {</div>
<div class="line"><span class="lineno">  492</span>            <span class="comment">// if the object is a BaseObjVar, get the offset directly</span></div>
<div class="line"><span class="lineno">  493</span>            <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">len</a>;</div>
<div class="line"><span class="lineno">  494</span>        }</div>
<div class="line"><span class="lineno">  495</span>        <span class="comment">// if the offset is greater than the size, return false</span></div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>.ub().getIntNumeral() &gt;= size)</div>
<div class="line"><span class="lineno">  497</span>        {</div>
<div class="line"><span class="lineno">  498</span>            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  499</span>        }</div>
<div class="line"><span class="lineno">  500</span>    }</div>
<div class="line"><span class="lineno">  501</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  502</span>}</div>
<div class="ttc" id="aCommandLine_8h_html_a2429346d37bd4c40889bd7c6d319d9da"><div class="ttname"><a href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition</b> <a href="CommandLine_8h_source.html#l00018">CommandLine.h:18</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbstractState_html_aaabe5850dbf1620c6058f5ac6cb169b6"><div class="ttname"><a href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">SVF::AbstractState::getInternalID</a></div><div class="ttdeci">static u32_t getInternalID(u32_t idx)</div><div class="ttdoc">Return the internal index if idx is an address otherwise return the value of idx.</div><div class="ttdef"><b>Definition</b> <a href="AbstractState_8h_source.html#l00114">AbstractState.h:114</a></div></div>
<div class="ttc" id="aclassSVF_1_1AddrStmt_html"><div class="ttname"><a href="classSVF_1_1AddrStmt.html">SVF::AddrStmt</a></div><div class="ttdef"><b>Definition</b> <a href="SVFStatements_8h_source.html#l00309">SVFStatements.h:310</a></div></div>
<div class="ttc" id="aclassSVF_1_1BaseObjVar_html_a95cafb75a7ae4879dee6949a158fe0c6"><div class="ttname"><a href="classSVF_1_1BaseObjVar.html#a95cafb75a7ae4879dee6949a158fe0c6">SVF::BaseObjVar::getICFGNode</a></div><div class="ttdeci">const ICFGNode * getICFGNode() const</div><div class="ttdoc">Get the ICFGNode related to the creation of this object.</div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00586">SVFVariables.h:586</a></div></div>
<div class="ttc" id="aclassSVF_1_1BaseObjVar_html_aa7fd696ea4a8a8ad505294727f894802"><div class="ttname"><a href="classSVF_1_1BaseObjVar.html#aa7fd696ea4a8a8ad505294727f894802">SVF::BaseObjVar::isConstantByteSize</a></div><div class="ttdeci">bool isConstantByteSize() const</div><div class="ttdoc">Check if byte size is a const value.</div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00659">SVFVariables.h:659</a></div></div>
<div class="ttc" id="aclassSVF_1_1BaseObjVar_html_aa85a3d18980860c01ebe190a16039af7"><div class="ttname"><a href="classSVF_1_1BaseObjVar.html#aa85a3d18980860c01ebe190a16039af7">SVF::BaseObjVar::getByteSizeOfObj</a></div><div class="ttdeci">u32_t getByteSizeOfObj() const</div><div class="ttdoc">Get the byte size of this object.</div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00653">SVFVariables.h:653</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a6cd23cec47be6d202ab2fc5dce3f664b"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a6cd23cec47be6d202ab2fc5dce3f664b">SVF::BufOverflowDetector::getGepObjOffsetFromBase</a></div><div class="ttdeci">IntervalValue getGepObjOffsetFromBase(const GepObjVar *obj) const</div><div class="ttdoc">Retrieves the offset of a GEP object from its base.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00210">AEDetector.h:210</a></div></div>
<div class="ttc" id="aclassSVF_1_1GenericGraph_html_ad6b861a4aa6eca7902410a7005d86707"><div class="ttname"><a href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">SVF::GenericGraph::getGNode</a></div><div class="ttdeci">NodeType * getGNode(NodeID id) const</div><div class="ttdoc">Get a node.</div><div class="ttdef"><b>Definition</b> <a href="GenericGraph_8h_source.html#l00688">GenericGraph.h:688</a></div></div>
<div class="ttc" id="aclassSVF_1_1ICFGNode_html"><div class="ttname"><a href="classSVF_1_1ICFGNode.html">SVF::ICFGNode</a></div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00054">ICFGNode.h:55</a></div></div>
<div class="ttc" id="aclassSVF_1_1IntervalValue_html"><div class="ttname"><a href="classSVF_1_1IntervalValue.html">SVF::IntervalValue</a></div><div class="ttdef"><b>Definition</b> <a href="IntervalValue_8h_source.html#l00045">IntervalValue.h:46</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFBaseNode_html_ab2211bc249e7cc9f26255fb184fd4eae"><div class="ttname"><a href="classSVF_1_1SVFBaseNode.html#ab2211bc249e7cc9f26255fb184fd4eae">SVF::SVFBaseNode::getId</a></div><div class="ttdeci">NodeID getId() const</div><div class="ttdoc">Get ID.</div><div class="ttdef"><b>Definition</b> <a href="GenericGraph_8h_source.html#l00254">GenericGraph.h:254</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html"><div class="ttname"><a href="classSVF_1_1SVFIR.html">SVF::SVFIR</a></div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00043">SVFIR.h:44</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html_a6d2760579a059b1aba98e4555a443884"><div class="ttname"><a href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">SVF::SVFIR::getBaseObject</a></div><div class="ttdeci">const BaseObjVar * getBaseObject(NodeID id) const</div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00403">SVFIR.h:403</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html_acdb6795e102e7c03a61b7a4d2044c348"><div class="ttname"><a href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">SVF::SVFIR::getPAG</a></div><div class="ttdeci">static SVFIR * getPAG(bool buildFromFile=false)</div><div class="ttdoc">Singleton design here to make sure we only have one instance during any analysis.</div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00117">SVFIR.h:117</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFStmt_html"><div class="ttname"><a href="classSVF_1_1SVFStmt.html">SVF::SVFStmt</a></div><div class="ttdef"><b>Definition</b> <a href="SVFStatements_8h_source.html#l00051">SVFStatements.h:52</a></div></div>
<div class="ttc" id="anamespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">u32_t NodeID</div><div class="ttdef"><b>Definition</b> <a href="GeneralType_8h_source.html#l00055">GeneralType.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7b134618ae6f2d1523d29f7bd92db5d7" name="a7b134618ae6f2d1523d29f7bd92db5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b134618ae6f2d1523d29f7bd92db5d7">&#9670;&#160;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">static</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::BufOverflowDetector::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1AEDetector.html">AEDetector</a> *&#160;</td>
          <td class="paramname"><em>detector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the detector is of the BUF_OVERFLOW kind. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detector</td><td>Pointer to the detector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the detector is of type BUF_OVERFLOW, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00156">156</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  157</span>    {</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">detector</a>-&gt;getKind() == <a class="code hl_enumvalue" href="classSVF_1_1AEDetector.html#a1666c7c2ee82415603bde7ef5c75a8beaf04a46a640c280f4380ddc48f8ee375b">AEDetector::BUF_OVERFLOW</a>;</div>
<div class="line"><span class="lineno">  159</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a437da08394623067ff14782f7de20375" name="a437da08394623067ff14782f7de20375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437da08394623067ff14782f7de20375">&#9670;&#160;</a></span>detect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufOverflowDetector::detect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detect buffer overflow issues within a node. </p>
<p>Detects buffer overflow issues within a given <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function handles both non-call nodes, where it analyzes GEP (GetElementPtr) instructions for potential buffer overflows, and call nodes, where it checks for external API calls that may cause overflows.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">node</td><td>Pointer to the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSVF_1_1AEDetector.html#ad7d9a8544b87e24d34056ecbe58c59c1">SVF::AEDetector</a>.</p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00044">44</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   45</span>{</div>
<div class="line"><span class="lineno">   46</span>    <span class="keywordflow">if</span> (!SVFUtil::isa&lt;CallICFGNode&gt;(node))</div>
<div class="line"><span class="lineno">   47</span>    {</div>
<div class="line"><span class="lineno">   48</span>        <span class="comment">// Handle non-call nodes by analyzing GEP instructions</span></div>
<div class="line"><span class="lineno">   49</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFStmt.html">SVFStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt</a> : node-&gt;getSVFStmts())</div>
<div class="line"><span class="lineno">   50</span>        {</div>
<div class="line"><span class="lineno">   51</span>            <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1GepStmt.html">GepStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a> = SVFUtil::dyn_cast&lt;GepStmt&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt</a>))</div>
<div class="line"><span class="lineno">   52</span>            {</div>
<div class="line"><span class="lineno">   53</span>                <a class="code hl_class" href="classSVF_1_1SVFIR.html">SVFIR</a>* svfir = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>();</div>
<div class="line"><span class="lineno">   54</span>                <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lhs</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>-&gt;getLHSVarID();</div>
<div class="line"><span class="lineno">   55</span>                <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rhs</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>-&gt;getRHSVarID();</div>
<div class="line"><span class="lineno">   56</span> </div>
<div class="line"><span class="lineno">   57</span>                <span class="comment">// Update the GEP object offset from its base</span></div>
<div class="line"><span class="lineno">   58</span>                <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#aae254384e3dbe204c07b5f0776f7d07d">updateGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lhs</a>].getAddrs(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rhs</a>].getAddrs(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>.getByteOffset(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>));</div>
<div class="line"><span class="lineno">   59</span> </div>
<div class="line"><span class="lineno">   60</span>                <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">baseObjSize</a> = <a class="code hl_function" href="classSVF_1_1IntervalValue.html#aa027be2f9243ce4cae799b265b019443">IntervalValue::bottom</a>();</div>
<div class="line"><span class="lineno">   61</span>                <a class="code hl_class" href="classSVF_1_1AddressValue.html">AddressValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddrs</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>-&gt;getRHSVarID()].getAddrs();</div>
<div class="line"><span class="lineno">   62</span>                <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addr</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddrs</a>)</div>
<div class="line"><span class="lineno">   63</span>                {</div>
<div class="line"><span class="lineno">   64</span>                    <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a> = <a class="code hl_function" href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">AbstractState::getInternalID</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addr</a>);</div>
<div class="line"><span class="lineno">   65</span>                    <a class="code hl_typedef" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> size = 0;</div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>                    <span class="keywordflow">if</span> (svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#aa7fd696ea4a8a8ad505294727f894802">isConstantByteSize</a>())</div>
<div class="line"><span class="lineno">   68</span>                    {</div>
<div class="line"><span class="lineno">   69</span>                        size = svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#aa85a3d18980860c01ebe190a16039af7">getByteSizeOfObj</a>();</div>
<div class="line"><span class="lineno">   70</span>                    }</div>
<div class="line"><span class="lineno">   71</span>                    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   72</span>                    {</div>
<div class="line"><span class="lineno">   73</span>                        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1ICFGNode.html">ICFGNode</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrNode</a> = svfir-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a6d2760579a059b1aba98e4555a443884">getBaseObject</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>)-&gt;<a class="code hl_function" href="classSVF_1_1BaseObjVar.html#a95cafb75a7ae4879dee6949a158fe0c6">getICFGNode</a>();</div>
<div class="line"><span class="lineno">   74</span>                        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFStmt.html">SVFStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt2</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrNode</a>-&gt;getSVFStmts())</div>
<div class="line"><span class="lineno">   75</span>                        {</div>
<div class="line"><span class="lineno">   76</span>                            <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1AddrStmt.html">AddrStmt</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrStmt</a> = SVFUtil::dyn_cast&lt;AddrStmt&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt2</a>))</div>
<div class="line"><span class="lineno">   77</span>                            {</div>
<div class="line"><span class="lineno">   78</span>                                size = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>.getAllocaInstByteSize(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">addrStmt</a>);</div>
<div class="line"><span class="lineno">   79</span>                            }</div>
<div class="line"><span class="lineno">   80</span>                        }</div>
<div class="line"><span class="lineno">   81</span>                    }</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>                    <span class="comment">// Calculate access offset and check for potential overflow</span></div>
<div class="line"><span class="lineno">   84</span>                    <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">accessOffset</a> = <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a0c39879a8c2cf7e2aff839fe5a7f8f3d">getAccessOffset</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>);</div>
<div class="line"><span class="lineno">   85</span>                    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">accessOffset</a>.ub().getIntNumeral() &gt;= size)</div>
<div class="line"><span class="lineno">   86</span>                    {</div>
<div class="line"><span class="lineno">   87</span>                        <a class="code hl_class" href="classSVF_1_1AEException.html">AEException</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt</a>-&gt;toString());</div>
<div class="line"><span class="lineno">   88</span>                        <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stmt</a>-&gt;getICFGNode());</div>
<div class="line"><span class="lineno">   89</span>                    }</div>
<div class="line"><span class="lineno">   90</span>                }</div>
<div class="line"><span class="lineno">   91</span>            }</div>
<div class="line"><span class="lineno">   92</span>        }</div>
<div class="line"><span class="lineno">   93</span>    }</div>
<div class="line"><span class="lineno">   94</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   95</span>    {</div>
<div class="line"><span class="lineno">   96</span>        <span class="comment">// Handle call nodes by checking for external API calls</span></div>
<div class="line"><span class="lineno">   97</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a> = SVFUtil::cast&lt;CallICFGNode&gt;(node);</div>
<div class="line"><span class="lineno">   98</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">SVFUtil::isExtCall</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getCalledFunction()))</div>
<div class="line"><span class="lineno">   99</span>        {</div>
<div class="line"><span class="lineno">  100</span>            <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ac6844230bf29cccc3b44cfb17915a13b">detectExtAPI</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>);</div>
<div class="line"><span class="lineno">  101</span>        }</div>
<div class="line"><span class="lineno">  102</span>    }</div>
<div class="line"><span class="lineno">  103</span>}</div>
<div class="ttc" id="aclassSVF_1_1AEException_html"><div class="ttname"><a href="classSVF_1_1AEException.html">SVF::AEException</a></div><div class="ttdoc">Exception class for handling errors in Abstract Execution.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00106">AEDetector.h:107</a></div></div>
<div class="ttc" id="aclassSVF_1_1AddressValue_html"><div class="ttname"><a href="classSVF_1_1AddressValue.html">SVF::AddressValue</a></div><div class="ttdef"><b>Definition</b> <a href="AddressValue_8h_source.html#l00043">AddressValue.h:44</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a0c39879a8c2cf7e2aff839fe5a7f8f3d"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a0c39879a8c2cf7e2aff839fe5a7f8f3d">SVF::BufOverflowDetector::getAccessOffset</a></div><div class="ttdeci">IntervalValue getAccessOffset(AbstractState &amp;as, NodeID objId, const GepStmt *gep)</div><div class="ttdoc">Retrieves the access offset for a given object and GEP statement.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00313">AEDetector.cpp:313</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_aae254384e3dbe204c07b5f0776f7d07d"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#aae254384e3dbe204c07b5f0776f7d07d">SVF::BufOverflowDetector::updateGepObjOffsetFromBase</a></div><div class="ttdeci">void updateGepObjOffsetFromBase(AddressValue gepAddrs, AddressValue objAddrs, IntervalValue offset)</div><div class="ttdoc">Updates the offset of a GEP object from its base.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00345">AEDetector.cpp:345</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_ac6844230bf29cccc3b44cfb17915a13b"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#ac6844230bf29cccc3b44cfb17915a13b">SVF::BufOverflowDetector::detectExtAPI</a></div><div class="ttdeci">void detectExtAPI(AbstractState &amp;as, const CallICFGNode *call)</div><div class="ttdoc">Handles external API calls related to buffer overflow detection.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00219">AEDetector.cpp:219</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_ae8fe081d8a287976c6b02e0b5030bc6b"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">SVF::BufOverflowDetector::addBugToReporter</a></div><div class="ttdeci">void addBugToReporter(const AEException &amp;e, const ICFGNode *node)</div><div class="ttdoc">Adds a bug to the reporter based on an exception.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00232">AEDetector.h:232</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html">SVF::CallICFGNode</a></div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00422">ICFGNode.h:423</a></div></div>
<div class="ttc" id="aclassSVF_1_1GepStmt_html"><div class="ttname"><a href="classSVF_1_1GepStmt.html">SVF::GepStmt</a></div><div class="ttdef"><b>Definition</b> <a href="SVFStatements_8h_source.html#l00522">SVFStatements.h:523</a></div></div>
<div class="ttc" id="aclassSVF_1_1IntervalValue_html_aa027be2f9243ce4cae799b265b019443"><div class="ttname"><a href="classSVF_1_1IntervalValue.html#aa027be2f9243ce4cae799b265b019443">SVF::IntervalValue::bottom</a></div><div class="ttdeci">static IntervalValue bottom()</div><div class="ttdoc">Create the bottom IntervalValue [+inf, -inf].</div><div class="ttdef"><b>Definition</b> <a href="IntervalValue_8h_source.html#l00100">IntervalValue.h:100</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a22ef185e767ff76c098e75126c885400"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const SVFFunction *fun)</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00269">SVFUtil.h:269</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6844230bf29cccc3b44cfb17915a13b" name="ac6844230bf29cccc3b44cfb17915a13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6844230bf29cccc3b44cfb17915a13b">&#9670;&#160;</a></span>detectExtAPI()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufOverflowDetector::detectExtAPI </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles external API calls related to buffer overflow detection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function checks the type of external memory API (e.g., memcpy, memset, strcpy, strcat) and applies the corresponding buffer overflow checks based on predefined rules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00219">219</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  221</span>{</div>
<div class="line"><span class="lineno">  222</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>() &amp;&amp; <span class="stringliteral">&quot;SVFFunction* is nullptr&quot;</span>);</div>
<div class="line"><span class="lineno">  223</span> </div>
<div class="line"><span class="lineno">  224</span>    <a class="code hl_enumeration" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670">AbsExtAPI::ExtAPIType</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> = <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aa977e421a7301ae86adce6f903b88dec">AbsExtAPI::UNCLASSIFIED</a>;</div>
<div class="line"><span class="lineno">  225</span> </div>
<div class="line"><span class="lineno">  226</span>    <span class="comment">// Determine the type of external memory API</span></div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string &amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">annotation</a> : <a class="code hl_class" href="classSVF_1_1ExtAPI.html">ExtAPI</a>::getExtAPI()-&gt;getExtFuncAnnotations(call-&gt;getCalledFunction()))</div>
<div class="line"><span class="lineno">  228</span>    {</div>
<div class="line"><span class="lineno">  229</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">annotation</a>.find(<span class="stringliteral">&quot;MEMCPY&quot;</span>) != std::string::npos)</div>
<div class="line"><span class="lineno">  230</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> = <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aff39fd0bbf8e04357eb1281a7ab8e938">AbsExtAPI::MEMCPY</a>;</div>
<div class="line"><span class="lineno">  231</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">annotation</a>.find(<span class="stringliteral">&quot;MEMSET&quot;</span>) != std::string::npos)</div>
<div class="line"><span class="lineno">  232</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> = <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670ae739cb8f6f26620771403f6290c1b4e6">AbsExtAPI::MEMSET</a>;</div>
<div class="line"><span class="lineno">  233</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">annotation</a>.find(<span class="stringliteral">&quot;STRCPY&quot;</span>) != std::string::npos)</div>
<div class="line"><span class="lineno">  234</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> = <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670adebe1478d4a4b8d77b9929ed5cfc5255">AbsExtAPI::STRCPY</a>;</div>
<div class="line"><span class="lineno">  235</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">annotation</a>.find(<span class="stringliteral">&quot;STRCAT&quot;</span>) != std::string::npos)</div>
<div class="line"><span class="lineno">  236</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> = <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aa4de9da88bd25ff9485007fa457de443">AbsExtAPI::STRCAT</a>;</div>
<div class="line"><span class="lineno">  237</span>    }</div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span>    <span class="comment">// Apply buffer overflow checks based on the determined API type</span></div>
<div class="line"><span class="lineno">  240</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> == <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aff39fd0bbf8e04357eb1281a7ab8e938">AbsExtAPI::MEMCPY</a>)</div>
<div class="line"><span class="lineno">  241</span>    {</div>
<div class="line"><span class="lineno">  242</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>.count(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>()) == 0)</div>
<div class="line"><span class="lineno">  243</span>        {</div>
<div class="line"><span class="lineno">  244</span>            <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aa4f76b6289e99c6660a34475c4b66074">SVFUtil::errs</a>() &lt;&lt; <span class="stringliteral">&quot;Warning: &quot;</span> &lt;&lt; call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>() &lt;&lt; <span class="stringliteral">&quot; is not in the rules, please implement it\n&quot;</span>;</div>
<div class="line"><span class="lineno">  245</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  246</span>        }</div>
<div class="line"><span class="lineno">  247</span>        std::vector&lt;std::pair&lt;u32_t, u32_t&gt;&gt; args =</div>
<div class="line"><span class="lineno">  248</span>                                              <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>.at(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>());</div>
<div class="line"><span class="lineno">  249</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a> : args)</div>
<div class="line"><span class="lineno">  250</span>        {</div>
<div class="line"><span class="lineno">  251</span>            <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a>.second)-&gt;<a class="code hl_function" href="classSVF_1_1SVFBaseNode.html#ab2211bc249e7cc9f26255fb184fd4eae">getId</a>()].getInterval() - <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a>(1);</div>
<div class="line"><span class="lineno">  252</span>            <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">argVar</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a>.first);</div>
<div class="line"><span class="lineno">  253</span>            <span class="keywordflow">if</span> (!<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">argVar</a>, <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>))</div>
<div class="line"><span class="lineno">  254</span>            {</div>
<div class="line"><span class="lineno">  255</span>                <a class="code hl_class" href="classSVF_1_1AEException.html">AEException</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a05607292d6ee32db702fa36aa8bd894e">toString</a>());</div>
<div class="line"><span class="lineno">  256</span>                <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>, call);</div>
<div class="line"><span class="lineno">  257</span>            }</div>
<div class="line"><span class="lineno">  258</span>        }</div>
<div class="line"><span class="lineno">  259</span>    }</div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> == <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670ae739cb8f6f26620771403f6290c1b4e6">AbsExtAPI::MEMSET</a>)</div>
<div class="line"><span class="lineno">  261</span>    {</div>
<div class="line"><span class="lineno">  262</span>        <span class="keywordflow">if</span> (<a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>.count(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>()) == 0)</div>
<div class="line"><span class="lineno">  263</span>        {</div>
<div class="line"><span class="lineno">  264</span>            <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aa4f76b6289e99c6660a34475c4b66074">SVFUtil::errs</a>() &lt;&lt; <span class="stringliteral">&quot;Warning: &quot;</span> &lt;&lt; call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>() &lt;&lt; <span class="stringliteral">&quot; is not in the rules, please implement it\n&quot;</span>;</div>
<div class="line"><span class="lineno">  265</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  266</span>        }</div>
<div class="line"><span class="lineno">  267</span>        std::vector&lt;std::pair&lt;u32_t, u32_t&gt;&gt; args =</div>
<div class="line"><span class="lineno">  268</span>                                              <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>.at(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>());</div>
<div class="line"><span class="lineno">  269</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a> : args)</div>
<div class="line"><span class="lineno">  270</span>        {</div>
<div class="line"><span class="lineno">  271</span>            <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a>.second)-&gt;<a class="code hl_function" href="classSVF_1_1SVFBaseNode.html#ab2211bc249e7cc9f26255fb184fd4eae">getId</a>()].getInterval() - <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a>(1);</div>
<div class="line"><span class="lineno">  272</span>            <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">argVar</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a>.first);</div>
<div class="line"><span class="lineno">  273</span>            <span class="keywordflow">if</span> (!<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">argVar</a>, <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>))</div>
<div class="line"><span class="lineno">  274</span>            {</div>
<div class="line"><span class="lineno">  275</span>                <a class="code hl_class" href="classSVF_1_1AEException.html">AEException</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a05607292d6ee32db702fa36aa8bd894e">toString</a>());</div>
<div class="line"><span class="lineno">  276</span>                <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>, call);</div>
<div class="line"><span class="lineno">  277</span>            }</div>
<div class="line"><span class="lineno">  278</span>        }</div>
<div class="line"><span class="lineno">  279</span>    }</div>
<div class="line"><span class="lineno">  280</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> == <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670adebe1478d4a4b8d77b9929ed5cfc5255">AbsExtAPI::STRCPY</a>)</div>
<div class="line"><span class="lineno">  281</span>    {</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">if</span> (!<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a4492568641edcdd0f882bed1a0bbe3b5">detectStrcpy</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, call))</div>
<div class="line"><span class="lineno">  283</span>        {</div>
<div class="line"><span class="lineno">  284</span>            <a class="code hl_class" href="classSVF_1_1AEException.html">AEException</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a05607292d6ee32db702fa36aa8bd894e">toString</a>());</div>
<div class="line"><span class="lineno">  285</span>            <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>, call);</div>
<div class="line"><span class="lineno">  286</span>        }</div>
<div class="line"><span class="lineno">  287</span>    }</div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">extType</a> == <a class="code hl_enumvalue" href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aa4de9da88bd25ff9485007fa457de443">AbsExtAPI::STRCAT</a>)</div>
<div class="line"><span class="lineno">  289</span>    {</div>
<div class="line"><span class="lineno">  290</span>        <span class="keywordflow">if</span> (!<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a6332a437555eb3b503741d420f633292">detectStrcat</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, call))</div>
<div class="line"><span class="lineno">  291</span>        {</div>
<div class="line"><span class="lineno">  292</span>            <a class="code hl_class" href="classSVF_1_1AEException.html">AEException</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>(call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a05607292d6ee32db702fa36aa8bd894e">toString</a>());</div>
<div class="line"><span class="lineno">  293</span>            <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ae8fe081d8a287976c6b02e0b5030bc6b">addBugToReporter</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bug</a>, call);</div>
<div class="line"><span class="lineno">  294</span>        }</div>
<div class="line"><span class="lineno">  295</span>    }</div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  297</span>    {</div>
<div class="line"><span class="lineno">  298</span>        <span class="comment">// Handle other cases</span></div>
<div class="line"><span class="lineno">  299</span>    }</div>
<div class="line"><span class="lineno">  300</span>}</div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670">SVF::AbsExtAPI::ExtAPIType</a></div><div class="ttdeci">ExtAPIType</div><div class="ttdoc">Enumeration of external API types.</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670aa4de9da88bd25ff9485007fa457de443"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aa4de9da88bd25ff9485007fa457de443">SVF::AbsExtAPI::STRCAT</a></div><div class="ttdeci">@ STRCAT</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670aa977e421a7301ae86adce6f903b88dec"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aa977e421a7301ae86adce6f903b88dec">SVF::AbsExtAPI::UNCLASSIFIED</a></div><div class="ttdeci">@ UNCLASSIFIED</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670adebe1478d4a4b8d77b9929ed5cfc5255"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670adebe1478d4a4b8d77b9929ed5cfc5255">SVF::AbsExtAPI::STRCPY</a></div><div class="ttdeci">@ STRCPY</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670ae739cb8f6f26620771403f6290c1b4e6"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670ae739cb8f6f26620771403f6290c1b4e6">SVF::AbsExtAPI::MEMSET</a></div><div class="ttdeci">@ MEMSET</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_ac30c873a83c91e3ead2c55783de34670aff39fd0bbf8e04357eb1281a7ab8e938"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#ac30c873a83c91e3ead2c55783de34670aff39fd0bbf8e04357eb1281a7ab8e938">SVF::AbsExtAPI::MEMCPY</a></div><div class="ttdeci">@ MEMCPY</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8h_source.html#l00052">AbsExtAPI.h:52</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a416ec25c8bb80b8bb241adc0e5216bc0"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">SVF::BufOverflowDetector::extAPIBufOverflowCheckRules</a></div><div class="ttdeci">Map&lt; std::string, std::vector&lt; std::pair&lt; u32_t, u32_t &gt; &gt; &gt; extAPIBufOverflowCheckRules</div><div class="ttdoc">Rules for checking buffer overflows in external APIs.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00318">AEDetector.h:318</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a4492568641edcdd0f882bed1a0bbe3b5"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a4492568641edcdd0f882bed1a0bbe3b5">SVF::BufOverflowDetector::detectStrcpy</a></div><div class="ttdeci">bool detectStrcpy(AbstractState &amp;as, const CallICFGNode *call)</div><div class="ttdoc">Detects buffer overflow in 'strcpy' function calls.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00396">AEDetector.cpp:396</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a6332a437555eb3b503741d420f633292"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a6332a437555eb3b503741d420f633292">SVF::BufOverflowDetector::detectStrcat</a></div><div class="ttdeci">bool detectStrcat(AbstractState &amp;as, const CallICFGNode *call)</div><div class="ttdoc">Detects buffer overflow in 'strcat' function calls.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00414">AEDetector.cpp:414</a></div></div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_ab76fcd4f6b7e832f56e918a811532173"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">SVF::BufOverflowDetector::canSafelyAccessMemory</a></div><div class="ttdeci">bool canSafelyAccessMemory(AbstractState &amp;as, const SVFVar *value, const IntervalValue &amp;len)</div><div class="ttdoc">Checks if memory can be safely accessed.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8cpp_source.html#l00455">AEDetector.cpp:455</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_a05607292d6ee32db702fa36aa8bd894e"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#a05607292d6ee32db702fa36aa8bd894e">SVF::CallICFGNode::toString</a></div><div class="ttdeci">const std::string toString() const override</div><div class="ttdef"><b>Definition</b> <a href="ICFG_8cpp_source.html#l00131">ICFG.cpp:131</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_a170acd29312b20ce4cbe221d7b23d11c"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">SVF::CallICFGNode::getArgument</a></div><div class="ttdeci">const ValVar * getArgument(u32_t ArgNo) const</div><div class="ttdoc">Parameter operations.</div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00500">ICFGNode.h:500</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_aa88b430ddc953a328bca872d0cc51944"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">SVF::CallICFGNode::getCalledFunction</a></div><div class="ttdeci">const SVFFunction * getCalledFunction() const</div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00518">ICFGNode.h:518</a></div></div>
<div class="ttc" id="aclassSVF_1_1ExtAPI_html"><div class="ttname"><a href="classSVF_1_1ExtAPI.html">SVF::ExtAPI</a></div><div class="ttdef"><b>Definition</b> <a href="ExtAPI_8h_source.html#l00044">ExtAPI.h:45</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFValue_html_a6199dc50e561bb2224a0e66b2a6425be"><div class="ttname"><a href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">SVF::SVFValue::getName</a></div><div class="ttdeci">const std::string &amp; getName() const</div><div class="ttdef"><b>Definition</b> <a href="SVFValue_8h_source.html#l00244">SVFValue.h:244</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFVar_html"><div class="ttname"><a href="classSVF_1_1SVFVar.html">SVF::SVFVar</a></div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00046">SVFVariables.h:47</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_aa4f76b6289e99c6660a34475c4b66074"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aa4f76b6289e99c6660a34475c4b66074">SVF::SVFUtil::errs</a></div><div class="ttdeci">std::ostream &amp; errs()</div><div class="ttdoc">Overwrite llvm::errs()</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00056">SVFUtil.h:56</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6332a437555eb3b503741d420f633292" name="a6332a437555eb3b503741d420f633292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6332a437555eb3b503741d420f633292">&#9670;&#160;</a></span>detectStrcat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> BufOverflowDetector::detectStrcat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects buffer overflow in 'strcat' function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a buffer overflow is detected, false otherwise.</dd></dl>
<p>This function checks if the destination buffer can safely accommodate both the existing string and the concatenated string from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the memory access is safe, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00414">414</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  415</span>{</div>
<div class="line"><span class="lineno">  416</span>    <span class="keyword">const</span> std::vector&lt;std::string&gt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strcatGroup</a> = {<span class="stringliteral">&quot;__strcat_chk&quot;</span>, <span class="stringliteral">&quot;strcat&quot;</span>, <span class="stringliteral">&quot;__wcscat_chk&quot;</span>, <span class="stringliteral">&quot;wcscat&quot;</span>};</div>
<div class="line"><span class="lineno">  417</span>    <span class="keyword">const</span> std::vector&lt;std::string&gt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strncatGroup</a> = {<span class="stringliteral">&quot;__strncat_chk&quot;</span>, <span class="stringliteral">&quot;strncat&quot;</span>, <span class="stringliteral">&quot;__wcsncat_chk&quot;</span>, <span class="stringliteral">&quot;wcsncat&quot;</span>};</div>
<div class="line"><span class="lineno">  418</span> </div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordflow">if</span> (std::find(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strcatGroup</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strcatGroup</a>.end(), call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>()) != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strcatGroup</a>.end())</div>
<div class="line"><span class="lineno">  420</span>    {</div>
<div class="line"><span class="lineno">  421</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(0);</div>
<div class="line"><span class="lineno">  422</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg1Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(1);</div>
<div class="line"><span class="lineno">  423</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen0</a> = <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#ac9465083ff86b7488079d3f4011b1fba">getUtils</a>()-&gt;<a class="code hl_function" href="classSVF_1_1AbsExtAPI.html#a547c5d9e1464bab6f0e05a9705c7a28a">getStrlen</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>);</div>
<div class="line"><span class="lineno">  424</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen1</a> = <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#ac9465083ff86b7488079d3f4011b1fba">getUtils</a>()-&gt;<a class="code hl_function" href="classSVF_1_1AbsExtAPI.html#a547c5d9e1464bab6f0e05a9705c7a28a">getStrlen</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg1Val</a>);</div>
<div class="line"><span class="lineno">  425</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">totalLen</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen0</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen1</a>;</div>
<div class="line"><span class="lineno">  426</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">totalLen</a>);</div>
<div class="line"><span class="lineno">  427</span>    }</div>
<div class="line"><span class="lineno">  428</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (std::find(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strncatGroup</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strncatGroup</a>.end(), call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#aa88b430ddc953a328bca872d0cc51944">getCalledFunction</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a6199dc50e561bb2224a0e66b2a6425be">getName</a>()) != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strncatGroup</a>.end())</div>
<div class="line"><span class="lineno">  429</span>    {</div>
<div class="line"><span class="lineno">  430</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(0);</div>
<div class="line"><span class="lineno">  431</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg2Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(2);</div>
<div class="line"><span class="lineno">  432</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg2Num</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg2Val</a>-&gt;getId()].getInterval();</div>
<div class="line"><span class="lineno">  433</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen0</a> = <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#ac9465083ff86b7488079d3f4011b1fba">getUtils</a>()-&gt;<a class="code hl_function" href="classSVF_1_1AbsExtAPI.html#a547c5d9e1464bab6f0e05a9705c7a28a">getStrlen</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>);</div>
<div class="line"><span class="lineno">  434</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">totalLen</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen0</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg2Num</a>;</div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">totalLen</a>);</div>
<div class="line"><span class="lineno">  436</span>    }</div>
<div class="line"><span class="lineno">  437</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  438</span>    {</div>
<div class="line"><span class="lineno">  439</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Unknown strcat function, please add it to strcatGroup or strncatGroup&quot;</span>);</div>
<div class="line"><span class="lineno">  440</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">abort</a>();</div>
<div class="line"><span class="lineno">  441</span>    }</div>
<div class="line"><span class="lineno">  442</span>}</div>
<div class="ttc" id="aclassSVF_1_1AbsExtAPI_html_a547c5d9e1464bab6f0e05a9705c7a28a"><div class="ttname"><a href="classSVF_1_1AbsExtAPI.html#a547c5d9e1464bab6f0e05a9705c7a28a">SVF::AbsExtAPI::getStrlen</a></div><div class="ttdeci">IntervalValue getStrlen(AbstractState &amp;as, const SVF::SVFVar *strValue)</div><div class="ttdoc">Calculates the length of a string.</div><div class="ttdef"><b>Definition</b> <a href="AbsExtAPI_8cpp_source.html#l00468">AbsExtAPI.cpp:468</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbstractInterpretation_html_a1d9e03a8dfd9cca940cac16f954d659a"><div class="ttname"><a href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">SVF::AbstractInterpretation::getAEInstance</a></div><div class="ttdeci">static AbstractInterpretation &amp; getAEInstance()</div><div class="ttdef"><b>Definition</b> <a href="AbstractInterpretation_8h_source.html#l00121">AbstractInterpretation.h:121</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbstractInterpretation_html_ac9465083ff86b7488079d3f4011b1fba"><div class="ttname"><a href="classSVF_1_1AbstractInterpretation.html#ac9465083ff86b7488079d3f4011b1fba">SVF::AbstractInterpretation::getUtils</a></div><div class="ttdeci">AbsExtAPI * getUtils()</div><div class="ttdef"><b>Definition</b> <a href="AbstractInterpretation_8h_source.html#l00277">AbstractInterpretation.h:277</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4492568641edcdd0f882bed1a0bbe3b5" name="a4492568641edcdd0f882bed1a0bbe3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4492568641edcdd0f882bed1a0bbe3b5">&#9670;&#160;</a></span>detectStrcpy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> BufOverflowDetector::detectStrcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Detects buffer overflow in 'strcpy' function calls. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a buffer overflow is detected, false otherwise.</dd></dl>
<p>This function checks if the destination buffer can safely accommodate the source string being copied, accounting for the null terminator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the memory access is safe, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00396">396</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  397</span>{</div>
<div class="line"><span class="lineno">  398</span>    <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(0);</div>
<div class="line"><span class="lineno">  399</span>    <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg1Val</a> = call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a170acd29312b20ce4cbe221d7b23d11c">getArgument</a>(1);</div>
<div class="line"><span class="lineno">  400</span>    <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen</a> = <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#ac9465083ff86b7488079d3f4011b1fba">getUtils</a>()-&gt;<a class="code hl_function" href="classSVF_1_1AbsExtAPI.html#a547c5d9e1464bab6f0e05a9705c7a28a">getStrlen</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg1Val</a>);</div>
<div class="line"><span class="lineno">  401</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">strLen</a>);</div>
<div class="line"><span class="lineno">  402</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c39879a8c2cf7e2aff839fe5a7f8f3d" name="a0c39879a8c2cf7e2aff839fe5a7f8f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c39879a8c2cf7e2aff839fe5a7f8f3d">&#9670;&#160;</a></span>getAccessOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> BufOverflowDetector::getAccessOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AbstractState.html">SVF::AbstractState</a> &amp;&#160;</td>
          <td class="paramname"><em>as</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a>&#160;</td>
          <td class="paramname"><em>objId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepStmt.html">GepStmt</a> *&#160;</td>
          <td class="paramname"><em>gep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the access offset for a given object and GEP statement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">objId</td><td>The ID of the object. </td></tr>
    <tr><td class="paramname">gep</td><td>Pointer to the GEP statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval value of the access offset.</dd></dl>
<p>This function calculates the access offset for a base object or a sub-object of an aggregate object (using GEP). If the object is a dummy object, it returns a top interval value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">as</td><td>Reference to the abstract state. </td></tr>
    <tr><td class="paramname">objId</td><td>The ID of the object. </td></tr>
    <tr><td class="paramname">gep</td><td>Pointer to the GEP statement. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval value of the access offset. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00313">313</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  314</span>{</div>
<div class="line"><span class="lineno">  315</span>    <a class="code hl_class" href="classSVF_1_1SVFIR.html">SVFIR</a>* svfir = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>();</div>
<div class="line"><span class="lineno">  316</span>    <span class="keyword">auto</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a> = svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>);</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span>    <span class="comment">// if the object is a BaseObjVar, return the byte offset directly</span></div>
<div class="line"><span class="lineno">  319</span>    <span class="keywordflow">if</span> (SVFUtil::isa&lt;BaseObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>))</div>
<div class="line"><span class="lineno">  320</span>    {</div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>.getByteOffset(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>);</div>
<div class="line"><span class="lineno">  322</span>    }</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SVFUtil::isa&lt;GepObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>))</div>
<div class="line"><span class="lineno">  324</span>    {</div>
<div class="line"><span class="lineno">  325</span>        <span class="comment">// if the object is a GepObjVar, return the offset from the base object</span></div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a6cd23cec47be6d202ab2fc5dce3f664b">getGepObjOffsetFromBase</a>(SVFUtil::cast&lt;GepObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>)) + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>.getByteOffset(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gep</a>);</div>
<div class="line"><span class="lineno">  327</span>    }</div>
<div class="line"><span class="lineno">  328</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  329</span>    {</div>
<div class="line"><span class="lineno">  330</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(SVFUtil::isa&lt;DummyObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>) &amp;&amp; <span class="stringliteral">&quot;Unknown object type&quot;</span>);</div>
<div class="line"><span class="lineno">  331</span>        <span class="keywordflow">return</span> <a class="code hl_function" href="classSVF_1_1IntervalValue.html#add3acad151d5af6c9a5f692f7a01e65b">IntervalValue::top</a>();</div>
<div class="line"><span class="lineno">  332</span>    }</div>
<div class="line"><span class="lineno">  333</span>}</div>
<div class="ttc" id="aclassSVF_1_1IntervalValue_html_add3acad151d5af6c9a5f692f7a01e65b"><div class="ttname"><a href="classSVF_1_1IntervalValue.html#add3acad151d5af6c9a5f692f7a01e65b">SVF::IntervalValue::top</a></div><div class="ttdeci">static IntervalValue top()</div><div class="ttdoc">Create the IntervalValue [-inf, +inf].</div><div class="ttdef"><b>Definition</b> <a href="IntervalValue_8h_source.html#l00094">IntervalValue.h:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cd23cec47be6d202ab2fc5dce3f664b" name="a6cd23cec47be6d202ab2fc5dce3f664b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd23cec47be6d202ab2fc5dce3f664b">&#9670;&#160;</a></span>getGepObjOffsetFromBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a> SVF::BufOverflowDetector::getGepObjOffsetFromBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the offset of a GEP object from its base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the GEP object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interval value of the offset. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00210">210</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  211</span>    {</div>
<div class="line"><span class="lineno">  212</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#aad6a7f125d4d5dc3659edc2f0f950c57">hasGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>))</div>
<div class="line"><span class="lineno">  213</span>            <span class="keywordflow">return</span> <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">gepObjOffsetFromBase</a>.at(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>);</div>
<div class="line"><span class="lineno">  214</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  215</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;GepObjVar not found in gepObjOffsetFromBase&quot;</span>);</div>
<div class="line"><span class="lineno">  216</span>    }</div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_aad6a7f125d4d5dc3659edc2f0f950c57"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#aad6a7f125d4d5dc3659edc2f0f950c57">SVF::BufOverflowDetector::hasGepObjOffsetFromBase</a></div><div class="ttdeci">bool hasGepObjOffsetFromBase(const GepObjVar *obj) const</div><div class="ttdoc">Checks if a GEP object has an associated offset.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00200">AEDetector.h:200</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa47ba77eb81cdc9f634dfaae7344a3dc" name="aa47ba77eb81cdc9f634dfaae7344a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47ba77eb81cdc9f634dfaae7344a3dc">&#9670;&#160;</a></span>handleStubFunctions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void BufOverflowDetector::handleStubFunctions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>callNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles external API calls related to buffer overflow detection. </p>
<p>Handles stub functions within the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">call</td><td>Pointer to the call <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</td></tr>
  </table>
  </dd>
</dl>
<p>This function is a placeholder for handling stub functions within the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> node. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classSVF_1_1AEDetector.html#a2455e0d20bf52a88832bf36ff414c75a">SVF::AEDetector</a>.</p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00113">113</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  114</span>{</div>
<div class="line"><span class="lineno">  115</span>    <span class="comment">// get function name</span></div>
<div class="line"><span class="lineno">  116</span>    std::string funcName = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getCalledFunction()-&gt;getName();</div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordflow">if</span> (funcName == <span class="stringliteral">&quot;SAFE_BUFACCESS&quot;</span>)</div>
<div class="line"><span class="lineno">  118</span>    {</div>
<div class="line"><span class="lineno">  119</span>        <span class="comment">// void SAFE_BUFACCESS(void* data, int size);</span></div>
<div class="line"><span class="lineno">  120</span>        <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_variable" href="classSVF_1_1AbstractInterpretation.html#a53df703db0b10df07db37f35b2586319">checkpoints</a>.erase(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>);</div>
<div class="line"><span class="lineno">  121</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;arg_size() &lt; 2)</div>
<div class="line"><span class="lineno">  122</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  123</span>        <a class="code hl_class" href="classSVF_1_1AbstractState.html">AbstractState</a>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a> =</div>
<div class="line"><span class="lineno">  124</span>            <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a4ff909b4aa70fe47c5c01a0f59eff73a">getAbsStateFromTrace</a>(</div>
<div class="line"><span class="lineno">  125</span>                <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>);</div>
<div class="line"><span class="lineno">  126</span>        <a class="code hl_typedef" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">size_id</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getArgument(1)-&gt;getId();</div>
<div class="line"><span class="lineno">  127</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">size_id</a>].getInterval();</div>
<div class="line"><span class="lineno">  128</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a>.isBottom())</div>
<div class="line"><span class="lineno">  129</span>        {</div>
<div class="line"><span class="lineno">  130</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a> = <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a>(0);</div>
<div class="line"><span class="lineno">  131</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;SAFE_BUFACCESS size is bottom&quot;</span>);</div>
<div class="line"><span class="lineno">  132</span>        }</div>
<div class="line"><span class="lineno">  133</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getArgument(0);</div>
<div class="line"><span class="lineno">  134</span>        <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isSafe</a> = <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a>);</div>
<div class="line"><span class="lineno">  135</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isSafe</a>)</div>
<div class="line"><span class="lineno">  136</span>        {</div>
<div class="line"><span class="lineno">  137</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;safe buffer access success: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;toString()</div>
<div class="line"><span class="lineno">  138</span>                      &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  139</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  140</span>        }</div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  142</span>        {</div>
<div class="line"><span class="lineno">  143</span>            std::string <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> = <span class="stringliteral">&quot;this SAFE_BUFACCESS should be a safe access but detected buffer overflow. Pos: &quot;</span>;</div>
<div class="line"><span class="lineno">  144</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> += <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getSourceLoc();</div>
<div class="line"><span class="lineno">  145</span>            std::cerr &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  146</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  147</span>        }</div>
<div class="line"><span class="lineno">  148</span>    }</div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (funcName == <span class="stringliteral">&quot;UNSAFE_BUFACCESS&quot;</span>)</div>
<div class="line"><span class="lineno">  150</span>    {</div>
<div class="line"><span class="lineno">  151</span>        <span class="comment">// handle other stub functions</span></div>
<div class="line"><span class="lineno">  152</span>        <span class="comment">//void UNSAFE_BUFACCESS(void* data, int size);</span></div>
<div class="line"><span class="lineno">  153</span>        <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_variable" href="classSVF_1_1AbstractInterpretation.html#a53df703db0b10df07db37f35b2586319">checkpoints</a>.erase(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>);</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;arg_size() &lt; 2) <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  155</span>        <a class="code hl_class" href="classSVF_1_1AbstractState.html">AbstractState</a>&amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a> = <a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a1d9e03a8dfd9cca940cac16f954d659a">AbstractInterpretation::getAEInstance</a>().<a class="code hl_function" href="classSVF_1_1AbstractInterpretation.html#a4ff909b4aa70fe47c5c01a0f59eff73a">getAbsStateFromTrace</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>);</div>
<div class="line"><span class="lineno">  156</span>        <a class="code hl_typedef" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">size_id</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getArgument(1)-&gt;getId();</div>
<div class="line"><span class="lineno">  157</span>        <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">size_id</a>].getInterval();</div>
<div class="line"><span class="lineno">  158</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a>.isBottom())</div>
<div class="line"><span class="lineno">  159</span>        {</div>
<div class="line"><span class="lineno">  160</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;UNSAFE_BUFACCESS size is bottom&quot;</span>);</div>
<div class="line"><span class="lineno">  161</span>        }</div>
<div class="line"><span class="lineno">  162</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1SVFVar.html">SVFVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getArgument(0);</div>
<div class="line"><span class="lineno">  163</span>        <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isSafe</a> = <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#ab76fcd4f6b7e832f56e918a811532173">canSafelyAccessMemory</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">as</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg0Val</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">val</a>);</div>
<div class="line"><span class="lineno">  164</span>        <span class="keywordflow">if</span> (!<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isSafe</a>)</div>
<div class="line"><span class="lineno">  165</span>        {</div>
<div class="line"><span class="lineno">  166</span>            std::cout &lt;&lt; <span class="stringliteral">&quot;detect buffer overflow success: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;toString() &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  167</span>            <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  168</span>        }</div>
<div class="line"><span class="lineno">  169</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  170</span>        {</div>
<div class="line"><span class="lineno">  171</span>            std::string <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> = <span class="stringliteral">&quot;this UNSAFE_BUFACCESS should be a buffer overflow but not detected. Pos: &quot;</span>;</div>
<div class="line"><span class="lineno">  172</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> += <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callNode</a>-&gt;getSourceLoc();</div>
<div class="line"><span class="lineno">  173</span>            std::cerr &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">err_msg</a> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno">  174</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  175</span>        }</div>
<div class="line"><span class="lineno">  176</span>    }</div>
<div class="line"><span class="lineno">  177</span>}</div>
<div class="ttc" id="aclassSVF_1_1AbstractInterpretation_html_a4ff909b4aa70fe47c5c01a0f59eff73a"><div class="ttname"><a href="classSVF_1_1AbstractInterpretation.html#a4ff909b4aa70fe47c5c01a0f59eff73a">SVF::AbstractInterpretation::getAbsStateFromTrace</a></div><div class="ttdeci">AbstractState &amp; getAbsStateFromTrace(const ICFGNode *node)</div><div class="ttdef"><b>Definition</b> <a href="AbstractInterpretation_8h_source.html#l00258">AbstractInterpretation.h:258</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbstractInterpretation_html_a53df703db0b10df07db37f35b2586319"><div class="ttname"><a href="classSVF_1_1AbstractInterpretation.html#a53df703db0b10df07db37f35b2586319">SVF::AbstractInterpretation::checkpoints</a></div><div class="ttdeci">Set&lt; const CallICFGNode * &gt; checkpoints</div><div class="ttdef"><b>Definition</b> <a href="AbstractInterpretation_8h_source.html#l00132">AbstractInterpretation.h:132</a></div></div>
<div class="ttc" id="aclassSVF_1_1AbstractState_html"><div class="ttname"><a href="classSVF_1_1AbstractState.html">SVF::AbstractState</a></div><div class="ttdef"><b>Definition</b> <a href="AbstractState_8h_source.html#l00058">AbstractState.h:59</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aad6a7f125d4d5dc3659edc2f0f950c57" name="aad6a7f125d4d5dc3659edc2f0f950c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6a7f125d4d5dc3659edc2f0f950c57">&#9670;&#160;</a></span>hasGepObjOffsetFromBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::BufOverflowDetector::hasGepObjOffsetFromBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a GEP object has an associated offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the GEP object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the GEP object has an offset, false otherwise. </dd></dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00200">200</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  201</span>    {</div>
<div class="line"><span class="lineno">  202</span>        <span class="keywordflow">return</span> <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">gepObjOffsetFromBase</a>.find(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>) != <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a3cd11f8d87ca8a2aa971349a5446f1cd">gepObjOffsetFromBase</a>.end();</div>
<div class="line"><span class="lineno">  203</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd940b41cca8134a59e87491ff0d0162" name="abd940b41cca8134a59e87491ff0d0162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd940b41cca8134a59e87491ff0d0162">&#9670;&#160;</a></span>initExtAPIBufOverflowCheckRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufOverflowDetector::initExtAPIBufOverflowCheckRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes external API buffer overflow check rules. </p>
<p>This function sets up rules for various memory-related functions like memcpy, memset, etc., defining which arguments should be checked for buffer overflows. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00185">185</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  186</span>{</div>
<div class="line"><span class="lineno">  187</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memcpy_p0i8_p0i8_i64&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  188</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memcpy_p0_p0_i64&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  189</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memcpy_p0i8_p0i8_i32&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  190</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memcpy&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  191</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memmove&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  192</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memmove_p0i8_p0i8_i64&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  193</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memmove_p0_p0_i64&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  194</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memmove_p0i8_p0i8_i32&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  195</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;__memcpy_chk&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  196</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;memmove&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  197</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;bcopy&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  198</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;memccpy&quot;</span>] = {{0, 3}, {1, 3}};</div>
<div class="line"><span class="lineno">  199</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;__memmove_chk&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  200</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memset&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  201</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memset_p0i8_i32&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  202</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memset_p0i8_i64&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  203</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;llvm_memset_p0_i64&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  204</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;__memset_chk&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  205</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;wmemset&quot;</span>] = {{0, 2}};</div>
<div class="line"><span class="lineno">  206</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;strncpy&quot;</span>] = {{0, 2}, {1, 2}};</div>
<div class="line"><span class="lineno">  207</span>    <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a416ec25c8bb80b8bb241adc0e5216bc0">extAPIBufOverflowCheckRules</a>[<span class="stringliteral">&quot;iconv&quot;</span>] = {{1, 2}, {3, 4}};</div>
<div class="line"><span class="lineno">  208</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c5cb9af3b1e74d10f11b36d88552b01" name="a9c5cb9af3b1e74d10f11b36d88552b01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5cb9af3b1e74d10f11b36d88552b01">&#9670;&#160;</a></span>reportBug()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::BufOverflowDetector::reportBug </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports all detected buffer overflow bugs. </p>

<p>Implements <a class="el" href="classSVF_1_1AEDetector.html#a4d936be5ca262a024a7554e685bddd61">SVF::AEDetector</a>.</p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00264">264</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  265</span>    {</div>
<div class="line"><span class="lineno">  266</span>        <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">nodeToBugInfo</a>.empty())</div>
<div class="line"><span class="lineno">  267</span>        {</div>
<div class="line"><span class="lineno">  268</span>            std::cerr &lt;&lt; <span class="stringliteral">&quot;######################Buffer Overflow (&quot;</span> + std::to_string(<a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">nodeToBugInfo</a>.size())</div>
<div class="line"><span class="lineno">  269</span>                      + <span class="stringliteral">&quot; found)######################\n&quot;</span>;</div>
<div class="line"><span class="lineno">  270</span>            std::cerr &lt;&lt; <span class="stringliteral">&quot;---------------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno">  271</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">it</a> : <a class="code hl_variable" href="classSVF_1_1BufOverflowDetector.html#a9d0a7fa63e5898380111edef2c748ce8">nodeToBugInfo</a>)</div>
<div class="line"><span class="lineno">  272</span>            {</div>
<div class="line"><span class="lineno">  273</span>                std::cerr &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">it</a>.second &lt;&lt; <span class="stringliteral">&quot;\n---------------------------------------------\n&quot;</span>;</div>
<div class="line"><span class="lineno">  274</span>            }</div>
<div class="line"><span class="lineno">  275</span>        }</div>
<div class="line"><span class="lineno">  276</span>    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae254384e3dbe204c07b5f0776f7d07d" name="aae254384e3dbe204c07b5f0776f7d07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae254384e3dbe204c07b5f0776f7d07d">&#9670;&#160;</a></span>updateGepObjOffsetFromBase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BufOverflowDetector::updateGepObjOffsetFromBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AddressValue.html">SVF::AddressValue</a>&#160;</td>
          <td class="paramname"><em>gepAddrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSVF_1_1AddressValue.html">SVF::AddressValue</a>&#160;</td>
          <td class="paramname"><em>objAddrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSVF_1_1IntervalValue.html">SVF::IntervalValue</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the offset of a GEP object from its base. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gepAddrs</td><td>Address value for GEP. </td></tr>
    <tr><td class="paramname">objAddrs</td><td>Address value for the object. </td></tr>
    <tr><td class="paramname">offset</td><td>The interval value of the offset.</td></tr>
  </table>
  </dd>
</dl>
<p>This function calculates and stores the offset of a GEP object from its base object using the addresses and offsets provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gepAddrs</td><td>The addresses of the GEP objects. </td></tr>
    <tr><td class="paramname">objAddrs</td><td>The addresses of the base objects. </td></tr>
    <tr><td class="paramname">offset</td><td>The interval value of the offset. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="AEDetector_8cpp_source.html#l00345">345</a> of file <a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  346</span>{</div>
<div class="line"><span class="lineno">  347</span>    <a class="code hl_class" href="classSVF_1_1SVFIR.html">SVFIR</a>* svfir = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>();</div>
<div class="line"><span class="lineno">  348</span> </div>
<div class="line"><span class="lineno">  349</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddr</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddrs</a>)</div>
<div class="line"><span class="lineno">  350</span>    {</div>
<div class="line"><span class="lineno">  351</span>        <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a> = <a class="code hl_function" href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">AbstractState::getInternalID</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objAddr</a>);</div>
<div class="line"><span class="lineno">  352</span>        <span class="keyword">auto</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a> = svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objId</a>);</div>
<div class="line"><span class="lineno">  353</span>        <span class="comment">// if the object is a BaseObjVar, add the offset directly</span></div>
<div class="line"><span class="lineno">  354</span>        <span class="keywordflow">if</span> (SVFUtil::isa&lt;BaseObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>))</div>
<div class="line"><span class="lineno">  355</span>        {</div>
<div class="line"><span class="lineno">  356</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddr</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddrs</a>)</div>
<div class="line"><span class="lineno">  357</span>            {</div>
<div class="line"><span class="lineno">  358</span>                <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObj</a> = <a class="code hl_function" href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">AbstractState::getInternalID</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddr</a>);</div>
<div class="line"><span class="lineno">  359</span>                <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1GepObjVar.html">GepObjVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObjVar</a> = SVFUtil::cast&lt;GepObjVar&gt;(svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObj</a>));</div>
<div class="line"><span class="lineno">  360</span>                <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a0c55cec78c768443052cecea69a6c203">addToGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObjVar</a>, <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>);</div>
<div class="line"><span class="lineno">  361</span>            }</div>
<div class="line"><span class="lineno">  362</span>        }</div>
<div class="line"><span class="lineno">  363</span>        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (SVFUtil::isa&lt;GepObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>))</div>
<div class="line"><span class="lineno">  364</span>        {</div>
<div class="line"><span class="lineno">  365</span>            <span class="comment">// if the object is a GepObjVar, add the offset from the base object</span></div>
<div class="line"><span class="lineno">  366</span>            <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1GepObjVar.html">GepObjVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objVar</a> = SVFUtil::cast&lt;GepObjVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">obj</a>);</div>
<div class="line"><span class="lineno">  367</span>            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddr</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddrs</a>)</div>
<div class="line"><span class="lineno">  368</span>            {</div>
<div class="line"><span class="lineno">  369</span>                <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObj</a> = <a class="code hl_function" href="classSVF_1_1AbstractState.html#aaabe5850dbf1620c6058f5ac6cb169b6">AbstractState::getInternalID</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepAddr</a>);</div>
<div class="line"><span class="lineno">  370</span>                <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1GepObjVar.html">GepObjVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObjVar</a> = SVFUtil::cast&lt;GepObjVar&gt;(svfir-&gt;<a class="code hl_function" href="classSVF_1_1GenericGraph.html#ad6b861a4aa6eca7902410a7005d86707">getGNode</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObj</a>));</div>
<div class="line"><span class="lineno">  371</span>                <span class="keywordflow">if</span> (<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#aad6a7f125d4d5dc3659edc2f0f950c57">hasGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objVar</a>))</div>
<div class="line"><span class="lineno">  372</span>                {</div>
<div class="line"><span class="lineno">  373</span>                    <a class="code hl_class" href="classSVF_1_1IntervalValue.html">IntervalValue</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objOffsetFromBase</a> = <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a6cd23cec47be6d202ab2fc5dce3f664b">getGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objVar</a>);</div>
<div class="line"><span class="lineno">  374</span>                    <span class="keywordflow">if</span> (!<a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#aad6a7f125d4d5dc3659edc2f0f950c57">hasGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObjVar</a>))</div>
<div class="line"><span class="lineno">  375</span>                        <a class="code hl_function" href="classSVF_1_1BufOverflowDetector.html#a0c55cec78c768443052cecea69a6c203">addToGepObjOffsetFromBase</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">gepObjVar</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">objOffsetFromBase</a> + <a class="code hl_variable" href="cJSON_8cpp.html#a95bf816579e97b6f33bdb5e25ed6d5de">offset</a>);</div>
<div class="line"><span class="lineno">  376</span>                }</div>
<div class="line"><span class="lineno">  377</span>                <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  378</span>                {</div>
<div class="line"><span class="lineno">  379</span>                    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;GEP RHS object has no offset from base&quot;</span>);</div>
<div class="line"><span class="lineno">  380</span>                }</div>
<div class="line"><span class="lineno">  381</span>            }</div>
<div class="line"><span class="lineno">  382</span>        }</div>
<div class="line"><span class="lineno">  383</span>    }</div>
<div class="line"><span class="lineno">  384</span>}</div>
<div class="ttc" id="aclassSVF_1_1BufOverflowDetector_html_a0c55cec78c768443052cecea69a6c203"><div class="ttname"><a href="classSVF_1_1BufOverflowDetector.html#a0c55cec78c768443052cecea69a6c203">SVF::BufOverflowDetector::addToGepObjOffsetFromBase</a></div><div class="ttdeci">void addToGepObjOffsetFromBase(const GepObjVar *obj, const IntervalValue &amp;offset)</div><div class="ttdoc">Adds an offset to a GEP object.</div><div class="ttdef"><b>Definition</b> <a href="AEDetector_8h_source.html#l00190">AEDetector.h:190</a></div></div>
<div class="ttc" id="aclassSVF_1_1GepObjVar_html"><div class="ttname"><a href="classSVF_1_1GepObjVar.html">SVF::GepObjVar</a></div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00737">SVFVariables.h:738</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a8bd63bb97cf4c121c55244249726ee25" name="a8bd63bb97cf4c121c55244249726ee25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd63bb97cf4c121c55244249726ee25">&#9670;&#160;</a></span>AbstractInterpretation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">friend</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="classSVF_1_1AbstractInterpretation.html">AbstractInterpretation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00135">135</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a63f1738ad44d9d07e1dcf911858ced04" name="a63f1738ad44d9d07e1dcf911858ced04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f1738ad44d9d07e1dcf911858ced04">&#9670;&#160;</a></span>bugLoc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt;std::string&gt; SVF::BufOverflowDetector::bugLoc</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set of locations where bugs have been reported. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00319">319</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<a id="a416ec25c8bb80b8bb241adc0e5216bc0" name="a416ec25c8bb80b8bb241adc0e5216bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416ec25c8bb80b8bb241adc0e5216bc0">&#9670;&#160;</a></span>extAPIBufOverflowCheckRules</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt;std::string, std::vector&lt;std::pair&lt;<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&gt; &gt; &gt; SVF::BufOverflowDetector::extAPIBufOverflowCheckRules</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rules for checking buffer overflows in external APIs. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00318">318</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<a id="a3cd11f8d87ca8a2aa971349a5446f1cd" name="a3cd11f8d87ca8a2aa971349a5446f1cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd11f8d87ca8a2aa971349a5446f1cd">&#9670;&#160;</a></span>gepObjOffsetFromBase</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1GepObjVar.html">GepObjVar</a>*, <a class="el" href="classSVF_1_1IntervalValue.html">IntervalValue</a>&gt; SVF::BufOverflowDetector::gepObjOffsetFromBase</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps GEP objects to their offsets from the base. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00317">317</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<a id="a9d0a7fa63e5898380111edef2c748ce8" name="a9d0a7fa63e5898380111edef2c748ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0a7fa63e5898380111edef2c748ce8">&#9670;&#160;</a></span>nodeToBugInfo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a>*, std::string&gt; SVF::BufOverflowDetector::nodeToBugInfo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps <a class="el" href="classSVF_1_1ICFG.html">ICFG</a> nodes to bug information. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00321">321</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<a id="a4c0f8f9afa5723d016abf2199512d921" name="a4c0f8f9afa5723d016abf2199512d921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0f8f9afa5723d016abf2199512d921">&#9670;&#160;</a></span>recoder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSVF_1_1SVFBugReport.html">SVFBugReport</a> SVF::BufOverflowDetector::recoder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recorder for abstract execution bugs. </p>

<p class="definition">Definition at line <a class="el" href="AEDetector_8h_source.html#l00320">320</a> of file <a class="el" href="AEDetector_8h_source.html">AEDetector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/SVF/SVF/svf/include/AE/Svfexe/<a class="el" href="AEDetector_8h_source.html">AEDetector.h</a></li>
<li>/home/runner/work/SVF/SVF/svf/lib/AE/Svfexe/<a class="el" href="AEDetector_8cpp_source.html">AEDetector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
