<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: /home/runner/work/SVF/SVF/svf/include/Util/SVFUtil.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f984cfbe93434e3daf67f2a9bd6d521f.html">svf</a></li><li class="navelem"><a class="el" href="dir_390f2a6be5eff59a6919ecbd9cc9f31d.html">include</a></li><li class="navelem"><a class="el" href="dir_445b24f35a8ddd2effd3d23ee1278e0a.html">Util</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SVFUtil.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="fastcluster_8h_source.html">FastCluster/fastcluster.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SVFValue_8h_source.html">SVFIR/SVFValue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SVFModule_8h_source.html">SVFIR/SVFModule.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ExtAPI_8h_source.html">Util/ExtAPI.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PointsTo_8h_source.html">MemoryModel/PointsTo.h</a>&quot;</code><br />
<code>#include &lt;time.h&gt;</code><br />
</div>
<p><a href="SVFUtil_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">SVF::SVFUtil::make_void&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">void_t is not available until C++17. We define it here for C++11/14.  <a href="structSVF_1_1SVFUtil_1_1make__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">SVF::SVFUtil::is_iterable&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that checks if a type is iterable (can be applied on a range-based for loop)  <a href="structSVF_1_1SVFUtil_1_1is__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable_3_01T_00_01void__t_3_01decltype_07std_1_1begin_07std_1_1dec794949348c8e1e00603fd8633b6dd1f3.html">SVF::SVFUtil::is_iterable&lt; T, void_t&lt; decltype(std::begin(std::declval&lt; T &amp; &gt;()) !=std::end(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">SVF::SVFUtil::is_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a map or unordered_map.  <a href="structSVF_1_1SVFUtil_1_1is__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1map_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_map&lt; std::map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1unordered__map_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_map&lt; std::unordered_map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">SVF::SVFUtil::is_set&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a set or unordered_set.  <a href="structSVF_1_1SVFUtil_1_1is__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1set_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_set&lt; std::set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1unordered__set_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_set&lt; std::unordered_set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">SVF::SVFUtil::is_sequence_container&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is vector or list.  <a href="structSVF_1_1SVFUtil_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1vector_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_sequence_container&lt; std::vector&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1deque_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_sequence_container&lt; std::deque&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1list_3_01Ts_8_8_8_01_4_01_4.html">SVF::SVFUtil::is_sequence_container&lt; std::list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSVF"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF.html">SVF</a></td></tr>
<tr class="memdesc:namespaceSVF"><td class="mdescLeft">&#160;</td><td class="mdescRight">for isBitcode <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSVF_1_1SVFUtil"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVF::SVFUtil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac047d963ed4b701c83958868ab36202f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac047d963ed4b701c83958868ab36202f">SVF::SVFUtil::equalPointsTo</a></td></tr>
<tr class="separator:ac047d963ed4b701c83958868ab36202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66b86171786cc34b798f05f67f321e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acb66b86171786cc34b798f05f67f321e">SVF::SVFUtil::equalNodeBS</a></td></tr>
<tr class="separator:acb66b86171786cc34b798f05f67f321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top">typedef OrderedSet&lt; PointsTo, equalPointsTo &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aed0b0b9f035057552a6a82154fd88e61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a> ()</td></tr>
<tr class="memdesc:aed0b0b9f035057552a6a82154fd88e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs()">llvm::outs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">More...</a><br /></td></tr>
<tr class="separator:aed0b0b9f035057552a6a82154fd88e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">SVF::SVFUtil::errs</a> ()</td></tr>
<tr class="memdesc:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs()">llvm::errs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">More...</a><br /></td></tr>
<tr class="separator:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a> (<a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">More...</a><br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">SVF::SVFUtil::dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">SVF::SVFUtil::dumpPointsToSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <a href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">More...</a><br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">SVF::SVFUtil::dumpSparseSet</a> (const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;To)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">SVF::SVFUtil::dumpAliasSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <a href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">More...</a><br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a05dc00b2bd9a8176aae31b6cfffe725d">SVF::SVFUtil::sucMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <a href="namespaceSVF_1_1SVFUtil.html#a05dc00b2bd9a8176aae31b6cfffe725d">More...</a><br /></td></tr>
<tr class="separator:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71522e8c55f84cfc6c13a0ddff18436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">SVF::SVFUtil::wrnMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:ac71522e8c55f84cfc6c13a0ddff18436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <a href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">More...</a><br /></td></tr>
<tr class="separator:ac71522e8c55f84cfc6c13a0ddff18436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">SVF::SVFUtil::writeWrnMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <a href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">More...</a><br /></td></tr>
<tr class="separator:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7655b13bbfe720ca2b8a25e0a72528e6">SVF::SVFUtil::errMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <a href="namespaceSVF_1_1SVFUtil.html#a7655b13bbfe720ca2b8a25e0a72528e6">More...</a><br /></td></tr>
<tr class="separator:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10504db25b86bc7f74aebb9c54f04cb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a10504db25b86bc7f74aebb9c54f04cb3">SVF::SVFUtil::bugMsg1</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:a10504db25b86bc7f74aebb9c54f04cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f6dfcc9118ffd80244a771bdee535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac25f6dfcc9118ffd80244a771bdee535">SVF::SVFUtil::bugMsg2</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:ac25f6dfcc9118ffd80244a771bdee535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76909ad87f59eb9a9cfd1913e13da264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a76909ad87f59eb9a9cfd1913e13da264">SVF::SVFUtil::bugMsg3</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:a76909ad87f59eb9a9cfd1913e13da264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550f2fb815882edfb666ac818792064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4550f2fb815882edfb666ac818792064">SVF::SVFUtil::pasMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a4550f2fb815882edfb666ac818792064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <a href="namespaceSVF_1_1SVFUtil.html#a4550f2fb815882edfb666ac818792064">More...</a><br /></td></tr>
<tr class="separator:a4550f2fb815882edfb666ac818792064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">SVF::SVFUtil::reportMemoryUsageKB</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;infor, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=SVFUtil::outs())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <a href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">More...</a><br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a> (<a class="el" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> *vmrss_kb, <a class="el" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> *vmsize_kb)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">More...</a><br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">SVF::SVFUtil::increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <a href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">More...</a><br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">SVF::SVFUtil::cmpPts</a> (const PointsTo &amp;lpts, const PointsTo &amp;rpts)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">SVF::SVFUtil::cmpNodeBS</a> (const NodeBS &amp;lpts, const NodeBS &amp;rpts)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top">NodeBS&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">SVF::SVFUtil::ptsToNodeBS</a> (const PointsTo &amp;pts)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">SVF::SVFUtil::dumpPointsToList</a> (const PointsToList &amp;ptl)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2bbf6e0dc5adae2140a519259e6f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abb2bbf6e0dc5adae2140a519259e6f17">SVF::SVFUtil::isIntrinsicInst</a> (const <a class="el" href="classSVF_1_1SVFInstruction.html">SVFInstruction</a> *inst)</td></tr>
<tr class="memdesc:abb2bbf6e0dc5adae2140a519259e6f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an llvm intrinsic instruction.  <a href="namespaceSVF_1_1SVFUtil.html#abb2bbf6e0dc5adae2140a519259e6f17">More...</a><br /></td></tr>
<tr class="separator:abb2bbf6e0dc5adae2140a519259e6f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">SVF::SVFUtil::isIntrinsicInst</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="separator:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb755f339ad1650f8ae2155451d9c0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8cb755f339ad1650f8ae2155451d9c0d">SVF::SVFUtil::isCallSite</a> (const SVFValue *val)</td></tr>
<tr class="memdesc:a8cb755f339ad1650f8ae2155451d9c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="namespaceSVF_1_1SVFUtil.html#a8cb755f339ad1650f8ae2155451d9c0d">More...</a><br /></td></tr>
<tr class="separator:a8cb755f339ad1650f8ae2155451d9c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f286ff865a778dc2af5410ed9b24e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">SVF::SVFUtil::isCallSite</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="separator:ac69f286ff865a778dc2af5410ed9b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd7753901074b660eda3166180a356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad4bd7753901074b660eda3166180a356">SVF::SVFUtil::isRetInstNode</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:ad4bd7753901074b660eda3166180a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4db2fe43846609d2ed1d7022b1be1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4af4db2fe43846609d2ed1d7022b1be1">SVF::SVFUtil::isNonInstricCallSite</a> (const SVFInstruction *inst)</td></tr>
<tr class="memdesc:a4af4db2fe43846609d2ed1d7022b1be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="namespaceSVF_1_1SVFUtil.html#a4af4db2fe43846609d2ed1d7022b1be1">More...</a><br /></td></tr>
<tr class="separator:a4af4db2fe43846609d2ed1d7022b1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b337f84cae7ae0ec4597b077aee08c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86b337f84cae7ae0ec4597b077aee08c">SVF::SVFUtil::isNonInstricCallSite</a> (const ICFGNode *inst)</td></tr>
<tr class="memdesc:a86b337f84cae7ae0ec4597b077aee08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="namespaceSVF_1_1SVFUtil.html#a86b337f84cae7ae0ec4597b077aee08c">More...</a><br /></td></tr>
<tr class="separator:a86b337f84cae7ae0ec4597b077aee08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f7c7f60a7ad6c053012a74f2dcc1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ada7f7c7f60a7ad6c053012a74f2dcc1c">SVF::SVFUtil::matchArgs</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs, const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *callee)</td></tr>
<tr class="separator:ada7f7c7f60a7ad6c053012a74f2dcc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18227f257c9881541b84ca186680dfd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae18227f257c9881541b84ca186680dfd">SVF::SVFUtil::split</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;s, char separator)</td></tr>
<tr class="memdesc:ae18227f257c9881541b84ca186680dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="namespaceSVF_1_1SVFUtil.html#ae18227f257c9881541b84ca186680dfd">More...</a><br /></td></tr>
<tr class="separator:ae18227f257c9881541b84ca186680dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;typename Data &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">SVF::SVFUtil::mergePtsOccMaps</a> (Map&lt; Data, unsigned &gt; &amp;to, const Map&lt; Data, unsigned &gt; from)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <a href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">More...</a><br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVF::SVFUtil::hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <a href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">More...</a><br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">SVF::SVFUtil::insertKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <a href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">More...</a><br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">SVF::SVFUtil::insertKey</a> (const NodeID &amp;key, NodeBS &amp;keySet)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">More...</a><br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">SVF::SVFUtil::removeKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing ::erase).  <a href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">More...</a><br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">SVF::SVFUtil::removeKey</a> (const NodeID &amp;key, NodeBS &amp;keySet)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">More...</a><br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">SVF::SVFUtil::timeLimitReached</a> (int signum)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">More...</a><br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">SVF::SVFUtil::startAnalysisLimitTimer</a> (unsigned timeLimit)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">SVF::SVFUtil::stopAnalysisLimitTimer</a> (bool limitTimerSet)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef185e767ff76c098e75126c885400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">SVF::SVFUtil::isExtCall</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:a22ef185e767ff76c098e75126c885400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bd5e1bf36b3e75bfcea9388871dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a688bd5e1bf36b3e75bfcea9388871dc4">SVF::SVFUtil::isMemcpyExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:a688bd5e1bf36b3e75bfcea9388871dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54098ea73555caa682287f8e3c9e8fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a54098ea73555caa682287f8e3c9e8fcb">SVF::SVFUtil::isMemsetExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:a54098ea73555caa682287f8e3c9e8fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96a872d9096037f20e25122e469ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a19b96a872d9096037f20e25122e469ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">More...</a><br /></td></tr>
<tr class="separator:a19b96a872d9096037f20e25122e469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a69173f50ebe48e69103befe516245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a> (const SVFFunction *fun)</td></tr>
<tr class="separator:ab4a69173f50ebe48e69103befe516245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86491999a479a611489469b3e69d7cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a86491999a479a611489469b3e69d7cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <a href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">More...</a><br /></td></tr>
<tr class="separator:a86491999a479a611489469b3e69d7cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">More...</a><br /></td></tr>
<tr class="separator:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97c2b79b795465490512e267a9309b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:a2c97c2b79b795465490512e267a9309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">More...</a><br /></td></tr>
<tr class="separator:a2c97c2b79b795465490512e267a9309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82e03d880257527bd9cb5978e05604"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">SVF::SVFUtil::getProgFunction</a> (SVFModule *svfModule, const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;funName)</td></tr>
<tr class="memdesc:a6f82e03d880257527bd9cb5978e05604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">More...</a><br /></td></tr>
<tr class="separator:a6f82e03d880257527bd9cb5978e05604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8017e3e5100b3f63ee338b66118d266"><td class="memItemLeft" align="right" valign="top">const SVFFunction *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">SVF::SVFUtil::getProgEntryFunction</a> (SVFModule *svfModule)</td></tr>
<tr class="memdesc:aa8017e3e5100b3f63ee338b66118d266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">More...</a><br /></td></tr>
<tr class="separator:aa8017e3e5100b3f63ee338b66118d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee60be22e8f9397db108131696d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a> (const SVFFunction *fun)</td></tr>
<tr class="memdesc:aec7ee60be22e8f9397db108131696d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">More...</a><br /></td></tr>
<tr class="separator:aec7ee60be22e8f9397db108131696d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1a34958ca60ed98ad228c1d46cf95aeb">SVF::SVFUtil::isArgOfUncalledFunction</a> (const SVFValue *svfval)</td></tr>
<tr class="memdesc:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this argument belongs to an uncalled function.  <a href="namespaceSVF_1_1SVFUtil.html#a1a34958ca60ed98ad228c1d46cf95aeb">More...</a><br /></td></tr>
<tr class="separator:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceaa01be78180abcef82edeff0027eb"><td class="memItemLeft" align="right" valign="top">const SVFValue *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acceaa01be78180abcef82edeff0027eb">SVF::SVFUtil::getForkedFun</a> (const CallICFGNode *inst)</td></tr>
<tr class="memdesc:acceaa01be78180abcef82edeff0027eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <a href="namespaceSVF_1_1SVFUtil.html#acceaa01be78180abcef82edeff0027eb">More...</a><br /></td></tr>
<tr class="separator:acceaa01be78180abcef82edeff0027eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d203b5b7749ce51583d39a503407db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa2d203b5b7749ce51583d39a503407db">SVF::SVFUtil::isExtCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:aa2d203b5b7749ce51583d39a503407db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f888dfee60a63eb0711fcdd63430e8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3f888dfee60a63eb0711fcdd63430e8f">SVF::SVFUtil::isExtCall</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:a3f888dfee60a63eb0711fcdd63430e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a75e8eda99da5d45ccf0188e2d876d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a83a75e8eda99da5d45ccf0188e2d876d">SVF::SVFUtil::isHeapAllocExtCallViaArg</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a83a75e8eda99da5d45ccf0188e2d876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3bde29364d65428ee2c4eb22063828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb3bde29364d65428ee2c4eb22063828">SVF::SVFUtil::isHeapAllocExtCallViaRet</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:aeb3bde29364d65428ee2c4eb22063828"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces to be used externally  <a href="namespaceSVF_1_1SVFUtil.html#aeb3bde29364d65428ee2c4eb22063828">More...</a><br /></td></tr>
<tr class="separator:aeb3bde29364d65428ee2c4eb22063828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b308e08dd0837b9401ada40349ac32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a85b308e08dd0837b9401ada40349ac32">SVF::SVFUtil::isHeapAllocExtCall</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *cs)</td></tr>
<tr class="separator:a85b308e08dd0837b9401ada40349ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd908aab5f4e0352c50a36381ae85f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5bd908aab5f4e0352c50a36381ae85f3">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a5bd908aab5f4e0352c50a36381ae85f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a01f4cd58f733d71c9bbd7dcc40194c0b">SVF::SVFUtil::isReallocExtCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a811faa9c2095f44e3e5b6e50aa6f6e06">SVF::SVFUtil::is_sequence_container_v</a> = is_sequence_container&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8c57ab480c497cbd21a49778d0e59bd5">SVF::SVFUtil::is_map_v</a> = is_map&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a08e67d68b1da116b2c51cb60bdb6dae2">SVF::SVFUtil::is_set_v</a> = is_set&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad37880353cffc950d5b9417bc41c0b06">SVF::SVFUtil::void_t</a> = typename make_void&lt; Ts... &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a></td></tr>
<tr class="separator:ad37880353cffc950d5b9417bc41c0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa32219da7a5c3d7517ec5026afdac588">SVF::SVFUtil::is_iterable_v</a> = is_iterable&lt;T&gt;::value</td></tr>
<tr class="separator:aa32219da7a5c3d7517ec5026afdac588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aac9a03aaeb26832c69f95a9a96a2d31a">SVF::SVFUtil::isThreadForkCall</a> (const CallICFGNode *inst)</td></tr>
<tr class="separator:aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c79a20405d3a31b309a14bd68f1166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c79a20405d3a31b309a14bd68f1166">SVF::SVFUtil::isThreadJoinCall</a> (const CallICFGNode *cs)</td></tr>
<tr class="separator:a86c79a20405d3a31b309a14bd68f1166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b7843d49df58cf1bf3725076702c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac1b7843d49df58cf1bf3725076702c07">SVF::SVFUtil::isThreadExitCall</a> (const CallICFGNode *cs)</td></tr>
<tr class="separator:ac1b7843d49df58cf1bf3725076702c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191cbe16e7e32dd136cff438752b3029"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a191cbe16e7e32dd136cff438752b3029">SVF::SVFUtil::isLockAquireCall</a> (const CallICFGNode *cs)</td></tr>
<tr class="separator:a191cbe16e7e32dd136cff438752b3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7be6fe5d9c277583eaeab46282b62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abaa7be6fe5d9c277583eaeab46282b62">SVF::SVFUtil::isLockReleaseCall</a> (const CallICFGNode *cs)</td></tr>
<tr class="separator:abaa7be6fe5d9c277583eaeab46282b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0066d96179c6d7e9a1e42608ecb73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a34f0066d96179c6d7e9a1e42608ecb73">SVF::SVFUtil::isBarrierWaitCall</a> (const CallICFGNode *cs)</td></tr>
<tr class="memdesc:a34f0066d96179c6d7e9a1e42608ecb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a barrier wait call.  <a href="namespaceSVF_1_1SVFUtil.html#a34f0066d96179c6d7e9a1e42608ecb73">More...</a><br /></td></tr>
<tr class="separator:a34f0066d96179c6d7e9a1e42608ecb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521102e94fcb6ca9d31e92d6b445b477"><td class="memItemLeft" align="right" valign="top">const SVFVar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a521102e94fcb6ca9d31e92d6b445b477">SVF::SVFUtil::getActualParmAtForkSite</a> (const CallICFGNode *cs)</td></tr>
<tr class="memdesc:a521102e94fcb6ca9d31e92d6b445b477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sole argument of the thread routine.  <a href="namespaceSVF_1_1SVFUtil.html#a521102e94fcb6ca9d31e92d6b445b477">More...</a><br /></td></tr>
<tr class="separator:a521102e94fcb6ca9d31e92d6b445b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6586774af88b61f367ba43d126f38ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac6586774af88b61f367ba43d126f38ac">SVF::SVFUtil::isProgExitCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:ac6586774af88b61f367ba43d126f38ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_reference&lt; T &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">SVF::SVFUtil::move</a> (T &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a72502f7f536418621485e90ab98c2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
