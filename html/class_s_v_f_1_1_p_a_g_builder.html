<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SVF: SVF::PAGBuilder Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SVF
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_s_v_f.html">SVF</a></li><li class="navelem"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html">PAGBuilder</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_s_v_f_1_1_p_a_g_builder-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SVF::PAGBuilder Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_p_a_g_builder_8h_source.html">PAGBuilder.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SVF::PAGBuilder:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_s_v_f_1_1_p_a_g_builder.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7c6b147496561a0efa5e4c27d5e1df8c"><td class="memItemLeft" align="right" valign="top"><a id="a7c6b147496561a0efa5e4c27d5e1df8c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a7c6b147496561a0efa5e4c27d5e1df8c">PAGBuilder</a> ()</td></tr>
<tr class="memdesc:a7c6b147496561a0efa5e4c27d5e1df8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a7c6b147496561a0efa5e4c27d5e1df8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dd6cbbbc3963771971ae89b291b699"><td class="memItemLeft" align="right" valign="top"><a id="ae6dd6cbbbc3963771971ae89b291b699"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ae6dd6cbbbc3963771971ae89b291b699">~PAGBuilder</a> ()</td></tr>
<tr class="memdesc:ae6dd6cbbbc3963771971ae89b291b699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:ae6dd6cbbbc3963771971ae89b291b699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ab2c9481467842e1ad4c46a1f6291"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a757ab2c9481467842e1ad4c46a1f6291">build</a> (<a class="el" href="class_s_v_f_1_1_s_v_f_module.html">SVFModule</a> *svfModule)</td></tr>
<tr class="memdesc:a757ab2c9481467842e1ad4c46a1f6291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start building <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> here.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a757ab2c9481467842e1ad4c46a1f6291">More...</a><br /></td></tr>
<tr class="separator:a757ab2c9481467842e1ad4c46a1f6291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac037265d15e76801cdf45ae5682ccef8"><td class="memItemLeft" align="right" valign="top"><a id="ac037265d15e76801cdf45ae5682ccef8"></a>
<a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ac037265d15e76801cdf45ae5682ccef8">getPAG</a> () const</td></tr>
<tr class="memdesc:ac037265d15e76801cdf45ae5682ccef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a>. <br /></td></tr>
<tr class="separator:ac037265d15e76801cdf45ae5682ccef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2baa9aa1c4b467001ceab3f179ae1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a2a2baa9aa1c4b467001ceab3f179ae1b">initialiseNodes</a> ()</td></tr>
<tr class="memdesc:a2a2baa9aa1c4b467001ceab3f179ae1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize nodes and edges.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a2a2baa9aa1c4b467001ceab3f179ae1b">More...</a><br /></td></tr>
<tr class="separator:a2a2baa9aa1c4b467001ceab3f179ae1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6893b4ac983a96827e4447b471e8a3"><td class="memItemLeft" align="right" valign="top"><a id="a4e6893b4ac983a96827e4447b471e8a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (NodeID src, NodeID dst, <a class="el" href="class_s_v_f_1_1_p_a_g_edge.html#a79080505b4744aa8806b55215ac2b0f6">PAGEdge::PEDGEK</a> kind, Size_t offset=0, Instruction *cs=NULL)</td></tr>
<tr class="separator:a4e6893b4ac983a96827e4447b471e8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378d2bc2d5526f0ab72c1488d3b58380"><td class="memItemLeft" align="right" valign="top"><a id="a378d2bc2d5526f0ab72c1488d3b58380"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a378d2bc2d5526f0ab72c1488d3b58380">sanityCheck</a> ()</td></tr>
<tr class="memdesc:a378d2bc2d5526f0ab72c1488d3b58380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sanity check for <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a>. <br /></td></tr>
<tr class="separator:a378d2bc2d5526f0ab72c1488d3b58380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb6701d6460f26cd31526754419847b"><td class="memItemLeft" align="right" valign="top"><a id="acfb6701d6460f26cd31526754419847b"></a>
NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#acfb6701d6460f26cd31526754419847b">getValueNode</a> (const Value *V)</td></tr>
<tr class="memdesc:acfb6701d6460f26cd31526754419847b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get different kinds of node. <br /></td></tr>
<tr class="separator:acfb6701d6460f26cd31526754419847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442ca853e750396d088aa736cc39356f"><td class="memItemLeft" align="right" valign="top"><a id="a442ca853e750396d088aa736cc39356f"></a>
NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a442ca853e750396d088aa736cc39356f">getObjectNode</a> (const Value *V)</td></tr>
<tr class="memdesc:a442ca853e750396d088aa736cc39356f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetObject - Return the object node (stack/global/heap/function) according to a LLVM Value. <br /></td></tr>
<tr class="separator:a442ca853e750396d088aa736cc39356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56174b3a60464bfb64f78b26d2408286"><td class="memItemLeft" align="right" valign="top"><a id="a56174b3a60464bfb64f78b26d2408286"></a>
NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a56174b3a60464bfb64f78b26d2408286">getReturnNode</a> (const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *func)</td></tr>
<tr class="memdesc:a56174b3a60464bfb64f78b26d2408286"><td class="mdescLeft">&#160;</td><td class="mdescRight">getReturnNode - Return the node representing the unique return value of a function. <br /></td></tr>
<tr class="separator:a56174b3a60464bfb64f78b26d2408286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab871886803e0dbe65b8c57bb15c309"><td class="memItemLeft" align="right" valign="top"><a id="adab871886803e0dbe65b8c57bb15c309"></a>
NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#adab871886803e0dbe65b8c57bb15c309">getVarargNode</a> (const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *func)</td></tr>
<tr class="memdesc:adab871886803e0dbe65b8c57bb15c309"><td class="mdescLeft">&#160;</td><td class="mdescRight">getVarargNode - Return the node representing the unique variadic argument of a function. <br /></td></tr>
<tr class="separator:adab871886803e0dbe65b8c57bb15c309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7247d100cc4f652d7dc4ca356b0f2538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a7247d100cc4f652d7dc4ca356b0f2538">visitGlobal</a> (<a class="el" href="class_s_v_f_1_1_s_v_f_module.html">SVFModule</a> *svfModule)</td></tr>
<tr class="memdesc:a7247d100cc4f652d7dc4ca356b0f2538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle globals including (global variable and functions)  <a href="class_s_v_f_1_1_p_a_g_builder.html#a7247d100cc4f652d7dc4ca356b0f2538">More...</a><br /></td></tr>
<tr class="separator:a7247d100cc4f652d7dc4ca356b0f2538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280244168f951cb2d6a061583c20c432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a280244168f951cb2d6a061583c20c432">InitialGlobal</a> (const GlobalVariable *gvar, Constant *C, u32_t offset)</td></tr>
<tr class="separator:a280244168f951cb2d6a061583c20c432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bd1644b78b1123622a34e6dee40829"><td class="memItemLeft" align="right" valign="top">NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a51bd1644b78b1123622a34e6dee40829">getGlobalVarField</a> (const GlobalVariable *gvar, u32_t offset)</td></tr>
<tr class="separator:a51bd1644b78b1123622a34e6dee40829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cee5531a01ce845dcd217302759326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a97cee5531a01ce845dcd217302759326">processCE</a> (const Value *val)</td></tr>
<tr class="memdesc:a97cee5531a01ce845dcd217302759326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process constant expression.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a97cee5531a01ce845dcd217302759326">More...</a><br /></td></tr>
<tr class="separator:a97cee5531a01ce845dcd217302759326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cedcedab00c875ba392da281de7f5f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a5cedcedab00c875ba392da281de7f5f2">computeGepOffset</a> (const User *V, <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;ls)</td></tr>
<tr class="memdesc:a5cedcedab00c875ba392da281de7f5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute offset of a gep instruction or gep constant expression.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a5cedcedab00c875ba392da281de7f5f2">More...</a><br /></td></tr>
<tr class="separator:a5cedcedab00c875ba392da281de7f5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bcfa8c506dec6c8adb85852b39a8ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#af0bcfa8c506dec6c8adb85852b39a8ab">handleDirectCall</a> (CallSite cs, const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *F)</td></tr>
<tr class="memdesc:af0bcfa8c506dec6c8adb85852b39a8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle direct call.  <a href="class_s_v_f_1_1_p_a_g_builder.html#af0bcfa8c506dec6c8adb85852b39a8ab">More...</a><br /></td></tr>
<tr class="separator:af0bcfa8c506dec6c8adb85852b39a8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab222f5d9ad6c59e1c3a738153cf650d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ab222f5d9ad6c59e1c3a738153cf650d0">handleIndCall</a> (CallSite cs)</td></tr>
<tr class="memdesc:ab222f5d9ad6c59e1c3a738153cf650d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle indirect call.  <a href="class_s_v_f_1_1_p_a_g_builder.html#ab222f5d9ad6c59e1c3a738153cf650d0">More...</a><br /></td></tr>
<tr class="separator:ab222f5d9ad6c59e1c3a738153cf650d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5344e675f4207a1e9a2de54d0e5f6e9d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a5344e675f4207a1e9a2de54d0e5f6e9d">handleExtCall</a> (CallSite cs, const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *F)</td></tr>
<tr class="memdesc:a5344e675f4207a1e9a2de54d0e5f6e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle external call.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a5344e675f4207a1e9a2de54d0e5f6e9d">More...</a><br /></td></tr>
<tr class="separator:a5344e675f4207a1e9a2de54d0e5f6e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6862687d02f922f4a2561898778c4b6"><td class="memItemLeft" align="right" valign="top">const Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#af6862687d02f922f4a2561898778c4b6">getBaseTypeAndFlattenedFields</a> (Value *v, std::vector&lt; <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &gt; &amp;fields)</td></tr>
<tr class="separator:af6862687d02f922f4a2561898778c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0298648bd13700f9c4649c9ed39664a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a0298648bd13700f9c4649c9ed39664a2">addComplexConsForExt</a> (Value *D, Value *S, u32_t sz=0)</td></tr>
<tr class="separator:a0298648bd13700f9c4649c9ed39664a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac119eecbd406c08b473b39c7fa3e475b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ac119eecbd406c08b473b39c7fa3e475b">visitAllocaInst</a> (<a class="el" href="namespace_s_v_f.html#a3bacb4f95c73e6d794901d01c6b65a83">AllocaInst</a> &amp;AI)</td></tr>
<tr class="memdesc:ac119eecbd406c08b473b39c7fa3e475b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Our visit overrides.  <a href="class_s_v_f_1_1_p_a_g_builder.html#ac119eecbd406c08b473b39c7fa3e475b">More...</a><br /></td></tr>
<tr class="separator:ac119eecbd406c08b473b39c7fa3e475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a96e3bad770eab314403b9d02b263f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a77a96e3bad770eab314403b9d02b263f">visitPHINode</a> (PHINode &amp;I)</td></tr>
<tr class="separator:a77a96e3bad770eab314403b9d02b263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767d67bbcf32288c3a255b20f3d236bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a767d67bbcf32288c3a255b20f3d236bc">visitStoreInst</a> (StoreInst &amp;I)</td></tr>
<tr class="separator:a767d67bbcf32288c3a255b20f3d236bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad333677366e6e2eba1aa7f60f6e02814"><td class="memItemLeft" align="right" valign="top"><a id="ad333677366e6e2eba1aa7f60f6e02814"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitLoadInst</b> (LoadInst &amp;I)</td></tr>
<tr class="separator:ad333677366e6e2eba1aa7f60f6e02814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0385ab439c9f8788678f0490565f6396"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a0385ab439c9f8788678f0490565f6396">visitGetElementPtrInst</a> (GetElementPtrInst &amp;I)</td></tr>
<tr class="separator:a0385ab439c9f8788678f0490565f6396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279ed7ff3400183d81b4a4fbebe502f1"><td class="memItemLeft" align="right" valign="top"><a id="a279ed7ff3400183d81b4a4fbebe502f1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitCallInst</b> (CallInst &amp;I)</td></tr>
<tr class="separator:a279ed7ff3400183d81b4a4fbebe502f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0008830aa2aebe1d0f31ed10a0b5533"><td class="memItemLeft" align="right" valign="top"><a id="ae0008830aa2aebe1d0f31ed10a0b5533"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitInvokeInst</b> (InvokeInst &amp;II)</td></tr>
<tr class="separator:ae0008830aa2aebe1d0f31ed10a0b5533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d34776d2f3744adb90374aa84d12d"><td class="memItemLeft" align="right" valign="top"><a id="ae38d34776d2f3744adb90374aa84d12d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitCallBrInst</b> (CallBrInst &amp;I)</td></tr>
<tr class="separator:ae38d34776d2f3744adb90374aa84d12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe51d51b7bd29f223552643010df586b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#abe51d51b7bd29f223552643010df586b">visitCallSite</a> (CallSite cs)</td></tr>
<tr class="separator:abe51d51b7bd29f223552643010df586b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d19f29650c772bddeaee3d700b0a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#af56d19f29650c772bddeaee3d700b0a7">visitReturnInst</a> (ReturnInst &amp;I)</td></tr>
<tr class="separator:af56d19f29650c772bddeaee3d700b0a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa76038afad572861c72fde345f9ad4"><td class="memItemLeft" align="right" valign="top"><a id="a1aa76038afad572861c72fde345f9ad4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitCastInst</b> (CastInst &amp;I)</td></tr>
<tr class="separator:a1aa76038afad572861c72fde345f9ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614aeca6530b697c0d67eb2b3173059c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a614aeca6530b697c0d67eb2b3173059c">visitSelectInst</a> (SelectInst &amp;I)</td></tr>
<tr class="separator:a614aeca6530b697c0d67eb2b3173059c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bab83475c617d969b6525f08d68e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a54bab83475c617d969b6525f08d68e0c">visitExtractValueInst</a> (ExtractValueInst &amp;EVI)</td></tr>
<tr class="separator:a54bab83475c617d969b6525f08d68e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afe9cfdcad2b2a961660fb1f8acd0d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a8afe9cfdcad2b2a961660fb1f8acd0d7">visitBranchInst</a> (BranchInst &amp;I)</td></tr>
<tr class="separator:a8afe9cfdcad2b2a961660fb1f8acd0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a54a195cf948c400d1fbaf705a4b423"><td class="memItemLeft" align="right" valign="top"><a id="a0a54a195cf948c400d1fbaf705a4b423"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitSwitchInst</b> (SwitchInst &amp;I)</td></tr>
<tr class="separator:a0a54a195cf948c400d1fbaf705a4b423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d125ab3215cb00171b3d8f2e7048ed"><td class="memItemLeft" align="right" valign="top"><a id="a45d125ab3215cb00171b3d8f2e7048ed"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitInsertValueInst</b> (InsertValueInst &amp;I)</td></tr>
<tr class="separator:a45d125ab3215cb00171b3d8f2e7048ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98abdcc0bb0aa457a3a77c03af2a6354"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a98abdcc0bb0aa457a3a77c03af2a6354">visitBinaryOperator</a> (BinaryOperator &amp;I)</td></tr>
<tr class="separator:a98abdcc0bb0aa457a3a77c03af2a6354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfed8e95ae4bccdeac53e9c2d3b3cca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a7dfed8e95ae4bccdeac53e9c2d3b3cca">visitUnaryOperator</a> (UnaryOperator &amp;I)</td></tr>
<tr class="separator:a7dfed8e95ae4bccdeac53e9c2d3b3cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f28734ad5b933d347f6ebc95dcd2f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ae6f28734ad5b933d347f6ebc95dcd2f2">visitCmpInst</a> (CmpInst &amp;I)</td></tr>
<tr class="separator:ae6f28734ad5b933d347f6ebc95dcd2f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e81ef5eff62ec9d040f4fe256ce4cc7"><td class="memItemLeft" align="right" valign="top"><a id="a4e81ef5eff62ec9d040f4fe256ce4cc7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a4e81ef5eff62ec9d040f4fe256ce4cc7">visitVAArgInst</a> (VAArgInst &amp;)</td></tr>
<tr class="memdesc:a4e81ef5eff62ec9d040f4fe256ce4cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO: do we need to care about these corner cases? <br /></td></tr>
<tr class="separator:a4e81ef5eff62ec9d040f4fe256ce4cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b565582e046a3acb279e315dd5318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a5b7b565582e046a3acb279e315dd5318">visitExtractElementInst</a> (ExtractElementInst &amp;I)</td></tr>
<tr class="separator:a5b7b565582e046a3acb279e315dd5318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009b45ee9315080dbc80e25db7af3777"><td class="memItemLeft" align="right" valign="top"><a id="a009b45ee9315080dbc80e25db7af3777"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitInsertElementInst</b> (InsertElementInst &amp;I)</td></tr>
<tr class="separator:a009b45ee9315080dbc80e25db7af3777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e3c052a31028b3d676e09c7e895b8"><td class="memItemLeft" align="right" valign="top"><a id="abc5e3c052a31028b3d676e09c7e895b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitShuffleVectorInst</b> (ShuffleVectorInst &amp;I)</td></tr>
<tr class="separator:abc5e3c052a31028b3d676e09c7e895b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e8185163f90a02dac7cb18a6e4eda5"><td class="memItemLeft" align="right" valign="top"><a id="a67e8185163f90a02dac7cb18a6e4eda5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitLandingPadInst</b> (LandingPadInst &amp;I)</td></tr>
<tr class="separator:a67e8185163f90a02dac7cb18a6e4eda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde7a8663cf936a2f5ce473673a09dc4"><td class="memItemLeft" align="right" valign="top"><a id="acde7a8663cf936a2f5ce473673a09dc4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#acde7a8663cf936a2f5ce473673a09dc4">visitResumeInst</a> (ResumeInst &amp;)</td></tr>
<tr class="memdesc:acde7a8663cf936a2f5ce473673a09dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instruction not that often. <br /></td></tr>
<tr class="separator:acde7a8663cf936a2f5ce473673a09dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b2faad712a499759550b4958cef044"><td class="memItemLeft" align="right" valign="top"><a id="ae9b2faad712a499759550b4958cef044"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitUnreachableInst</b> (UnreachableInst &amp;)</td></tr>
<tr class="separator:ae9b2faad712a499759550b4958cef044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0cc10b66f6fc0f3e909861ac8cd244"><td class="memItemLeft" align="right" valign="top"><a id="a3d0cc10b66f6fc0f3e909861ac8cd244"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitFenceInst</b> (FenceInst &amp;I)</td></tr>
<tr class="separator:a3d0cc10b66f6fc0f3e909861ac8cd244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e25ea8fee0e6d58c70ed7f1444ccaa"><td class="memItemLeft" align="right" valign="top"><a id="af9e25ea8fee0e6d58c70ed7f1444ccaa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitAtomicCmpXchgInst</b> (AtomicCmpXchgInst &amp;I)</td></tr>
<tr class="separator:af9e25ea8fee0e6d58c70ed7f1444ccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86667fc83e3afd45da76b8a0bf73ea83"><td class="memItemLeft" align="right" valign="top"><a id="a86667fc83e3afd45da76b8a0bf73ea83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>visitAtomicRMWInst</b> (AtomicRMWInst &amp;I)</td></tr>
<tr class="separator:a86667fc83e3afd45da76b8a0bf73ea83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141d835fbf86c6b1963f23b9198f4edb"><td class="memItemLeft" align="right" valign="top"><a id="a141d835fbf86c6b1963f23b9198f4edb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a141d835fbf86c6b1963f23b9198f4edb">visitInstruction</a> (Instruction &amp;)</td></tr>
<tr class="memdesc:a141d835fbf86c6b1963f23b9198f4edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide base case for our instruction visit. <br /></td></tr>
<tr class="separator:a141d835fbf86c6b1963f23b9198f4edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac982536389623922a8db341784f599e5"><td class="memItemLeft" align="right" valign="top"><a id="ac982536389623922a8db341784f599e5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ac982536389623922a8db341784f599e5">setCurrentLocation</a> (const Value *val, const BasicBlock *bb)</td></tr>
<tr class="memdesc:ac982536389623922a8db341784f599e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current basic block in order to keep track of control flow information. <br /></td></tr>
<tr class="separator:ac982536389623922a8db341784f599e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5147c8d5e072bf2e30b943e56a537925"><td class="memItemLeft" align="right" valign="top"><a id="a5147c8d5e072bf2e30b943e56a537925"></a>
const Value *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentValue</b> () const</td></tr>
<tr class="separator:a5147c8d5e072bf2e30b943e56a537925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc50396b684b2c5d066974916b07424b"><td class="memItemLeft" align="right" valign="top"><a id="abc50396b684b2c5d066974916b07424b"></a>
const BasicBlock *&#160;</td><td class="memItemRight" valign="bottom"><b>getCurrentBB</b> () const</td></tr>
<tr class="separator:abc50396b684b2c5d066974916b07424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723c751c4575c5f73e2391c2ac1037c7"><td class="memItemLeft" align="right" valign="top"><a id="a723c751c4575c5f73e2391c2ac1037c7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a723c751c4575c5f73e2391c2ac1037c7">addGlobalBlackHoleAddrEdge</a> (NodeID node, const ConstantExpr *int2Ptrce)</td></tr>
<tr class="memdesc:a723c751c4575c5f73e2391c2ac1037c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add global black hole Address edge. <br /></td></tr>
<tr class="separator:a723c751c4575c5f73e2391c2ac1037c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612e0c0ebc12361d2fa56fb5fd85a671"><td class="memItemLeft" align="right" valign="top">NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a612e0c0ebc12361d2fa56fb5fd85a671">addNullPtrNode</a> ()</td></tr>
<tr class="memdesc:a612e0c0ebc12361d2fa56fb5fd85a671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add NullPtr <a class="el" href="class_s_v_f_1_1_p_a_g_node.html">PAGNode</a>.  <a href="class_s_v_f_1_1_p_a_g_builder.html#a612e0c0ebc12361d2fa56fb5fd85a671">More...</a><br /></td></tr>
<tr class="separator:a612e0c0ebc12361d2fa56fb5fd85a671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8960f5bcb7484b548c27948686317783"><td class="memItemLeft" align="right" valign="top">NodeID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a8960f5bcb7484b548c27948686317783">getGepValNode</a> (const Value *val, const <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;ls, const Type *baseType, u32_t fieldidx)</td></tr>
<tr class="separator:a8960f5bcb7484b548c27948686317783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad522a6e5d90b6d59baf667a6ec8f32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#abad522a6e5d90b6d59baf667a6ec8f32">setCurrentBBAndValueForPAGEdge</a> (<a class="el" href="class_s_v_f_1_1_p_a_g_edge.html">PAGEdge</a> *edge)</td></tr>
<tr class="separator:abad522a6e5d90b6d59baf667a6ec8f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27d71a747b7536cf7e8b375a70265be"><td class="memItemLeft" align="right" valign="top"><a id="ae27d71a747b7536cf7e8b375a70265be"></a>
<a class="el" href="class_s_v_f_1_1_p_a_g_edge.html">PAGEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>addBlackHoleAddrEdge</b> (NodeID node)</td></tr>
<tr class="separator:ae27d71a747b7536cf7e8b375a70265be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc73e4204e3150b4f8cf654752d0bd7"><td class="memItemLeft" align="right" valign="top"><a id="affc73e4204e3150b4f8cf654752d0bd7"></a>
<a class="el" href="class_s_v_f_1_1_addr_p_e.html">AddrPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#affc73e4204e3150b4f8cf654752d0bd7">addAddrEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:affc73e4204e3150b4f8cf654752d0bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Address edge. <br /></td></tr>
<tr class="separator:affc73e4204e3150b4f8cf654752d0bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d68206d9d900adc56474a97d84f5aa"><td class="memItemLeft" align="right" valign="top"><a id="ad9d68206d9d900adc56474a97d84f5aa"></a>
<a class="el" href="class_s_v_f_1_1_copy_p_e.html">CopyPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ad9d68206d9d900adc56474a97d84f5aa">addCopyEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:ad9d68206d9d900adc56474a97d84f5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Copy edge. <br /></td></tr>
<tr class="separator:ad9d68206d9d900adc56474a97d84f5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883daf0dd77cffc7525522138a72f5f5"><td class="memItemLeft" align="right" valign="top"><a id="a883daf0dd77cffc7525522138a72f5f5"></a>
<a class="el" href="class_s_v_f_1_1_cmp_p_e.html">CmpPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a883daf0dd77cffc7525522138a72f5f5">addCmpEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:a883daf0dd77cffc7525522138a72f5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Copy edge. <br /></td></tr>
<tr class="separator:a883daf0dd77cffc7525522138a72f5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1a7ac8b5c26cc4a571a602eace6b87"><td class="memItemLeft" align="right" valign="top"><a id="a1e1a7ac8b5c26cc4a571a602eace6b87"></a>
<a class="el" href="class_s_v_f_1_1_binary_o_p_p_e.html">BinaryOPPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a1e1a7ac8b5c26cc4a571a602eace6b87">addBinaryOPEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:a1e1a7ac8b5c26cc4a571a602eace6b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Copy edge. <br /></td></tr>
<tr class="separator:a1e1a7ac8b5c26cc4a571a602eace6b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8aa05cf63cec65b603b497ef35101f"><td class="memItemLeft" align="right" valign="top"><a id="aba8aa05cf63cec65b603b497ef35101f"></a>
<a class="el" href="class_s_v_f_1_1_unary_o_p_p_e.html">UnaryOPPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#aba8aa05cf63cec65b603b497ef35101f">addUnaryOPEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:aba8aa05cf63cec65b603b497ef35101f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Unary edge. <br /></td></tr>
<tr class="separator:aba8aa05cf63cec65b603b497ef35101f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a607f25cf79a39de233c3c3226a5c3a84"><td class="memItemLeft" align="right" valign="top"><a id="a607f25cf79a39de233c3c3226a5c3a84"></a>
<a class="el" href="class_s_v_f_1_1_load_p_e.html">LoadPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a607f25cf79a39de233c3c3226a5c3a84">addLoadEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:a607f25cf79a39de233c3c3226a5c3a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Load edge. <br /></td></tr>
<tr class="separator:a607f25cf79a39de233c3c3226a5c3a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5343c240c160f0ab1c97f3546e82bc9"><td class="memItemLeft" align="right" valign="top"><a id="ab5343c240c160f0ab1c97f3546e82bc9"></a>
<a class="el" href="class_s_v_f_1_1_store_p_e.html">StorePE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ab5343c240c160f0ab1c97f3546e82bc9">addStoreEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:ab5343c240c160f0ab1c97f3546e82bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Store edge. <br /></td></tr>
<tr class="separator:ab5343c240c160f0ab1c97f3546e82bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0bd7bb5f476a59490e09c599a7018d"><td class="memItemLeft" align="right" valign="top"><a id="a7f0bd7bb5f476a59490e09c599a7018d"></a>
<a class="el" href="class_s_v_f_1_1_call_p_e.html">CallPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a7f0bd7bb5f476a59490e09c599a7018d">addCallEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_call_block_node.html">CallBlockNode</a> *cs)</td></tr>
<tr class="memdesc:a7f0bd7bb5f476a59490e09c599a7018d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Call edge. <br /></td></tr>
<tr class="separator:a7f0bd7bb5f476a59490e09c599a7018d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102a8cfcbcb1d3b86cf4eb4aceb45ce"><td class="memItemLeft" align="right" valign="top"><a id="a0102a8cfcbcb1d3b86cf4eb4aceb45ce"></a>
<a class="el" href="class_s_v_f_1_1_ret_p_e.html">RetPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a0102a8cfcbcb1d3b86cf4eb4aceb45ce">addRetEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_call_block_node.html">CallBlockNode</a> *cs)</td></tr>
<tr class="memdesc:a0102a8cfcbcb1d3b86cf4eb4aceb45ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Return edge. <br /></td></tr>
<tr class="separator:a0102a8cfcbcb1d3b86cf4eb4aceb45ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb20aef23c737da1f4253e0131a20918"><td class="memItemLeft" align="right" valign="top"><a id="afb20aef23c737da1f4253e0131a20918"></a>
<a class="el" href="class_s_v_f_1_1_gep_p_e.html">GepPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#afb20aef23c737da1f4253e0131a20918">addGepEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;ls, bool constGep)</td></tr>
<tr class="memdesc:afb20aef23c737da1f4253e0131a20918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Gep edge. <br /></td></tr>
<tr class="separator:afb20aef23c737da1f4253e0131a20918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ae4030eb2aa3e91cbe3347ebbebe4d"><td class="memItemLeft" align="right" valign="top"><a id="ae8ae4030eb2aa3e91cbe3347ebbebe4d"></a>
<a class="el" href="class_s_v_f_1_1_normal_gep_p_e.html">NormalGepPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#ae8ae4030eb2aa3e91cbe3347ebbebe4d">addNormalGepEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;ls)</td></tr>
<tr class="memdesc:ae8ae4030eb2aa3e91cbe3347ebbebe4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Offset(Gep) edge. <br /></td></tr>
<tr class="separator:ae8ae4030eb2aa3e91cbe3347ebbebe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca96a7d6ea2b029a094301744a803038"><td class="memItemLeft" align="right" valign="top"><a id="aca96a7d6ea2b029a094301744a803038"></a>
<a class="el" href="class_s_v_f_1_1_variant_gep_p_e.html">VariantGepPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#aca96a7d6ea2b029a094301744a803038">addVariantGepEdge</a> (NodeID src, NodeID dst)</td></tr>
<tr class="memdesc:aca96a7d6ea2b029a094301744a803038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Variant(Gep) edge. <br /></td></tr>
<tr class="separator:aca96a7d6ea2b029a094301744a803038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1145de8b8cc483196ed48df4ddeb5518"><td class="memItemLeft" align="right" valign="top"><a id="a1145de8b8cc483196ed48df4ddeb5518"></a>
<a class="el" href="class_s_v_f_1_1_t_d_fork_p_e.html">TDForkPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a1145de8b8cc483196ed48df4ddeb5518">addThreadForkEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_call_block_node.html">CallBlockNode</a> *cs)</td></tr>
<tr class="memdesc:a1145de8b8cc483196ed48df4ddeb5518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Thread fork edge for parameter passing. <br /></td></tr>
<tr class="separator:a1145de8b8cc483196ed48df4ddeb5518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3dc63ec3c4a55168160eb413ee0133"><td class="memItemLeft" align="right" valign="top"><a id="a9d3dc63ec3c4a55168160eb413ee0133"></a>
<a class="el" href="class_s_v_f_1_1_t_d_join_p_e.html">TDJoinPE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_s_v_f_1_1_p_a_g_builder.html#a9d3dc63ec3c4a55168160eb413ee0133">addThreadJoinEdge</a> (NodeID src, NodeID dst, const <a class="el" href="class_s_v_f_1_1_call_block_node.html">CallBlockNode</a> *cs)</td></tr>
<tr class="memdesc:a9d3dc63ec3c4a55168160eb413ee0133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add Thread join edge for parameter passing. <br /></td></tr>
<tr class="separator:a9d3dc63ec3c4a55168160eb413ee0133"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> Builder </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0298648bd13700f9c4649c9ed39664a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0298648bd13700f9c4649c9ed39664a2">&#9670;&nbsp;</a></span>addComplexConsForExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::addComplexConsForExt </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>sz</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the load/store constraints and temp. nodes for the complex constraint *D = *S (where D/S may point to structs). </p>
<p>If sz is 0, we will add edges for all fields.</p>

</div>
</div>
<a id="a612e0c0ebc12361d2fa56fb5fd85a671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612e0c0ebc12361d2fa56fb5fd85a671">&#9670;&nbsp;</a></span>addNullPtrNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeID SVF::PAGBuilder::addNullPtrNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add NullPtr <a class="el" href="class_s_v_f_1_1_p_a_g_node.html">PAGNode</a>. </p>
<p>let all undef value or non-determined pointers points-to black hole</p>

</div>
</div>
<a id="a757ab2c9481467842e1ad4c46a1f6291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757ab2c9481467842e1ad4c46a1f6291">&#9670;&nbsp;</a></span>build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> * PAGBuilder::build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_v_f_1_1_s_v_f_module.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start building <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> here. </p>
<p>Start building <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> here </p>
<p>initial external library information initial <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> nodes</p>
<p>initial <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> edges: // handle globals</p>
<p>handle functions</p>
<p>collect return node of function fun</p>
<p>Return <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> node will not be created for function which can not reach the return instruction due to call to abort(), exit(), etc. In 176.gcc of SPEC 2000, function build_objc_string() from c-lang.c shows an example when fun.doesNotReturn() evaluates to TRUE because of abort().</p>
<p>To be noted, we do not record arguments which are in declared function without body TODO: what about external functions with <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> imported by commandline?</p>

</div>
</div>
<a id="a5cedcedab00c875ba392da281de7f5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cedcedab00c875ba392da281de7f5f2">&#9670;&nbsp;</a></span>computeGepOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PAGBuilder::computeGepOffset </td>
          <td>(</td>
          <td class="paramtype">const User *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute offset of a gep instruction or gep constant expression. </p>
<p>Return the object node offset according to GEP insn (V). Given a gep edge p = q + i, if "i" is a constant then we return its offset size otherwise if "i" is a variable determined by runtime, then it is a variant offset Return TRUE if the offset of this GEP insn is a constant. </p>

</div>
</div>
<a id="af6862687d02f922f4a2561898778c4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6862687d02f922f4a2561898778c4b6">&#9670;&nbsp;</a></span>getBaseTypeAndFlattenedFields()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Type * PAGBuilder::getBaseTypeAndFlattenedFields </td>
          <td>(</td>
          <td class="paramtype">Value *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>fields</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the base type and the max possible offset of an object pointed to by (V). </p>

</div>
</div>
<a id="a8960f5bcb7484b548c27948686317783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8960f5bcb7484b548c27948686317783">&#9670;&nbsp;</a></span>getGepValNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeID PAGBuilder::getGepValNode </td>
          <td>(</td>
          <td class="paramtype">const Value *&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_v_f_1_1_location_set.html">LocationSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Type *&#160;</td>
          <td class="paramname"><em>baseType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>fieldidx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a temp field value node according to base value and offset this node is after the initial node method, it is out of scope of symInfo table </p>

</div>
</div>
<a id="a51bd1644b78b1123622a34e6dee40829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51bd1644b78b1123622a34e6dee40829">&#9670;&nbsp;</a></span>getGlobalVarField()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeID PAGBuilder::getGlobalVarField </td>
          <td>(</td>
          <td class="paramtype">const GlobalVariable *&#160;</td>
          <td class="paramname"><em>gvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the field of the global variable node FIXME:Here we only get the field that actually used in the program We ignore the initialization of global variable field that not used in the program </p>
<p>if we did not find the constant expression in the program, then we need to create a gep node for this field</p>

</div>
</div>
<a id="af0bcfa8c506dec6c8adb85852b39a8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bcfa8c506dec6c8adb85852b39a8ab">&#9670;&nbsp;</a></span>handleDirectCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::handleDirectCall </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle direct call. </p>
<p>Add the constraints for a direct, non-external call. </p>
<p>FIXME: this assertion should be placed for correct checking except bug program like 188.ammp, 300.twolf</p>

</div>
</div>
<a id="a5344e675f4207a1e9a2de54d0e5f6e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5344e675f4207a1e9a2de54d0e5f6e9d">&#9670;&nbsp;</a></span>handleExtCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::handleExtCall </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_s_v_f_1_1_s_v_f_function.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle external call. </p>
<p>Handle external calls </p>
<p>this case is for strcpy(dst,src); to maintain its semantics we will store src to the base of dst instead of dst. dst = load base store src base</p>
<p>create inter-procedural <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> edges for thread forks</p>
<p>pthread_create has 1 arg. apr_thread_create has 2 arg.</p>
<p>Connect actual parameter to formal parameter of the start routine</p>
<p>handle indirect calls at pthread create APIs e.g., pthread_create(&amp;t1, NULL, fp, ...); const Value* fun = <a class="el" href="class_s_v_f_1_1_thread_a_p_i.html#a6852ff1eedc1117e95e45e4a90c80d53" title="Return a static reference.">ThreadAPI::getThreadAPI()</a>-&gt;getForkedFun(inst); if(!SVFUtil::isa&lt;Function&gt;(fun)) pag-&gt;addIndirectCallsites(cs,pag-&gt;getValueNode(fun));</p>
<p>If forkedFun does not pass to spawnee as function type but as void pointer remember to update inter-procedural callgraph/PAG/SVFG etc. when indirect call targets are resolved We don't connect the callgraph here, further investigation is need to hanle mod-ref during <a class="el" href="class_s_v_f_1_1_s_v_f_g.html">SVFG</a> construction.</p>
<p>create inter-procedural <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> edges for hare_parallel_for calls</p>
<p>The task function of hare_parallel_for has 3 args.</p>
<p>Connect actual parameter to formal parameter of the start routine</p>
<p>handle indirect calls at hare_parallel_for (e.g., hare_parallel_for(..., fp, ...); const Value* fun = <a class="el" href="class_s_v_f_1_1_thread_a_p_i.html#a6852ff1eedc1117e95e45e4a90c80d53" title="Return a static reference.">ThreadAPI::getThreadAPI()</a>-&gt;getForkedFun(inst); if(!SVFUtil::isa&lt;Function&gt;(fun)) pag-&gt;addIndirectCallsites(cs,pag-&gt;getValueNode(fun));</p>
<p>TODO: inter-procedural <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> edges for thread joins</p>

</div>
</div>
<a id="ab222f5d9ad6c59e1c3a738153cf650d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab222f5d9ad6c59e1c3a738153cf650d0">&#9670;&nbsp;</a></span>handleIndCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::handleIndCall </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle indirect call. </p>
<p>Indirect call is resolved on-the-fly during pointer analysis </p>

</div>
</div>
<a id="a280244168f951cb2d6a061583c20c432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280244168f951cb2d6a061583c20c432">&#9670;&nbsp;</a></span>InitialGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::InitialGlobal </td>
          <td>(</td>
          <td class="paramtype">const GlobalVariable *&#160;</td>
          <td class="paramname"><em>gvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Constant *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>src should not point to anything yet</p>

</div>
</div>
<a id="a2a2baa9aa1c4b467001ceab3f179ae1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2baa9aa1c4b467001ceab3f179ae1b">&#9670;&nbsp;</a></span>initialiseNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::initialiseNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize nodes and edges. </p>
<p>add address edges for constant nodes.</p>

</div>
</div>
<a id="a97cee5531a01ce845dcd217302759326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cee5531a01ce845dcd217302759326">&#9670;&nbsp;</a></span>processCE()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::processCE </td>
          <td>(</td>
          <td class="paramtype">const Value *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process constant expression. </p>
<p>Handle constant expression, and connect the gep edge </p>

</div>
</div>
<a id="abad522a6e5d90b6d59baf667a6ec8f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad522a6e5d90b6d59baf667a6ec8f32">&#9670;&nbsp;</a></span>setCurrentBBAndValueForPAGEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::setCurrentBBAndValueForPAGEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_v_f_1_1_p_a_g_edge.html">PAGEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We assume every <a class="el" href="class_s_v_f_1_1_gep_val_p_n.html">GepValPN</a> and its <a class="el" href="class_s_v_f_1_1_gep_p_e.html">GepPE</a> are unique across whole program</p>

</div>
</div>
<a id="ac119eecbd406c08b473b39c7fa3e475b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac119eecbd406c08b473b39c7fa3e475b">&#9670;&nbsp;</a></span>visitAllocaInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitAllocaInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_s_v_f.html#a3bacb4f95c73e6d794901d01c6b65a83">AllocaInst</a> &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Our visit overrides. </p>
<p>Visit alloca instructions Add edge V (dst) &lt;&ndash; O (src), V here is a value node on <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a>, O is object node on <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> </p>

</div>
</div>
<a id="a98abdcc0bb0aa457a3a77c03af2a6354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98abdcc0bb0aa457a3a77c03af2a6354">&#9670;&nbsp;</a></span>visitBinaryOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitBinaryOperator </td>
          <td>(</td>
          <td class="paramtype">BinaryOperator &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit Binary Operator </p>

</div>
</div>
<a id="a8afe9cfdcad2b2a961660fb1f8acd0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afe9cfdcad2b2a961660fb1f8acd0d7">&#9670;&nbsp;</a></span>visitBranchInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitBranchInst </td>
          <td>(</td>
          <td class="paramtype">BranchInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Branch and switch instructions are treated as UnaryOP br cmp label if.then, label if.else </p>

</div>
</div>
<a id="abe51d51b7bd29f223552643010df586b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe51d51b7bd29f223552643010df586b">&#9670;&nbsp;</a></span>visitCallSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitCallSite </td>
          <td>(</td>
          <td class="paramtype">CallSite&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect callsite arguments and returns</p>

</div>
</div>
<a id="ae6f28734ad5b933d347f6ebc95dcd2f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f28734ad5b933d347f6ebc95dcd2f2">&#9670;&nbsp;</a></span>visitCmpInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitCmpInst </td>
          <td>(</td>
          <td class="paramtype">CmpInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit compare instruction </p>

</div>
</div>
<a id="a5b7b565582e046a3acb279e315dd5318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7b565582e046a3acb279e315dd5318">&#9670;&nbsp;</a></span>visitExtractElementInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitExtractElementInst </td>
          <td>(</td>
          <td class="paramtype">ExtractElementInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The extractelement instruction extracts a single scalar element from a vector at a specified index. TODO: for now we just assume the pointer after extraction points to blackhole The first operand of an extractelement instruction is a value of vector type. The second operand is an index indicating the position from which to extract the element.</p>
<p>&lt;result&gt; = extractelement &lt;4 x i32&gt; vec, i32 0 ; yields i32 </p>

</div>
</div>
<a id="a54bab83475c617d969b6525f08d68e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bab83475c617d969b6525f08d68e0c">&#9670;&nbsp;</a></span>visitExtractValueInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitExtractValueInst </td>
          <td>(</td>
          <td class="paramtype">ExtractValueInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>visit extract value instructions for structures in registers TODO: for now we just assume the pointer after extraction points to blackhole for example %24 = extractvalue { i32, struct.s_hash* } call34, 0 %24 is a pointer points to first field of a register value call34 however we can not create call34 as an memory object, as it is register value. Is that necessary treat extract value as getelementptr instruction later to get more precise results? </p>

</div>
</div>
<a id="a0385ab439c9f8788678f0490565f6396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0385ab439c9f8788678f0490565f6396">&#9670;&nbsp;</a></span>visitGetElementPtrInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitGetElementPtrInst </td>
          <td>(</td>
          <td class="paramtype">GetElementPtrInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit getelementptr instructions </p>

</div>
</div>
<a id="a7247d100cc4f652d7dc4ca356b0f2538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7247d100cc4f652d7dc4ca356b0f2538">&#9670;&nbsp;</a></span>visitGlobal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitGlobal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_s_v_f_1_1_s_v_f_module.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle globals including (global variable and functions) </p>
<p>Visit global variables for building <a class="el" href="class_s_v_f_1_1_p_a_g.html">PAG</a> </p>
<p>initialize global variable</p>
<p>initialize global functions</p>

</div>
</div>
<a id="a77a96e3bad770eab314403b9d02b263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a96e3bad770eab314403b9d02b263f">&#9670;&nbsp;</a></span>visitPHINode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitPHINode </td>
          <td>(</td>
          <td class="paramtype">PHINode &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit phi instructions </p>

</div>
</div>
<a id="af56d19f29650c772bddeaee3d700b0a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af56d19f29650c772bddeaee3d700b0a7">&#9670;&nbsp;</a></span>visitReturnInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitReturnInst </td>
          <td>(</td>
          <td class="paramtype">ReturnInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit return instructions of a function </p>

</div>
</div>
<a id="a614aeca6530b697c0d67eb2b3173059c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614aeca6530b697c0d67eb2b3173059c">&#9670;&nbsp;</a></span>visitSelectInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitSelectInst </td>
          <td>(</td>
          <td class="paramtype">SelectInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit select instructions </p>
<p>Two operands have same incoming basic block, both are the current BB</p>

</div>
</div>
<a id="a767d67bbcf32288c3a255b20f3d236bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a767d67bbcf32288c3a255b20f3d236bc">&#9670;&nbsp;</a></span>visitStoreInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitStoreInst </td>
          <td>(</td>
          <td class="paramtype">StoreInst &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit store instructions </p>

</div>
</div>
<a id="a7dfed8e95ae4bccdeac53e9c2d3b3cca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfed8e95ae4bccdeac53e9c2d3b3cca">&#9670;&nbsp;</a></span>visitUnaryOperator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PAGBuilder::visitUnaryOperator </td>
          <td>(</td>
          <td class="paramtype">UnaryOperator &amp;&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Visit Unary Operator </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/SVF-FE/<a class="el" href="_p_a_g_builder_8h_source.html">PAGBuilder.h</a></li>
<li>lib/SVF-FE/PAGBuilder.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
