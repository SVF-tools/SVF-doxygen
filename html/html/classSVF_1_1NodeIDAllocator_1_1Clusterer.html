<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::NodeIDAllocator::Clusterer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="classSVF_1_1NodeIDAllocator.html">NodeIDAllocator</a></li><li class="navelem"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html">Clusterer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classSVF_1_1NodeIDAllocator_1_1Clusterer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SVF::NodeIDAllocator::Clusterer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a33d502a0bd49307cd824e34b73157b9b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a33d502a0bd49307cd824e34b73157b9b">cluster</a> (<a class="el" href="classSVF_1_1BVDataPTAImpl.html">BVDataPTAImpl</a> *pta, const std::vector&lt; std::pair&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, unsigned &gt;&gt; keys, std::vector&lt; std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt;&gt; &amp;candidates, std::string evalSubtitle=&quot;&quot;)</td></tr>
<tr class="separator:a33d502a0bd49307cd824e34b73157b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b25188130f4c21d145c950a70d616f"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a36b25188130f4c21d145c950a70d616f">getReverseNodeMapping</a> (const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;nodeMapping)</td></tr>
<tr class="separator:a36b25188130f4c21d145c950a70d616f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbc5c04c79846fe1cc46a3bd5a65aba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#acbbc5c04c79846fe1cc46a3bd5a65aba">evaluate</a> (const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;nodeMap, const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, unsigned &gt; pointsToSets, <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; std::string, std::string &gt; &amp;stats, bool accountForOcc)</td></tr>
<tr class="memdesc:acbbc5c04c79846fe1cc46a3bd5a65aba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in *NumWords statistics in stats..  <a href="#acbbc5c04c79846fe1cc46a3bd5a65aba">More...</a><br /></td></tr>
<tr class="separator:acbbc5c04c79846fe1cc46a3bd5a65aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10cbda6a84ce890c9946a5ff35800b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac10cbda6a84ce890c9946a5ff35800b7">printStats</a> (std::string title, <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; std::string, std::string &gt; &amp;stats)</td></tr>
<tr class="separator:ac10cbda6a84ce890c9946a5ff35800b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a1f74f1e72a844166f742d2d46efbbb5e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#af15e78ec0ab5bf5328d0f8e90c74fe4b">NodePair</a>, std::pair&lt; unsigned, unsigned &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1f74f1e72a844166f742d2d46efbbb5e">DistOccMap</a></td></tr>
<tr class="separator:a1f74f1e72a844166f742d2d46efbbb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ac8c209af1d177cbc8fbbfe4526fe8ce2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac8c209af1d177cbc8fbbfe4526fe8ce2">condensedIndex</a> (size_t n, size_t i, size_t j)</td></tr>
<tr class="separator:ac8c209af1d177cbc8fbbfe4526fe8ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aea96839c51ac1e2cbf4813174bb21c"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">requiredBits</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;pts)</td></tr>
<tr class="memdesc:a9aea96839c51ac1e2cbf4813174bb21c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of bits required to represent pts in a perfect world.  <a href="#a9aea96839c51ac1e2cbf4813174bb21c">More...</a><br /></td></tr>
<tr class="separator:a9aea96839c51ac1e2cbf4813174bb21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f0a6b61a044db819c253f8b9ab093e"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad0f0a6b61a044db819c253f8b9ab093e">requiredBits</a> (const size_t n)</td></tr>
<tr class="memdesc:ad0f0a6b61a044db819c253f8b9ab093e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of bits required to represent n items in a perfect world.  <a href="#ad0f0a6b61a044db819c253f8b9ab093e">More...</a><br /></td></tr>
<tr class="separator:ad0f0a6b61a044db819c253f8b9ab093e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf415d244ef1fafe7a7de3c360553c0f"><td class="memItemLeft" align="right" valign="top">static double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#adf415d244ef1fafe7a7de3c360553c0f">getDistanceMatrix</a> (const std::vector&lt; std::pair&lt; const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> *, unsigned &gt;&gt; pointsToSets, const size_t <a class="el" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, unsigned &gt; &amp;nodeMap, double &amp;distanceMatrixTime)</td></tr>
<tr class="separator:adf415d244ef1fafe7a7de3c360553c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd44e3b07b0482bacf6b1a080fe650c6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">traverseDendrogram</a> (std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;nodeMap, const int *dendrogram, const size_t <a class="el" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, unsigned &amp;allocCounter, <a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt; int &gt; &amp;visited, const int index, const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;regionNodeMap)</td></tr>
<tr class="separator:abd44e3b07b0482bacf6b1a080fe650c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d34542f34a8e8008119c3d61943daa2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a7d34542f34a8e8008119c3d61943daa2">regionObjects</a> (const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, <a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt; &amp;graph, size_t <a class="el" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, size_t &amp;numLabels)</td></tr>
<tr class="separator:a7d34542f34a8e8008119c3d61943daa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f86e733cc075180e9682887c554b8fa"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3f86e733cc075180e9682887c554b8fa">determineBestMapping</a> (const std::vector&lt; std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt;&gt; &amp;candidates, <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, unsigned &gt; pointsToSets, const std::string &amp;evalSubtitle, double &amp;evalTime)</td></tr>
<tr class="separator:a3f86e733cc075180e9682887c554b8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afa74c5ccd22bebe0b76db33066d8b498"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afa74c5ccd22bebe0b76db33066d8b498">NumObjects</a> = &quot;NumObjects&quot;</td></tr>
<tr class="separator:afa74c5ccd22bebe0b76db33066d8b498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f733cad8a103a64e80270acb67567a"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad5f733cad8a103a64e80270acb67567a">RegioningTime</a> = &quot;RegioningTime&quot;</td></tr>
<tr class="separator:ad5f733cad8a103a64e80270acb67567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d2dbb2faab0a0e03bfa353534116a8"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a09d2dbb2faab0a0e03bfa353534116a8">DistanceMatrixTime</a> = &quot;DistanceMatrixTime&quot;</td></tr>
<tr class="separator:a09d2dbb2faab0a0e03bfa353534116a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78d2b60035350c634f6f58d7a043c22"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ae78d2b60035350c634f6f58d7a043c22">FastClusterTime</a> = &quot;FastClusterTime&quot;</td></tr>
<tr class="separator:ae78d2b60035350c634f6f58d7a043c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ab9cffacc1584b2e7bae5d1b08c541"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a67ab9cffacc1584b2e7bae5d1b08c541">DendrogramTraversalTime</a> = &quot;DendrogramTravTime&quot;</td></tr>
<tr class="separator:a67ab9cffacc1584b2e7bae5d1b08c541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d98862e19affdd08740f85490d0d856"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1d98862e19affdd08740f85490d0d856">EvalTime</a> = &quot;EvalTime&quot;</td></tr>
<tr class="separator:a1d98862e19affdd08740f85490d0d856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef85f0ecacd681357b3945f97d52964"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afef85f0ecacd681357b3945f97d52964">TotalTime</a> = &quot;TotalTime&quot;</td></tr>
<tr class="separator:afef85f0ecacd681357b3945f97d52964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a70b98363303cb33d96732f44b4c5c3"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a2a70b98363303cb33d96732f44b4c5c3">TheoreticalNumWords</a> = &quot;TheoreticalWords&quot;</td></tr>
<tr class="separator:a2a70b98363303cb33d96732f44b4c5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2786eae11ee13845da336ad23bc97e9"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af2786eae11ee13845da336ad23bc97e9">OriginalBvNumWords</a> = &quot;OriginalBvWords&quot;</td></tr>
<tr class="separator:af2786eae11ee13845da336ad23bc97e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639b887e30115c2a6cd108c65f18fcc1"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a639b887e30115c2a6cd108c65f18fcc1">OriginalSbvNumWords</a> = &quot;OriginalSbvWords&quot;</td></tr>
<tr class="separator:a639b887e30115c2a6cd108c65f18fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fe4b4098898ee38928c9db30ea0fe9"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">NewBvNumWords</a> = &quot;NewBvWords&quot;</td></tr>
<tr class="separator:af3fe4b4098898ee38928c9db30ea0fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779446e2fe92518401f1732fb809f066"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">NewSbvNumWords</a> = &quot;NewSbvWords&quot;</td></tr>
<tr class="separator:a779446e2fe92518401f1732fb809f066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fe44f10cdbca9754444943a0f5c3c1"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac5fe44f10cdbca9754444943a0f5c3c1">NumRegions</a> = &quot;NumRegions&quot;</td></tr>
<tr class="separator:ac5fe44f10cdbca9754444943a0f5c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cb36a1f0f67864fb8290e9dfd7b639"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad7cb36a1f0f67864fb8290e9dfd7b639">NumGtIntRegions</a> = &quot;NumGtIntRegions&quot;</td></tr>
<tr class="separator:ad7cb36a1f0f67864fb8290e9dfd7b639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172d72ae4ae45fa2baf2f20ff2b499dc"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a172d72ae4ae45fa2baf2f20ff2b499dc">LargestRegion</a> = &quot;LargestRegion&quot;</td></tr>
<tr class="separator:a172d72ae4ae45fa2baf2f20ff2b499dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3556bdda6725b72d0ca88364daeae32e"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3556bdda6725b72d0ca88364daeae32e">BestCandidate</a> = &quot;BestCandidate&quot;</td></tr>
<tr class="separator:a3556bdda6725b72d0ca88364daeae32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf9461c717e8dabaee6a57f3d76d61f"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1bf9461c717e8dabaee6a57f3d76d61f">NumNonTrivialRegionObjects</a> = &quot;NumNonTrivObj&quot;</td></tr>
<tr class="separator:a1bf9461c717e8dabaee6a57f3d76d61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Perform clustering given points-to sets with nodes allocated according to the DENSE strategy. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00102">102</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1f74f1e72a844166f742d2d46efbbb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f74f1e72a844166f742d2d46efbbb5e">&#9670;&nbsp;</a></span>DistOccMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt;<a class="el" href="namespaceSVF.html#af15e78ec0ab5bf5328d0f8e90c74fe4b">NodePair</a>, std::pair&lt;unsigned, unsigned&gt; &gt; <a class="el" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1f74f1e72a844166f742d2d46efbbb5e">SVF::NodeIDAllocator::Clusterer::DistOccMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps a pair of nodes to their (minimum) distance and the number of times that distance occurs in a set of <em>unique</em> points-to sets. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00107">107</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a33d502a0bd49307cd824e34b73157b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d502a0bd49307cd824e34b73157b9b">&#9670;&nbsp;</a></span>cluster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; SVF::NodeIDAllocator::Clusterer::cluster </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1BVDataPTAImpl.html">BVDataPTAImpl</a> *&#160;</td>
          <td class="paramname"><em>pta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, unsigned &gt;&gt;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>evalSubtitle</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns vector mapping previously allocated node IDs to a smarter allocation based on the points-to sets in pta accessed through keys. The second part of the keys pairs are the number of (potential) occurrences of that points-to set or a subset, depending on the client's wish. TODO: interfaces are getting unwieldy, an initialised object may be better. TODO: kind of sucks pta can't be const here because getPts isn't. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00174">174</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    {</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;        <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(pta != <span class="keyword">nullptr</span> &amp;&amp; <span class="stringliteral">&quot;Clusterer::cluster: given null BVDataPTAImpl&quot;</span>);</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;        <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<a class="code" href="classSVF_1_1Options.html#a2537be131132830c63d408133619a065">Options::NodeAllocStrat</a> == Strategy::DENSE &amp;&amp; <span class="stringliteral">&quot;Clusterer::cluster: only dense allocation clustering currently supported&quot;</span>);</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        Map&lt;std::string, std::string&gt; overallStats;</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordtype">double</span> totalTime = 0.0;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        <span class="keywordtype">double</span> fastClusterTime = 0.0;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        <span class="keywordtype">double</span> distanceMatrixTime = 0.0;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;        <span class="keywordtype">double</span> dendrogramTraversalTime = 0.0;</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <span class="keywordtype">double</span> regioningTime = 0.0;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordtype">double</span> evalTime = 0.0;</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;        <span class="comment">// Pair of nodes to their (minimum) distance and the number of occurrences of that distance.</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        Map&lt;std::pair&lt;NodeID, NodeID&gt;, std::pair&lt;unsigned, unsigned&gt;&gt; distances;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;        <span class="keywordtype">double</span> clkStart = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <span class="comment">// Map points-to sets to occurrences.</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        Map&lt;PointsTo, unsigned&gt; pointsToSets;</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="comment">// Objects each object shares at least a points-to set with.</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;        Map&lt;NodeID, Set&lt;NodeID&gt;&gt; coPointeeGraph;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;NodeID, unsigned&gt; &amp;keyOcc : keys)</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;        {</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;            <span class="keyword">const</span> PointsTo &amp;pts = pta-&gt;getPts(keyOcc.first);</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">size_t</span> oldSize = pointsToSets.size();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;            pointsToSets[pts] += keyOcc.second;;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;            <span class="comment">// Edges in this graph have no weight or uniqueness, so we only need to</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;            <span class="comment">// do this for each points-to set once.</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;            <span class="keywordflow">if</span> (oldSize != pointsToSets.size())</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;            {</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;                <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> firstO = !pts.empty() ? *(pts.begin()) : 0;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;                Set&lt;NodeID&gt; &amp;firstOsNeighbours = coPointeeGraph[firstO];</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts)</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;                {</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                    <span class="keywordflow">if</span> (o != firstO)</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;                    {</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;                        firstOsNeighbours.insert(o);</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                        coPointeeGraph[o].insert(firstO);</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;                    }</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;                }</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;            }</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        }</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        <span class="keywordtype">size_t</span> <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a> = <a class="code" href="classSVF_1_1NodeIDAllocator.html#a2bd3ca30fc9669d9a0327544bdb4557b">NodeIDAllocator::get</a>()-&gt;<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afa74c5ccd22bebe0b76db33066d8b498">NumObjects</a>] = std::to_string(numObjects);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;        <span class="keywordtype">size_t</span> numRegions = 0;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;        std::vector&lt;unsigned&gt; objectsRegion;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1Options.html#ab6115b28808af348e1f6a6b58b4cd84f">Options::RegionedClustering</a>)</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        {</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;            objectsRegion = <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a7d34542f34a8e8008119c3d61943daa2">regionObjects</a>(coPointeeGraph, numObjects, numRegions);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;        }</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        {</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;            <span class="comment">// Just a single big region (0).</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;            objectsRegion.insert(objectsRegion.end(), <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, 0);</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;            numRegions = 1;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        }</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="comment">// Set needs to be ordered because getDistanceMatrix, in its n^2 iteration, expects</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="comment">// sets to be ordered (we are building a condensed matrix, not a full matrix, so it</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="comment">// matters). In getDistanceMatrix, doing regionReverseMapping for oi and oj, where</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="comment">// oi &lt; oj, and getting a result moi &gt; moj gives incorrect results.</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="comment">// In the condensed matrix, [b][a] where b &gt;= a, is incorrect.</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;        std::vector&lt;OrderedSet&lt;NodeID&gt;&gt; regionsObjects(numRegions);</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o = 0; o &lt; <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>; ++o) regionsObjects[objectsRegion[o]].insert(o);</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        <span class="comment">// Size of the return node mapping. It is potentially larger than the number of</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        <span class="comment">// objects because we align each region to NATIVE_INT_SIZE.</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        <span class="keywordtype">size_t</span> numMappings = 0;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="comment">// Maps a region to a mapping which maps 0 to n to all objects</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="comment">// in that region.</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        std::vector&lt;std::vector&lt;NodeID&gt;&gt; regionMappings(numRegions);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="comment">// The reverse: region to mapping of objects to a 0 to n from above.</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        std::vector&lt;Map&lt;NodeID, unsigned&gt;&gt; regionReverseMappings(numRegions);</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        <span class="comment">// We can thus use 0 to n for each region to create smaller distance matrices.</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> region = 0; region &lt; numRegions; ++region)</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        {</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;            <span class="keywordtype">size_t</span> curr = 0;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;            <span class="comment">// With the OrderedSet above, o1 &lt; o2 =&gt; map[o1] &lt; map[o2].</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : regionsObjects[region])</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;            {</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;                <span class="comment">// push_back here is just like p...[region][curr] = o.</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;                regionMappings[region].push_back(o);</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;                regionReverseMappings[region][o] = curr++;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            }</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            <span class="comment">// curr is the number of objects. A region with no objects makes no sense.</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(curr != 0);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;            <span class="comment">// Number of bits needed for this region if we were</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;            <span class="comment">// to start assigning from 0 rounded up to the fewest needed</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;            <span class="comment">// native ints. This is added to the number of mappings since</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;            <span class="comment">// we align each region to a native int.</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            numMappings += <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">requiredBits</a>(regionsObjects[region].size());</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        <span class="comment">// Points-to sets which are relevant to a region, i.e., those whose elements</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        <span class="comment">// belong to that region. Pair is for occurences.</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;        std::vector&lt;std::vector&lt;std::pair&lt;const PointsTo *, unsigned&gt;&gt;&gt; regionsPointsTos(numRegions);</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Map&lt;PointsTo, unsigned&gt;::value_type &amp;ptocc : pointsToSets)</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        {</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;            <span class="keyword">const</span> PointsTo &amp;pt = ptocc.first;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> occ = ptocc.second;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            <span class="keywordflow">if</span> (pt.empty()) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;            <span class="comment">// Guaranteed that begin() != end() because of the continue above. All objects in pt</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="comment">// will be relevant to the same region.</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            <span class="keywordtype">unsigned</span> region = objectsRegion[*(pt.begin())];</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;            <span class="comment">// In our &quot;graph&quot;, objects in the same points-to set have an edge between them,</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="comment">// so they are all in the same connected component/region.</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            regionsPointsTos[region].push_back(std::make_pair(&amp;pt, occ));</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        }</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordtype">double</span> clkEnd = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        regioningTime = (clkEnd - clkStart) / <a class="code" href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a>;</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad5f733cad8a103a64e80270acb67567a">RegioningTime</a>] = std::to_string(regioningTime);</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac5fe44f10cdbca9754444943a0f5c3c1">NumRegions</a>] = std::to_string(numRegions);</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;        std::vector&lt;hclust_fast_methods&gt; methods;</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1Options.html#a8e0538a7f2e3c5bece69bc69f7074819">Options::ClusterMethod</a> == <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>)</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        {</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;            methods.push_back(<a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a>);</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;            methods.push_back(<a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a>);</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            methods.push_back(<a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a>);</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        {</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;            methods.push_back(<a class="code" href="classSVF_1_1Options.html#a8e0538a7f2e3c5bece69bc69f7074819">Options::ClusterMethod</a>);</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;        }</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method : methods)</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;        {</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;            std::vector&lt;NodeID&gt; nodeMap(numObjects, UINT_MAX);</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;            <span class="keywordtype">unsigned</span> numGtIntRegions = 0;</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;            <span class="keywordtype">unsigned</span> largestRegion = 0;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;            <span class="keywordtype">unsigned</span> nonTrivialRegionObjects = 0;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;            <span class="keywordtype">unsigned</span> allocCounter = 0;</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> region = 0; region &lt; numRegions; ++region)</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;            {</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">size_t</span> regionNumObjects = regionsObjects[region].size();</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                <span class="comment">// Round up to next Word: ceiling of current allocation to get how</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                <span class="comment">// many words and multiply to get the number of bits; if we&#39;re aligning.</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1Options.html#a88550ed8c4ec2ccc5d5e40869499787b">Options::RegionAlign</a>)</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                {</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                    allocCounter =</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                        ((allocCounter + <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a> - 1) / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>) * <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                }</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                <span class="keywordflow">if</span> (regionNumObjects &gt; largestRegion) largestRegion = regionNumObjects;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                <span class="comment">// For regions with fewer than 64 objects, we can just allocate them</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;                <span class="comment">// however as they will be in the one int regardless..</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                <span class="keywordflow">if</span> (regionNumObjects &lt; <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>)</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                {</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : regionsObjects[region]) nodeMap[o] = allocCounter++;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                }</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;                ++numGtIntRegions;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                nonTrivialRegionObjects += regionNumObjects;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                <span class="keywordtype">double</span> *distMatrix = <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#adf415d244ef1fafe7a7de3c360553c0f">getDistanceMatrix</a>(regionsPointsTos[region], regionNumObjects,</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                                                       regionReverseMappings[region], distanceMatrixTime);</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                clkStart = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;                <span class="keywordtype">int</span> *dendrogram = <span class="keyword">new</span> <span class="keywordtype">int</span>[2 * (regionNumObjects - 1)];</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                <span class="keywordtype">double</span> *height = <span class="keyword">new</span> <span class="keywordtype">double</span>[regionNumObjects - 1];</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                <a class="code" href="fastcluster_8h.html#acccd226cbdf0944b5c9e24c84a4599c9">hclust_fast</a>(regionNumObjects, distMatrix, method, dendrogram, height);</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;                <span class="keyword">delete</span>[] distMatrix;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;                <span class="keyword">delete</span>[] height;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;                clkEnd = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;                fastClusterTime += (clkEnd - clkStart) / <a class="code" href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a>;</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;                clkStart = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;                Set&lt;int&gt; visited;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;                <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">traverseDendrogram</a>(nodeMap, dendrogram, regionNumObjects, allocCounter,</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;                                   visited, regionNumObjects - 1, regionMappings[region]);</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;                <span class="keyword">delete</span>[] dendrogram;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;                clkEnd = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;                dendrogramTraversalTime += (clkEnd - clkStart) / <a class="code" href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a>;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;            }</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;            candidates.push_back(std::make_pair(method, nodeMap));</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;            <span class="comment">// Though we &quot;update&quot; these in the loop, they will be the same every iteration.</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;            overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad7cb36a1f0f67864fb8290e9dfd7b639">NumGtIntRegions</a>] = std::to_string(numGtIntRegions);</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;            overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a172d72ae4ae45fa2baf2f20ff2b499dc">LargestRegion</a>] = std::to_string(largestRegion);</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;            overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1bf9461c717e8dabaee6a57f3d76d61f">NumNonTrivialRegionObjects</a>] = std::to_string(nonTrivialRegionObjects);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;        }</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        <span class="comment">// Work out which of the mappings we generated looks best.</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        std::pair&lt;hclust_fast_methods, std::vector&lt;NodeID&gt;&gt; bestMapping = <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3f86e733cc075180e9682887c554b8fa">determineBestMapping</a>(candidates, pointsToSets,</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;                                                                                               evalSubtitle, evalTime);</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a09d2dbb2faab0a0e03bfa353534116a8">DistanceMatrixTime</a>] = std::to_string(distanceMatrixTime);</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a67ab9cffacc1584b2e7bae5d1b08c541">DendrogramTraversalTime</a>] = std::to_string(dendrogramTraversalTime);</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ae78d2b60035350c634f6f58d7a043c22">FastClusterTime</a>] = std::to_string(fastClusterTime);</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1d98862e19affdd08740f85490d0d856">EvalTime</a>] = std::to_string(evalTime);</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afef85f0ecacd681357b3945f97d52964">TotalTime</a>] = std::to_string(distanceMatrixTime + dendrogramTraversalTime + fastClusterTime + regioningTime + evalTime);</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;        overallStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3556bdda6725b72d0ca88364daeae32e">BestCandidate</a>] = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVFUtil::hclustMethodToString</a>(bestMapping.first);</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;        <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac10cbda6a84ce890c9946a5ff35800b7">printStats</a>(evalSubtitle + <span class="stringliteral">&quot;: overall&quot;</span>, overallStats);</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;        <span class="keywordflow">return</span> bestMapping.second;</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    }</div><div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ad7cb36a1f0f67864fb8290e9dfd7b639"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad7cb36a1f0f67864fb8290e9dfd7b639">SVF::NodeIDAllocator::Clusterer::NumGtIntRegions</a></div><div class="ttdeci">static const std::string NumGtIntRegions</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00124">NodeIDAllocator.h:124</a></div></div>
<div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00018">MTAResultValidator.h:18</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a9aea96839c51ac1e2cbf4813174bb21c"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">SVF::NodeIDAllocator::Clusterer::requiredBits</a></div><div class="ttdeci">static unsigned requiredBits(const PointsTo &amp;pts)</div><div class="ttdoc">Returns the minimum number of bits required to represent pts in a perfect world. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00405">NodeIDAllocator.cpp:405</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a67ab9cffacc1584b2e7bae5d1b08c541"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a67ab9cffacc1584b2e7bae5d1b08c541">SVF::NodeIDAllocator::Clusterer::DendrogramTraversalTime</a></div><div class="ttdeci">static const std::string DendrogramTraversalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00115">NodeIDAllocator.h:115</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_html_a190c729a3f3f622f82cee4917946b50f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">SVF::NodeIDAllocator::numObjects</a></div><div class="ttdeci">NodeID numObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00084">NodeIDAllocator.h:84</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_a2537be131132830c63d408133619a065"><div class="ttname"><a href="classSVF_1_1Options.html#a2537be131132830c63d408133619a065">SVF::Options::NodeAllocStrat</a></div><div class="ttdeci">static const llvm::cl::opt&lt; SVF::NodeIDAllocator::Strategy &gt; NodeAllocStrat</div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00034">Options.h:34</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_afa74c5ccd22bebe0b76db33066d8b498"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afa74c5ccd22bebe0b76db33066d8b498">SVF::NodeIDAllocator::Clusterer::NumObjects</a></div><div class="ttdeci">static const std::string NumObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00111">NodeIDAllocator.h:111</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ad5f733cad8a103a64e80270acb67567a"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad5f733cad8a103a64e80270acb67567a">SVF::NodeIDAllocator::Clusterer::RegioningTime</a></div><div class="ttdeci">static const std::string RegioningTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00112">NodeIDAllocator.h:112</a></div></div>
<div class="ttc" id="fastcluster_8h_html_acccd226cbdf0944b5c9e24c84a4599c9"><div class="ttname"><a href="fastcluster_8h.html#acccd226cbdf0944b5c9e24c84a4599c9">hclust_fast</a></div><div class="ttdeci">int hclust_fast(int n, double *distmat, int method, int *merge, double *height)</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8cpp_source.html#l00133">fastcluster.cpp:133</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ac10cbda6a84ce890c9946a5ff35800b7"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac10cbda6a84ce890c9946a5ff35800b7">SVF::NodeIDAllocator::Clusterer::printStats</a></div><div class="ttdeci">static void printStats(std::string title, Map&lt; std::string, std::string &gt; &amp;stats)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00678">NodeIDAllocator.cpp:678</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ae78d2b60035350c634f6f58d7a043c22"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ae78d2b60035350c634f6f58d7a043c22">SVF::NodeIDAllocator::Clusterer::FastClusterTime</a></div><div class="ttdeci">static const std::string FastClusterTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00114">NodeIDAllocator.h:114</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_a88550ed8c4ec2ccc5d5e40869499787b"><div class="ttname"><a href="classSVF_1_1Options.html#a88550ed8c4ec2ccc5d5e40869499787b">SVF::Options::RegionAlign</a></div><div class="ttdeci">static const llvm::cl::opt&lt; bool &gt; RegionAlign</div><div class="ttdoc">Align identifiers in each region to a word. </div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00061">Options.h:61</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00069">fastcluster.h:69</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a3f86e733cc075180e9682887c554b8fa"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3f86e733cc075180e9682887c554b8fa">SVF::NodeIDAllocator::Clusterer::determineBestMapping</a></div><div class="ttdeci">static std::pair&lt; hclust_fast_methods, std::vector&lt; NodeID &gt; &gt; determineBestMapping(const std::vector&lt; std::pair&lt; hclust_fast_methods, std::vector&lt; NodeID &gt;&gt;&gt; &amp;candidates, Map&lt; PointsTo, unsigned &gt; pointsToSets, const std::string &amp;evalSubtitle, double &amp;evalTime)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00638">NodeIDAllocator.cpp:638</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a7d34542f34a8e8008119c3d61943daa2"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a7d34542f34a8e8008119c3d61943daa2">SVF::NodeIDAllocator::Clusterer::regionObjects</a></div><div class="ttdeci">static std::vector&lt; unsigned &gt; regionObjects(const Map&lt; NodeID, Set&lt; NodeID &gt;&gt; &amp;graph, size_t numObjects, size_t &amp;numLabels)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00520">NodeIDAllocator.cpp:520</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00075">fastcluster.h:75</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dd"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a></div><div class="ttdeci">hclust_fast_methods</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00065">fastcluster.h:65</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_a8e0538a7f2e3c5bece69bc69f7074819"><div class="ttname"><a href="classSVF_1_1Options.html#a8e0538a7f2e3c5bece69bc69f7074819">SVF::Options::ClusterMethod</a></div><div class="ttdeci">static const llvm::cl::opt&lt; enum hclust_fast_methods &gt; ClusterMethod</div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00055">Options.h:55</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a14a4c5124f2fd03ca3d898e2acd54160"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVF::SVFUtil::hclustMethodToString</a></div><div class="ttdeci">std::string hclustMethodToString(hclust_fast_methods method)</div><div class="ttdoc">Returns a string representation of a hclust method. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00365">SVFUtil.cpp:365</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a3556bdda6725b72d0ca88364daeae32e"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3556bdda6725b72d0ca88364daeae32e">SVF::NodeIDAllocator::Clusterer::BestCandidate</a></div><div class="ttdeci">static const std::string BestCandidate</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00126">NodeIDAllocator.h:126</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00067">fastcluster.h:67</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_a1aeda3370621dc00e9a0fe8e7aabc736"><div class="ttname"><a href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a></div><div class="ttdeci">#define TIMEINTERVAL</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00174">SVFBasicTypes.h:174</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a172d72ae4ae45fa2baf2f20ff2b499dc"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a172d72ae4ae45fa2baf2f20ff2b499dc">SVF::NodeIDAllocator::Clusterer::LargestRegion</a></div><div class="ttdeci">static const std::string LargestRegion</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00125">NodeIDAllocator.h:125</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_adf415d244ef1fafe7a7de3c360553c0f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#adf415d244ef1fafe7a7de3c360553c0f">SVF::NodeIDAllocator::Clusterer::getDistanceMatrix</a></div><div class="ttdeci">static double * getDistanceMatrix(const std::vector&lt; std::pair&lt; const PointsTo *, unsigned &gt;&gt; pointsToSets, const size_t numObjects, const Map&lt; NodeID, unsigned &gt; &amp;nodeMap, double &amp;distanceMatrixTime)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00418">NodeIDAllocator.cpp:418</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_ab6115b28808af348e1f6a6b58b4cd84f"><div class="ttname"><a href="classSVF_1_1Options.html#ab6115b28808af348e1f6a6b58b4cd84f">SVF::Options::RegionedClustering</a></div><div class="ttdeci">static const llvm::cl::opt&lt; bool &gt; RegionedClustering</div><div class="ttdoc">Cluster partitions separately. </div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00058">Options.h:58</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00071">fastcluster.h:71</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_html_a2bd3ca30fc9669d9a0327544bdb4557b"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator.html#a2bd3ca30fc9669d9a0327544bdb4557b">SVF::NodeIDAllocator::get</a></div><div class="ttdeci">static NodeIDAllocator * get(void)</div><div class="ttdoc">Return (singleton) allocator. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00025">NodeIDAllocator.cpp:25</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a09d2dbb2faab0a0e03bfa353534116a8"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a09d2dbb2faab0a0e03bfa353534116a8">SVF::NodeIDAllocator::Clusterer::DistanceMatrixTime</a></div><div class="ttdeci">static const std::string DistanceMatrixTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00113">NodeIDAllocator.h:113</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_afef85f0ecacd681357b3945f97d52964"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afef85f0ecacd681357b3945f97d52964">SVF::NodeIDAllocator::Clusterer::TotalTime</a></div><div class="ttdeci">static const std::string TotalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00117">NodeIDAllocator.h:117</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a1d98862e19affdd08740f85490d0d856"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1d98862e19affdd08740f85490d0d856">SVF::NodeIDAllocator::Clusterer::EvalTime</a></div><div class="ttdeci">static const std::string EvalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00116">NodeIDAllocator.h:116</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a1bf9461c717e8dabaee6a57f3d76d61f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1bf9461c717e8dabaee6a57f3d76d61f">SVF::NodeIDAllocator::Clusterer::NumNonTrivialRegionObjects</a></div><div class="ttdeci">static const std::string NumNonTrivialRegionObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00127">NodeIDAllocator.h:127</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ac5fe44f10cdbca9754444943a0f5c3c1"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac5fe44f10cdbca9754444943a0f5c3c1">SVF::NodeIDAllocator::Clusterer::NumRegions</a></div><div class="ttdeci">static const std::string NumRegions</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00123">NodeIDAllocator.h:123</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_ab8ca0fd9d0caa6817d305cae0f1cf022"><div class="ttname"><a href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a></div><div class="ttdeci">#define NATIVE_INT_SIZE</div><div class="ttdoc">Size of native integer that we&amp;#39;ll use for bit vectors, in bits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00178">SVFBasicTypes.h:178</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_abd44e3b07b0482bacf6b1a080fe650c6"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">SVF::NodeIDAllocator::Clusterer::traverseDendrogram</a></div><div class="ttdeci">static void traverseDendrogram(std::vector&lt; NodeID &gt; &amp;nodeMap, const int *dendrogram, const size_t numObjects, unsigned &amp;allocCounter, Set&lt; int &gt; &amp;visited, const int index, const std::vector&lt; NodeID &gt; &amp;regionNodeMap)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00489">NodeIDAllocator.cpp:489</a></div></div>
<div class="ttc" id="classSVF_1_1PTAStat_html_a3c4eaa1695ea13405911ae1621f98edc"><div class="ttname"><a href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">SVF::PTAStat::getClk</a></div><div class="ttdeci">static double getClk(bool mark=false)</div><div class="ttdef"><b>Definition:</b> <a href="PTAStat_8cpp_source.html#l00114">PTAStat.cpp:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8c209af1d177cbc8fbbfe4526fe8ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c209af1d177cbc8fbbfe4526fe8ce2">&#9670;&nbsp;</a></span>condensedIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SVF::NodeIDAllocator::Clusterer::condensedIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an index into a condensed matrix (upper triangle, excluding diagonals) corresponding to an nxn matrix. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00399">399</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    {</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="comment">// From https://stackoverflow.com/a/14839010</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="keywordflow">return</span> n*(n-1)/2 - (n-i)*(n-i-1)/2 + j - i - 1;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a id="a3f86e733cc075180e9682887c554b8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f86e733cc075180e9682887c554b8fa">&#9670;&nbsp;</a></span>determineBestMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &gt; SVF::NodeIDAllocator::Clusterer::determineBestMapping </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>candidates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, unsigned &gt;&#160;</td>
          <td class="paramname"><em>pointsToSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>evalSubtitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>evalTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00638">638</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;    {</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;        <span class="comment">// In case we&#39;re not comparing anything, set to first &quot;candidate&quot;.</span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;        std::pair&lt;hclust_fast_methods, std::vector&lt;NodeID&gt;&gt; bestMapping = candidates[0];</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;        <span class="comment">// Number of bits required for the best candidate.</span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;        <span class="keywordtype">size_t</span> bestWords = std::numeric_limits&lt;size_t&gt;::max();</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;        <span class="keywordflow">if</span> (evalSubtitle != <span class="stringliteral">&quot;&quot;</span> || <a class="code" href="classSVF_1_1Options.html#a8e0538a7f2e3c5bece69bc69f7074819">Options::ClusterMethod</a> == <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>)</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;        {</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;<a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>, std::vector&lt;NodeID&gt;&gt; &amp;candidate : candidates)</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;            {</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;                Map&lt;std::string, std::string&gt; candidateStats;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;                <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> candidateMethod = candidate.first;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;                std::string candidateMethodName = <a class="code" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVFUtil::hclustMethodToString</a>(candidateMethod);</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;                std::vector&lt;NodeID&gt; candidateMapping = candidate.second;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                <span class="comment">// TODO: parameterise final arg.</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">double</span> clkStart = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#acbbc5c04c79846fe1cc46a3bd5a65aba">evaluate</a>(candidateMapping, pointsToSets, candidateStats, <span class="keyword">true</span>);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                <span class="keyword">const</span> <span class="keywordtype">double</span> clkEnd = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                evalTime += (clkEnd - clkStart) / <a class="code" href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a>;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac10cbda6a84ce890c9946a5ff35800b7">printStats</a>(evalSubtitle + <span class="stringliteral">&quot;: candidate &quot;</span> + candidateMethodName, candidateStats);</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;                <span class="keywordtype">size_t</span> candidateWords = 0;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;                <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1Options.html#abc02c7dc5e6cb3613856e0f774c6d304">Options::PtType</a> == <a class="code" href="classSVF_1_1PointsTo.html#a8f757f92ebf0a2ebdb5e6b001606923eacccb6e19f3e8db5f5b5b8858b22da61a">PointsTo::SBV</a>) candidateWords = std::stoull(candidateStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">NewSbvNumWords</a>]);</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classSVF_1_1Options.html#abc02c7dc5e6cb3613856e0f774c6d304">Options::PtType</a> == <a class="code" href="classSVF_1_1PointsTo.html#a8f757f92ebf0a2ebdb5e6b001606923ea0397c2678894d1792fcd3432a7aa64fb">PointsTo::CBV</a>) candidateWords = std::stoull(candidateStats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">NewBvNumWords</a>]);</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                <span class="keywordflow">else</span> <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;Clusterer::cluster: unsupported BV type for clustering.&quot;</span>);</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;                <span class="keywordflow">if</span> (candidateWords &lt; bestWords)</div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;                {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;                    bestWords = candidateWords;</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;                    bestMapping = candidate;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;                }</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;            }</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;        }</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;        <span class="keywordflow">return</span> bestMapping;</div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;    }</div><div class="ttc" id="classSVF_1_1PointsTo_html_a8f757f92ebf0a2ebdb5e6b001606923eacccb6e19f3e8db5f5b5b8858b22da61a"><div class="ttname"><a href="classSVF_1_1PointsTo.html#a8f757f92ebf0a2ebdb5e6b001606923eacccb6e19f3e8db5f5b5b8858b22da61a">SVF::PointsTo::SBV</a></div><div class="ttdef"><b>Definition:</b> <a href="PointsTo_8h_source.html#l00032">PointsTo.h:32</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_acbbc5c04c79846fe1cc46a3bd5a65aba"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#acbbc5c04c79846fe1cc46a3bd5a65aba">SVF::NodeIDAllocator::Clusterer::evaluate</a></div><div class="ttdeci">static void evaluate(const std::vector&lt; NodeID &gt; &amp;nodeMap, const Map&lt; PointsTo, unsigned &gt; pointsToSets, Map&lt; std::string, std::string &gt; &amp;stats, bool accountForOcc)</div><div class="ttdoc">Fills in *NumWords statistics in stats.. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00560">NodeIDAllocator.cpp:560</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a779446e2fe92518401f1732fb809f066"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">SVF::NodeIDAllocator::Clusterer::NewSbvNumWords</a></div><div class="ttdeci">static const std::string NewSbvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00122">NodeIDAllocator.h:122</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_abc02c7dc5e6cb3613856e0f774c6d304"><div class="ttname"><a href="classSVF_1_1Options.html#abc02c7dc5e6cb3613856e0f774c6d304">SVF::Options::PtType</a></div><div class="ttdeci">static const llvm::cl::opt&lt; PointsTo::Type &gt; PtType</div><div class="ttdoc">Type of points-to set to use for all analyses. </div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00049">Options.h:49</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ac10cbda6a84ce890c9946a5ff35800b7"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac10cbda6a84ce890c9946a5ff35800b7">SVF::NodeIDAllocator::Clusterer::printStats</a></div><div class="ttdeci">static void printStats(std::string title, Map&lt; std::string, std::string &gt; &amp;stats)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00678">NodeIDAllocator.cpp:678</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00075">fastcluster.h:75</a></div></div>
<div class="ttc" id="fastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dd"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a></div><div class="ttdeci">hclust_fast_methods</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00065">fastcluster.h:65</a></div></div>
<div class="ttc" id="classSVF_1_1Options_html_a8e0538a7f2e3c5bece69bc69f7074819"><div class="ttname"><a href="classSVF_1_1Options.html#a8e0538a7f2e3c5bece69bc69f7074819">SVF::Options::ClusterMethod</a></div><div class="ttdeci">static const llvm::cl::opt&lt; enum hclust_fast_methods &gt; ClusterMethod</div><div class="ttdef"><b>Definition:</b> <a href="Options_8h_source.html#l00055">Options.h:55</a></div></div>
<div class="ttc" id="namespaceSVF_1_1SVFUtil_html_a14a4c5124f2fd03ca3d898e2acd54160"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">SVF::SVFUtil::hclustMethodToString</a></div><div class="ttdeci">std::string hclustMethodToString(hclust_fast_methods method)</div><div class="ttdoc">Returns a string representation of a hclust method. </div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00365">SVFUtil.cpp:365</a></div></div>
<div class="ttc" id="classSVF_1_1PointsTo_html_a8f757f92ebf0a2ebdb5e6b001606923ea0397c2678894d1792fcd3432a7aa64fb"><div class="ttname"><a href="classSVF_1_1PointsTo.html#a8f757f92ebf0a2ebdb5e6b001606923ea0397c2678894d1792fcd3432a7aa64fb">SVF::PointsTo::CBV</a></div><div class="ttdef"><b>Definition:</b> <a href="PointsTo_8h_source.html#l00033">PointsTo.h:33</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_a1aeda3370621dc00e9a0fe8e7aabc736"><div class="ttname"><a href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a></div><div class="ttdeci">#define TIMEINTERVAL</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00174">SVFBasicTypes.h:174</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_af3fe4b4098898ee38928c9db30ea0fe9"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">SVF::NodeIDAllocator::Clusterer::NewBvNumWords</a></div><div class="ttdeci">static const std::string NewBvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00121">NodeIDAllocator.h:121</a></div></div>
<div class="ttc" id="classSVF_1_1PTAStat_html_a3c4eaa1695ea13405911ae1621f98edc"><div class="ttname"><a href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">SVF::PTAStat::getClk</a></div><div class="ttdeci">static double getClk(bool mark=false)</div><div class="ttdef"><b>Definition:</b> <a href="PTAStat_8cpp_source.html#l00114">PTAStat.cpp:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acbbc5c04c79846fe1cc46a3bd5a65aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbc5c04c79846fe1cc46a3bd5a65aba">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::NodeIDAllocator::Clusterer::evaluate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, unsigned &gt;&#160;</td>
          <td class="paramname"><em>pointsToSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>accountForOcc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in *NumWords statistics in stats.. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00560">560</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;    {</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> totalTheoretical = 0;</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> totalOriginalSbv = 0;</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> totalOriginalBv = 0;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;        <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> totalNewSbv = 0;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;        <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> totalNewBv = 0;</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> Map&lt;PointsTo, unsigned&gt;::value_type &amp;ptsOcc : pointsToSets)</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        {</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;            <span class="keyword">const</span> PointsTo &amp;pts = ptsOcc.first;</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> occ = ptsOcc.second;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;            <span class="keywordflow">if</span> (pts.count() == 0) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> theoretical = <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">requiredBits</a>(pts) / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;            <span class="keywordflow">if</span> (accountForOcc) theoretical *= occ;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;            <span class="comment">// Check number of words for original SBV.</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;            Set&lt;unsigned&gt; words;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;            <span class="comment">// TODO: nasty hardcoding.</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts) words.insert(o / 128);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;            <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> originalSbv = words.size() * 2;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;            <span class="keywordflow">if</span> (accountForOcc) originalSbv *= occ;</div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;            <span class="comment">// Check number of words for original BV.</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;            <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> min = UINT_MAX;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;            <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> max = 0;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts)</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;            {</div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;                <span class="keywordflow">if</span> (o &lt; min) min = o;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;                <span class="keywordflow">if</span> (o &gt; max) max = o;</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;            }</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;            words.clear();</div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> b = min; b &lt;= max; ++b)</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;            {</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;                words.insert(b / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>);</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;            }</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;            <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> originalBv = words.size();</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;            <span class="keywordflow">if</span> (accountForOcc) originalBv *= occ;</div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;            <span class="comment">// Check number of words for new SBV.</span></div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;            words.clear();</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;            <span class="comment">// TODO: nasty hardcoding.</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts) words.insert(nodeMap[o] / 128);</div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;            <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> newSbv = words.size() * 2;</div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;            <span class="keywordflow">if</span> (accountForOcc) newSbv *= occ;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;            <span class="comment">// Check number of words for new BV.</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;            min = UINT_MAX;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;            max = 0;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts)</div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;            {</div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> mappedO = nodeMap[o];</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;                <span class="keywordflow">if</span> (mappedO &lt; min) min = mappedO;</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;                <span class="keywordflow">if</span> (mappedO &gt; max) max = mappedO;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;            }</div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;</div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;            words.clear();</div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;            <span class="comment">// No nodeMap[b] because min and max and from nodeMap.</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;            <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> b = min; b &lt;= max; ++b) words.insert(b / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>);</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;            <a class="code" href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">u64_t</a> newBv = words.size();</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;            <span class="keywordflow">if</span> (accountForOcc) newBv *= occ;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;            totalTheoretical += theoretical;</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;            totalOriginalSbv += originalSbv;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;            totalOriginalBv += originalBv;</div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;            totalNewSbv += newSbv;</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;            totalNewBv += newBv;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;        }</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;        stats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a2a70b98363303cb33d96732f44b4c5c3">TheoreticalNumWords</a>] = std::to_string(totalTheoretical);</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;        stats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a639b887e30115c2a6cd108c65f18fcc1">OriginalSbvNumWords</a>] = std::to_string(totalOriginalSbv);</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;        stats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af2786eae11ee13845da336ad23bc97e9">OriginalBvNumWords</a>] = std::to_string(totalOriginalBv);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        stats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">NewSbvNumWords</a>] = std::to_string(totalNewSbv);</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        stats[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">NewBvNumWords</a>] = std::to_string(totalNewBv);</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    }</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00018">MTAResultValidator.h:18</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a9aea96839c51ac1e2cbf4813174bb21c"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">SVF::NodeIDAllocator::Clusterer::requiredBits</a></div><div class="ttdeci">static unsigned requiredBits(const PointsTo &amp;pts)</div><div class="ttdoc">Returns the minimum number of bits required to represent pts in a perfect world. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00405">NodeIDAllocator.cpp:405</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_af2786eae11ee13845da336ad23bc97e9"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af2786eae11ee13845da336ad23bc97e9">SVF::NodeIDAllocator::Clusterer::OriginalBvNumWords</a></div><div class="ttdeci">static const std::string OriginalBvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00119">NodeIDAllocator.h:119</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a779446e2fe92518401f1732fb809f066"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">SVF::NodeIDAllocator::Clusterer::NewSbvNumWords</a></div><div class="ttdeci">static const std::string NewSbvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00122">NodeIDAllocator.h:122</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a2a70b98363303cb33d96732f44b4c5c3"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a2a70b98363303cb33d96732f44b4c5c3">SVF::NodeIDAllocator::Clusterer::TheoreticalNumWords</a></div><div class="ttdeci">static const std::string TheoreticalNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00118">NodeIDAllocator.h:118</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a639b887e30115c2a6cd108c65f18fcc1"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a639b887e30115c2a6cd108c65f18fcc1">SVF::NodeIDAllocator::Clusterer::OriginalSbvNumWords</a></div><div class="ttdeci">static const std::string OriginalSbvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00120">NodeIDAllocator.h:120</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_af3fe4b4098898ee38928c9db30ea0fe9"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">SVF::NodeIDAllocator::Clusterer::NewBvNumWords</a></div><div class="ttdeci">static const std::string NewBvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00121">NodeIDAllocator.h:121</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_ab8ca0fd9d0caa6817d305cae0f1cf022"><div class="ttname"><a href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a></div><div class="ttdeci">#define NATIVE_INT_SIZE</div><div class="ttdoc">Size of native integer that we&amp;#39;ll use for bit vectors, in bits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00178">SVFBasicTypes.h:178</a></div></div>
<div class="ttc" id="namespaceSVF_html_a366625858f450a1ea5f985a3c83e0f14"><div class="ttname"><a href="namespaceSVF.html#a366625858f450a1ea5f985a3c83e0f14">SVF::u64_t</a></div><div class="ttdeci">unsigned long long u64_t</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00076">SVFBasicTypes.h:76</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adf415d244ef1fafe7a7de3c360553c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf415d244ef1fafe7a7de3c360553c0f">&#9670;&nbsp;</a></span>getDistanceMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double * SVF::NodeIDAllocator::Clusterer::getDistanceMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> *, unsigned &gt;&gt;&#160;</td>
          <td class="paramname"><em>pointsToSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>distanceMatrixTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Builds the upper triangle of the distance matrix, as an array of length (numObjects * (numObjects - 1)) / 2, as required by fastcluster. Responsibility of caller to <code>delete</code>. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00418">418</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    {</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">double</span> clkStart = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        <span class="keywordtype">size_t</span> condensedSize = (<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a> * (<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a> - 1)) / 2;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;        <span class="keywordtype">double</span> *distMatrix = <span class="keyword">new</span> <span class="keywordtype">double</span>[condensedSize];</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; condensedSize; ++i) distMatrix[i] = <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a> * <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>;</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="comment">// TODO: maybe use machine epsilon?</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        <span class="comment">// For reducing distance due to extra occurrences.</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="comment">// Can differentiate ~9999 occurrences.</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        <span class="keywordtype">double</span> occurrenceEpsilon = 0.0001;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::pair&lt;const PointsTo *, unsigned&gt; &amp;ptsOcc : pointsToSets)</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        {</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;            <span class="keyword">const</span> PointsTo *pts = ptsOcc.first;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;            <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(pts != <span class="keyword">nullptr</span>);</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;            <span class="keyword">const</span> <span class="keywordtype">unsigned</span> occ = ptsOcc.second;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;            <span class="comment">// Distance between each element of pts.</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;            <span class="keywordtype">unsigned</span> distance = <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">requiredBits</a>(*pts) / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;            <span class="comment">// Use a vector so we can index into pts.</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;            std::vector&lt;NodeID&gt; ptsVec;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;            <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : *pts) ptsVec.push_back(o);</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; ptsVec.size(); ++i)</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            {</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> oi = ptsVec[i];</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;                <span class="keyword">const</span> Map&lt;NodeID, unsigned&gt;::const_iterator moi = nodeMap.find(oi);</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;                <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(moi != nodeMap.end());</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> j = i + 1; j &lt; ptsVec.size(); ++j)</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;                {</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;                    <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> oj = ptsVec[j];</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                    <span class="keyword">const</span> Map&lt;NodeID, unsigned&gt;::const_iterator moj = nodeMap.find(oj);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;                    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(moj != nodeMap.end());</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;                    <span class="keywordtype">double</span> &amp;existingDistance = distMatrix[<a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac8c209af1d177cbc8fbbfe4526fe8ce2">condensedIndex</a>(<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, moi-&gt;second, moj-&gt;second)];</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;                    <span class="comment">// Subtract extra occurrenceEpsilon to make upcoming logic simpler.</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;                    <span class="comment">// When existingDistance is never whole, it is always between two distances.</span></div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;                    <span class="keywordflow">if</span> (distance &lt; existingDistance) existingDistance = distance - occurrenceEpsilon;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;                    <span class="keywordflow">if</span> (distance == std::ceil(existingDistance))</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;                    {</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;                        <span class="comment">// We have something like distance == x, existingDistance == x - e, for some e &lt; 1</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;                        <span class="comment">// (potentially even set during this iteration).</span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;                        <span class="comment">// So, the new distance is an occurrence the existingDistance being tracked, it just</span></div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;                        <span class="comment">// had some reductions because of multiple occurences.</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;                        <span class="comment">// If there is not room within this distance to reduce more (increase priority),</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;                        <span class="comment">// just ignore it. TODO: maybe warn?</span></div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;                        <span class="keywordflow">if</span> (existingDistance - occ * occurrenceEpsilon &gt; std::floor(existingDistance))</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                        {</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;                            existingDistance -= occ * occurrenceEpsilon;</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;                        }</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;                        <span class="keywordflow">else</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;                        {</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;                            <span class="comment">// Reached minimum.</span></div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;                            existingDistance = std::floor(existingDistance) + occurrenceEpsilon;</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;                        }</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;                    }</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;                }</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;            }</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        }</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">double</span> clkEnd = <a class="code" href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">PTAStat::getClk</a>(<span class="keyword">true</span>);</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        distanceMatrixTime += (clkEnd - clkStart) / <a class="code" href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a>;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;        <span class="keywordflow">return</span> distMatrix;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    }</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00018">MTAResultValidator.h:18</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a9aea96839c51ac1e2cbf4813174bb21c"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">SVF::NodeIDAllocator::Clusterer::requiredBits</a></div><div class="ttdeci">static unsigned requiredBits(const PointsTo &amp;pts)</div><div class="ttdoc">Returns the minimum number of bits required to represent pts in a perfect world. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00405">NodeIDAllocator.cpp:405</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_html_a190c729a3f3f622f82cee4917946b50f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">SVF::NodeIDAllocator::numObjects</a></div><div class="ttdeci">NodeID numObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00084">NodeIDAllocator.h:84</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_a1aeda3370621dc00e9a0fe8e7aabc736"><div class="ttname"><a href="SVFBasicTypes_8h.html#a1aeda3370621dc00e9a0fe8e7aabc736">TIMEINTERVAL</a></div><div class="ttdeci">#define TIMEINTERVAL</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00174">SVFBasicTypes.h:174</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ac8c209af1d177cbc8fbbfe4526fe8ce2"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac8c209af1d177cbc8fbbfe4526fe8ce2">SVF::NodeIDAllocator::Clusterer::condensedIndex</a></div><div class="ttdeci">static size_t condensedIndex(size_t n, size_t i, size_t j)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00399">NodeIDAllocator.cpp:399</a></div></div>
<div class="ttc" id="SVFBasicTypes_8h_html_ab8ca0fd9d0caa6817d305cae0f1cf022"><div class="ttname"><a href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a></div><div class="ttdeci">#define NATIVE_INT_SIZE</div><div class="ttdoc">Size of native integer that we&amp;#39;ll use for bit vectors, in bits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00178">SVFBasicTypes.h:178</a></div></div>
<div class="ttc" id="classSVF_1_1PTAStat_html_a3c4eaa1695ea13405911ae1621f98edc"><div class="ttname"><a href="classSVF_1_1PTAStat.html#a3c4eaa1695ea13405911ae1621f98edc">SVF::PTAStat::getClk</a></div><div class="ttdeci">static double getClk(bool mark=false)</div><div class="ttdef"><b>Definition:</b> <a href="PTAStat_8cpp_source.html#l00114">PTAStat.cpp:114</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36b25188130f4c21d145c950a70d616f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b25188130f4c21d145c950a70d616f">&#9670;&nbsp;</a></span>getReverseNodeMapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; SVF::NodeIDAllocator::Clusterer::getReverseNodeMapping </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeMapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00385">385</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    {</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        <span class="comment">// nodeMapping.size() may not be big enough because we leave some gaps, but it&#39;s a start.</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;        std::vector&lt;NodeID&gt; reverseNodeMapping(nodeMapping.size(), UINT_MAX);</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; nodeMapping.size(); ++i)</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;        {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> mapsTo = nodeMapping.at(i);</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;            <span class="keywordflow">if</span> (mapsTo &gt;= reverseNodeMapping.size()) reverseNodeMapping.resize(mapsTo + 1, UINT_MAX);</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;            reverseNodeMapping.at(mapsTo) = i;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;        }</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;        <span class="keywordflow">return</span> reverseNodeMapping;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;    }</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00018">MTAResultValidator.h:18</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac10cbda6a84ce890c9946a5ff35800b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac10cbda6a84ce890c9946a5ff35800b7">&#9670;&nbsp;</a></span>printStats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::NodeIDAllocator::Clusterer::printStats </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; std::string, std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints statistics to <a class="el" href="namespaceSVF_1_1SVFUtil.html#a85ab6b592fefc45a0674d3295e01638f" title="Overwrite llvm::outs() ">SVFUtil::outs()</a>. TODO: make stats const. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00678">678</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    {</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;        <span class="comment">// When not in order, it is too hard to compare original/new SBV/BV words, so this array forces an order.</span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;        <span class="keyword">const</span> <span class="keyword">static</span> std::array&lt;std::string, 17&gt; statKeys =</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;            { <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afa74c5ccd22bebe0b76db33066d8b498">NumObjects</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a2a70b98363303cb33d96732f44b4c5c3">TheoreticalNumWords</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a639b887e30115c2a6cd108c65f18fcc1">OriginalSbvNumWords</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af2786eae11ee13845da336ad23bc97e9">OriginalBvNumWords</a>,</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;              <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">NewSbvNumWords</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">NewBvNumWords</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac5fe44f10cdbca9754444943a0f5c3c1">NumRegions</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad7cb36a1f0f67864fb8290e9dfd7b639">NumGtIntRegions</a>,</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;              <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1bf9461c717e8dabaee6a57f3d76d61f">NumNonTrivialRegionObjects</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a172d72ae4ae45fa2baf2f20ff2b499dc">LargestRegion</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad5f733cad8a103a64e80270acb67567a">RegioningTime</a>,</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;              <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a09d2dbb2faab0a0e03bfa353534116a8">DistanceMatrixTime</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ae78d2b60035350c634f6f58d7a043c22">FastClusterTime</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a67ab9cffacc1584b2e7bae5d1b08c541">DendrogramTraversalTime</a>,</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;              <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1d98862e19affdd08740f85490d0d856">EvalTime</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afef85f0ecacd681357b3945f97d52964">TotalTime</a>, <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3556bdda6725b72d0ca88364daeae32e">BestCandidate</a> };</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> fieldWidth = 20;</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;        std::cout.flags(std::ios::left);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;        std::cout &lt;&lt; <span class="stringliteral">&quot;****Clusterer Statistics: &quot;</span> &lt;&lt; subtitle &lt;&lt; <span class="stringliteral">&quot;****\n&quot;</span>;</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> std::string &amp;statKey : statKeys)</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;        {</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;            Map&lt;std::string, std::string&gt;::const_iterator stat = stats.find(statKey);</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;            <span class="keywordflow">if</span> (stat != stats.end())</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;            {</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                std::cout &lt;&lt; std::setw(fieldWidth) &lt;&lt; statKey &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; stat-&gt;second &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;            }</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;        }</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        std::cout.flush();</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;    }</div><div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ad7cb36a1f0f67864fb8290e9dfd7b639"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad7cb36a1f0f67864fb8290e9dfd7b639">SVF::NodeIDAllocator::Clusterer::NumGtIntRegions</a></div><div class="ttdeci">static const std::string NumGtIntRegions</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00124">NodeIDAllocator.h:124</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a67ab9cffacc1584b2e7bae5d1b08c541"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a67ab9cffacc1584b2e7bae5d1b08c541">SVF::NodeIDAllocator::Clusterer::DendrogramTraversalTime</a></div><div class="ttdeci">static const std::string DendrogramTraversalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00115">NodeIDAllocator.h:115</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_af2786eae11ee13845da336ad23bc97e9"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af2786eae11ee13845da336ad23bc97e9">SVF::NodeIDAllocator::Clusterer::OriginalBvNumWords</a></div><div class="ttdeci">static const std::string OriginalBvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00119">NodeIDAllocator.h:119</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a779446e2fe92518401f1732fb809f066"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a779446e2fe92518401f1732fb809f066">SVF::NodeIDAllocator::Clusterer::NewSbvNumWords</a></div><div class="ttdeci">static const std::string NewSbvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00122">NodeIDAllocator.h:122</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_afa74c5ccd22bebe0b76db33066d8b498"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afa74c5ccd22bebe0b76db33066d8b498">SVF::NodeIDAllocator::Clusterer::NumObjects</a></div><div class="ttdeci">static const std::string NumObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00111">NodeIDAllocator.h:111</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a2a70b98363303cb33d96732f44b4c5c3"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a2a70b98363303cb33d96732f44b4c5c3">SVF::NodeIDAllocator::Clusterer::TheoreticalNumWords</a></div><div class="ttdeci">static const std::string TheoreticalNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00118">NodeIDAllocator.h:118</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ad5f733cad8a103a64e80270acb67567a"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ad5f733cad8a103a64e80270acb67567a">SVF::NodeIDAllocator::Clusterer::RegioningTime</a></div><div class="ttdeci">static const std::string RegioningTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00112">NodeIDAllocator.h:112</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ae78d2b60035350c634f6f58d7a043c22"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ae78d2b60035350c634f6f58d7a043c22">SVF::NodeIDAllocator::Clusterer::FastClusterTime</a></div><div class="ttdeci">static const std::string FastClusterTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00114">NodeIDAllocator.h:114</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a639b887e30115c2a6cd108c65f18fcc1"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a639b887e30115c2a6cd108c65f18fcc1">SVF::NodeIDAllocator::Clusterer::OriginalSbvNumWords</a></div><div class="ttdeci">static const std::string OriginalSbvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00120">NodeIDAllocator.h:120</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a3556bdda6725b72d0ca88364daeae32e"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a3556bdda6725b72d0ca88364daeae32e">SVF::NodeIDAllocator::Clusterer::BestCandidate</a></div><div class="ttdeci">static const std::string BestCandidate</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00126">NodeIDAllocator.h:126</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a172d72ae4ae45fa2baf2f20ff2b499dc"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a172d72ae4ae45fa2baf2f20ff2b499dc">SVF::NodeIDAllocator::Clusterer::LargestRegion</a></div><div class="ttdeci">static const std::string LargestRegion</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00125">NodeIDAllocator.h:125</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a09d2dbb2faab0a0e03bfa353534116a8"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a09d2dbb2faab0a0e03bfa353534116a8">SVF::NodeIDAllocator::Clusterer::DistanceMatrixTime</a></div><div class="ttdeci">static const std::string DistanceMatrixTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00113">NodeIDAllocator.h:113</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_afef85f0ecacd681357b3945f97d52964"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#afef85f0ecacd681357b3945f97d52964">SVF::NodeIDAllocator::Clusterer::TotalTime</a></div><div class="ttdeci">static const std::string TotalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00117">NodeIDAllocator.h:117</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a1d98862e19affdd08740f85490d0d856"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1d98862e19affdd08740f85490d0d856">SVF::NodeIDAllocator::Clusterer::EvalTime</a></div><div class="ttdeci">static const std::string EvalTime</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00116">NodeIDAllocator.h:116</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a1bf9461c717e8dabaee6a57f3d76d61f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a1bf9461c717e8dabaee6a57f3d76d61f">SVF::NodeIDAllocator::Clusterer::NumNonTrivialRegionObjects</a></div><div class="ttdeci">static const std::string NumNonTrivialRegionObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00127">NodeIDAllocator.h:127</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_af3fe4b4098898ee38928c9db30ea0fe9"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#af3fe4b4098898ee38928c9db30ea0fe9">SVF::NodeIDAllocator::Clusterer::NewBvNumWords</a></div><div class="ttdeci">static const std::string NewBvNumWords</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00121">NodeIDAllocator.h:121</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_ac5fe44f10cdbca9754444943a0f5c3c1"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#ac5fe44f10cdbca9754444943a0f5c3c1">SVF::NodeIDAllocator::Clusterer::NumRegions</a></div><div class="ttdeci">static const std::string NumRegions</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00123">NodeIDAllocator.h:123</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d34542f34a8e8008119c3d61943daa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d34542f34a8e8008119c3d61943daa2">&#9670;&nbsp;</a></span>regionObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; SVF::NodeIDAllocator::Clusterer::regionObjects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, <a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numLabels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector mapping object IDs to a label such that if two objects appear in the same points-to set, they have the same label. The "appear in the same
points-to set" is encoded by graph which is an adjacency list ensuring that x in pt(p) and y in pt(p) -&gt; x is reachable from y. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00520">520</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    {</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        <span class="keywordtype">unsigned</span> label = UINT_MAX;</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        std::vector&lt;NodeID&gt; labels(<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, UINT_MAX);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;        Set&lt;NodeID&gt; labelled;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt;<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a>, Set&lt;NodeID&gt;&gt;::value_type &amp;oos : graph)</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        {</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;            <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o = oos.first;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;            <span class="keywordflow">if</span> (labels[o] != UINT_MAX) <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;            std::queue&lt;NodeID&gt; bfsQueue;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;            bfsQueue.push(o);</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;            ++label;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;            <span class="keywordflow">while</span> (!bfsQueue.empty())</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;            {</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                <span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o = bfsQueue.front();</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                bfsQueue.pop();</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                <span class="keywordflow">if</span> (labels[o] != UINT_MAX)</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                {</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                    <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(labels[o] == label);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;                    <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;                }</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;                labels[o] = label;</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;                Map&lt;NodeID, Set&lt;NodeID&gt;&gt;::const_iterator neighboursIt = graph.find(o);</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;                <a class="code" href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a>(neighboursIt != graph.end());</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;                <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> neighbour : neighboursIt-&gt;second) bfsQueue.push(neighbour);</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;            }</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;        }</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;        <span class="comment">// The remaining objects have no relation with others: they get their own label.</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> o = 0; o &lt; <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>; ++o)</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;        {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;            <span class="keywordflow">if</span> (labels[o] == UINT_MAX) labels[o] = ++label;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        }</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;        numLabels = label + 1;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;        <span class="keywordflow">return</span> labels;</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;    }</div><div class="ttc" id="namespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">unsigned NodeID</div><div class="ttdef"><b>Definition:</b> <a href="MTAResultValidator_8h_source.html#l00018">MTAResultValidator.h:18</a></div></div>
<div class="ttc" id="util_8h_html_a07d17d6d5d1074c0969bc5d3c3d1d84a"><div class="ttname"><a href="util_8h.html#a07d17d6d5d1074c0969bc5d3c3d1d84a">assert</a></div><div class="ttdeci">#define assert(ex)</div><div class="ttdef"><b>Definition:</b> <a href="util_8h_source.html#l00141">util.h:141</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_html_a190c729a3f3f622f82cee4917946b50f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">SVF::NodeIDAllocator::numObjects</a></div><div class="ttdeci">NodeID numObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00084">NodeIDAllocator.h:84</a></div></div>
<div class="ttc" id="namespaceSVF_html_a8234d4b959abc9123993bcff4eee34c1"><div class="ttname"><a href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">SVF::Map</a></div><div class="ttdeci">std::unordered_map&lt; Key, Value, Hash, KeyEqual, Allocator &gt; Map</div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00100">SVFBasicTypes.h:100</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9aea96839c51ac1e2cbf4813174bb21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aea96839c51ac1e2cbf4813174bb21c">&#9670;&nbsp;</a></span>requiredBits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SVF::NodeIDAllocator::Clusterer::requiredBits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of bits required to represent pts in a perfect world. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00405">405</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    {</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">requiredBits</a>(pts.count());</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    }</div><div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_a9aea96839c51ac1e2cbf4813174bb21c"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#a9aea96839c51ac1e2cbf4813174bb21c">SVF::NodeIDAllocator::Clusterer::requiredBits</a></div><div class="ttdeci">static unsigned requiredBits(const PointsTo &amp;pts)</div><div class="ttdoc">Returns the minimum number of bits required to represent pts in a perfect world. </div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00405">NodeIDAllocator.cpp:405</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0f0a6b61a044db819c253f8b9ab093e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f0a6b61a044db819c253f8b9ab093e">&#9670;&nbsp;</a></span>requiredBits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned SVF::NodeIDAllocator::Clusterer::requiredBits </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of bits required to represent n items in a perfect world. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00410">410</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    {</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;        <span class="keywordflow">if</span> (n == 0) <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="comment">// Ceiling of number of bits amongst each native integer gives needed native ints,</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        <span class="comment">// so we then multiply again by the number of bits in each native int.</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="keywordflow">return</span> ((n - 1) / <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a> + 1) * <a class="code" href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a>;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;    }</div><div class="ttc" id="SVFBasicTypes_8h_html_ab8ca0fd9d0caa6817d305cae0f1cf022"><div class="ttname"><a href="SVFBasicTypes_8h.html#ab8ca0fd9d0caa6817d305cae0f1cf022">NATIVE_INT_SIZE</a></div><div class="ttdeci">#define NATIVE_INT_SIZE</div><div class="ttdoc">Size of native integer that we&amp;#39;ll use for bit vectors, in bits. </div><div class="ttdef"><b>Definition:</b> <a href="SVFBasicTypes_8h_source.html#l00178">SVFBasicTypes.h:178</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abd44e3b07b0482bacf6b1a080fe650c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd44e3b07b0482bacf6b1a080fe650c6">&#9670;&nbsp;</a></span>traverseDendrogram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::NodeIDAllocator::Clusterer::traverseDendrogram </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>dendrogram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>numObjects</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>allocCounter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#af739db846e47ba6b2fd15eaad31ab7fb">Set</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>visited</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regionNodeMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Traverses the dendrogram produced by fastcluster, making node o, where o is the nth leaf (per recursive DFS) map to n. index is the dendrogram node to work off. The traversal should start at the top, which is the "last" (consider that it is 2D) element of the dendrogram, numObjects - 1. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8cpp_source.html#l00489">489</a> of file <a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;    {</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordflow">if</span> (visited.find(index) != visited.end()) <span class="keywordflow">return</span>;</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;        visited.insert(index);</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;        <span class="keywordtype">int</span> left = dendrogram[index - 1];</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;        <span class="keywordflow">if</span> (left &lt; 0)</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        {</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            <span class="comment">// Reached a leaf.</span></div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;            <span class="comment">// -1 because the items start from 1 per fastcluster (TODO).</span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            nodeMap[regionNodeMap[std::abs(left) - 1]] = allocCounter;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            ++allocCounter;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;        }</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;        {</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;            <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">traverseDendrogram</a>(nodeMap, dendrogram, <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, allocCounter, visited, left, regionNodeMap);</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        }</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <span class="comment">// Repeat for the right child.</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <span class="keywordtype">int</span> right = dendrogram[(<a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a> - 1) + index - 1];</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;        <span class="keywordflow">if</span> (right &lt; 0)</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;        {</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            nodeMap[regionNodeMap[std::abs(right) - 1]] = allocCounter;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            ++allocCounter;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;        }</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;        <span class="keywordflow">else</span></div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        {</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;            <a class="code" href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">traverseDendrogram</a>(nodeMap, dendrogram, <a class="code" href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">numObjects</a>, allocCounter, visited, right, regionNodeMap);</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;        }</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;    }</div><div class="ttc" id="classSVF_1_1NodeIDAllocator_html_a190c729a3f3f622f82cee4917946b50f"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator.html#a190c729a3f3f622f82cee4917946b50f">SVF::NodeIDAllocator::numObjects</a></div><div class="ttdeci">NodeID numObjects</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8h_source.html#l00084">NodeIDAllocator.h:84</a></div></div>
<div class="ttc" id="classSVF_1_1NodeIDAllocator_1_1Clusterer_html_abd44e3b07b0482bacf6b1a080fe650c6"><div class="ttname"><a href="classSVF_1_1NodeIDAllocator_1_1Clusterer.html#abd44e3b07b0482bacf6b1a080fe650c6">SVF::NodeIDAllocator::Clusterer::traverseDendrogram</a></div><div class="ttdeci">static void traverseDendrogram(std::vector&lt; NodeID &gt; &amp;nodeMap, const int *dendrogram, const size_t numObjects, unsigned &amp;allocCounter, Set&lt; int &gt; &amp;visited, const int index, const std::vector&lt; NodeID &gt; &amp;regionNodeMap)</div><div class="ttdef"><b>Definition:</b> <a href="NodeIDAllocator_8cpp_source.html#l00489">NodeIDAllocator.cpp:489</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3556bdda6725b72d0ca88364daeae32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3556bdda6725b72d0ca88364daeae32e">&#9670;&nbsp;</a></span>BestCandidate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::BestCandidate = &quot;BestCandidate&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00126">126</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a67ab9cffacc1584b2e7bae5d1b08c541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ab9cffacc1584b2e7bae5d1b08c541">&#9670;&nbsp;</a></span>DendrogramTraversalTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::DendrogramTraversalTime = &quot;DendrogramTravTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00115">115</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a09d2dbb2faab0a0e03bfa353534116a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d2dbb2faab0a0e03bfa353534116a8">&#9670;&nbsp;</a></span>DistanceMatrixTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::DistanceMatrixTime = &quot;DistanceMatrixTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00113">113</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a1d98862e19affdd08740f85490d0d856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d98862e19affdd08740f85490d0d856">&#9670;&nbsp;</a></span>EvalTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::EvalTime = &quot;EvalTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00116">116</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="ae78d2b60035350c634f6f58d7a043c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae78d2b60035350c634f6f58d7a043c22">&#9670;&nbsp;</a></span>FastClusterTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::FastClusterTime = &quot;FastClusterTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00114">114</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a172d72ae4ae45fa2baf2f20ff2b499dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172d72ae4ae45fa2baf2f20ff2b499dc">&#9670;&nbsp;</a></span>LargestRegion</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::LargestRegion = &quot;LargestRegion&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00125">125</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="af3fe4b4098898ee38928c9db30ea0fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fe4b4098898ee38928c9db30ea0fe9">&#9670;&nbsp;</a></span>NewBvNumWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NewBvNumWords = &quot;NewBvWords&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00121">121</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a779446e2fe92518401f1732fb809f066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a779446e2fe92518401f1732fb809f066">&#9670;&nbsp;</a></span>NewSbvNumWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NewSbvNumWords = &quot;NewSbvWords&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00122">122</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="ad7cb36a1f0f67864fb8290e9dfd7b639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7cb36a1f0f67864fb8290e9dfd7b639">&#9670;&nbsp;</a></span>NumGtIntRegions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NumGtIntRegions = &quot;NumGtIntRegions&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00124">124</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a1bf9461c717e8dabaee6a57f3d76d61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf9461c717e8dabaee6a57f3d76d61f">&#9670;&nbsp;</a></span>NumNonTrivialRegionObjects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NumNonTrivialRegionObjects = &quot;NumNonTrivObj&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00127">127</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="afa74c5ccd22bebe0b76db33066d8b498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa74c5ccd22bebe0b76db33066d8b498">&#9670;&nbsp;</a></span>NumObjects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NumObjects = &quot;NumObjects&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Statistics strings. </p>

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00111">111</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="ac5fe44f10cdbca9754444943a0f5c3c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fe44f10cdbca9754444943a0f5c3c1">&#9670;&nbsp;</a></span>NumRegions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::NumRegions = &quot;NumRegions&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00123">123</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="af2786eae11ee13845da336ad23bc97e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2786eae11ee13845da336ad23bc97e9">&#9670;&nbsp;</a></span>OriginalBvNumWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::OriginalBvNumWords = &quot;OriginalBvWords&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00119">119</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a639b887e30115c2a6cd108c65f18fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639b887e30115c2a6cd108c65f18fcc1">&#9670;&nbsp;</a></span>OriginalSbvNumWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::OriginalSbvNumWords = &quot;OriginalSbvWords&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00120">120</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="ad5f733cad8a103a64e80270acb67567a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f733cad8a103a64e80270acb67567a">&#9670;&nbsp;</a></span>RegioningTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::RegioningTime = &quot;RegioningTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00112">112</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="a2a70b98363303cb33d96732f44b4c5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a70b98363303cb33d96732f44b4c5c3">&#9670;&nbsp;</a></span>TheoreticalNumWords</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::TheoreticalNumWords = &quot;TheoreticalWords&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00118">118</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<a id="afef85f0ecacd681357b3945f97d52964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef85f0ecacd681357b3945f97d52964">&#9670;&nbsp;</a></span>TotalTime</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string SVF::NodeIDAllocator::Clusterer::TotalTime = &quot;TotalTime&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NodeIDAllocator_8h_source.html#l00117">117</a> of file <a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/SVF/SVF/include/Util/<a class="el" href="NodeIDAllocator_8h_source.html">NodeIDAllocator.h</a></li>
<li>/home/runner/work/SVF/SVF/lib/Util/<a class="el" href="NodeIDAllocator_8cpp_source.html">NodeIDAllocator.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
