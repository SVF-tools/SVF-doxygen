<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::SVFUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVFUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">SVF::SVFUtil Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__const__past__pointer.html">add_const_past_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__const__past__pointer_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is_7fffc8df953a67082a10c9027356ecdf.html">add_const_past_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer, just return it. If it is not, return T&amp;.  <a href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer_3_01T_00_01std_1_1enable__if__t915410d772a4855ec3d21a633a25ee09.html">add_lvalue_reference_if_not_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_convert_val&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl.html">cast_retty_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5_01_4.html">cast_retty_impl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5const_01_4.html">cast_retty_impl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_4.html">cast_retty_impl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01From_01_5_01_4.html">cast_retty_impl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">cast_retty_impl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap.html">cast_retty_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_retty_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that checks if a type is iterable (can be applied on a range-based for loop)  <a href="structSVF_1_1SVFUtil_1_1is__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable_3_01T_00_01void__t_3_01decltype_07std_1_1begin_07std_1_1dec794949348c8e1e00603fd8633b6dd1f3.html">is_iterable&lt; T, void_t&lt; decltype(std::begin(std::declval&lt; T &amp; &gt;()) !=std::end(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a map or unordered_map.  <a href="structSVF_1_1SVFUtil_1_1is__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1map_3_01Ts_8_8_8_01_4_01_4.html">is_map&lt; std::map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1unordered__map_3_01Ts_8_8_8_01_4_01_4.html">is_map&lt; std::unordered_map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is vector or list.  <a href="structSVF_1_1SVFUtil_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1deque_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::deque&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1list_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1vector_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::vector&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a set or unordered_set.  <a href="structSVF_1_1SVFUtil_1_1is__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1set_3_01Ts_8_8_8_01_4_01_4.html">is_set&lt; std::set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1unordered__set_3_01Ts_8_8_8_01_4_01_4.html">is_set&lt; std::unordered_set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl.html">isa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__baseacbe8554d65d479d86c5b7d994311309.html">isa_impl&lt; To, From, std::enable_if_t&lt; std::is_base_of&lt; To, From &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allow upcasts, and perform no dynamic check for them.  <a href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__baseacbe8554d65d479d86c5b7d994311309.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl.html">isa_impl_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5_01_4.html">isa_impl_cl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5const_01_4.html">isa_impl_cl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_4.html">isa_impl_cl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html">isa_impl_cl&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5_01_4.html">isa_impl_cl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5const_01_4.html">isa_impl_cl&lt; To, From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">isa_impl_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">isa_impl_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">void_t is not available until C++17. We define it here for C++11/14.  <a href="structSVF_1_1SVFUtil_1_1make__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type.html">simplify_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type_3_01const_01From_01_4.html">simplify_type&lt; const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac047d963ed4b701c83958868ab36202f" id="r_ac047d963ed4b701c83958868ab36202f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">struct</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac047d963ed4b701c83958868ab36202f">equalPointsTo</a></td></tr>
<tr class="separator:ac047d963ed4b701c83958868ab36202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66b86171786cc34b798f05f67f321e" id="r_acb66b86171786cc34b798f05f67f321e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">struct</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acb66b86171786cc34b798f05f67f321e">equalNodeBS</a></td></tr>
<tr class="separator:acb66b86171786cc34b798f05f67f321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2" id="r_a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737" id="r_a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c8cbc986cccb9d84f87aae162df3737">isa</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a5c8cbc986cccb9d84f87aae162df3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13729076054a2977670b05a338a6763d" id="r_a13729076054a2977670b05a338a6763d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">First</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Second</a> , typename... Rest, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a13729076054a2977670b05a338a6763d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a13729076054a2977670b05a338a6763d">isa</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a13729076054a2977670b05a338a6763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac2d264d80b8bfdbeaf120c5d6778d0" id="r_a5ac2d264d80b8bfdbeaf120c5d6778d0"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a5ac2d264d80b8bfdbeaf120c5d6778d0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::value, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5ac2d264d80b8bfdbeaf120c5d6778d0">cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a5ac2d264d80b8bfdbeaf120c5d6778d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fad7cd816cf65f5909aaaec37808018" id="r_a3fad7cd816cf65f5909aaaec37808018"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a3fad7cd816cf65f5909aaaec37808018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3fad7cd816cf65f5909aaaec37808018">cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a3fad7cd816cf65f5909aaaec37808018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74798437de126220947080e9fed0e90c" id="r_a74798437de126220947080e9fed0e90c"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a74798437de126220947080e9fed0e90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a74798437de126220947080e9fed0e90c">cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a74798437de126220947080e9fed0e90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c81ab179a570e6a4f16dbc776cad360" id="r_a3c81ab179a570e6a4f16dbc776cad360"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a3c81ab179a570e6a4f16dbc776cad360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, std::unique_ptr&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3c81ab179a570e6a4f16dbc776cad360">cast</a> (std::unique_ptr&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; &amp;&amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a3c81ab179a570e6a4f16dbc776cad360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefeaa1d67563fbf00b9f06a848072df1" id="r_aefeaa1d67563fbf00b9f06a848072df1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:aefeaa1d67563fbf00b9f06a848072df1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::value, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aefeaa1d67563fbf00b9f06a848072df1">dyn_cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:aefeaa1d67563fbf00b9f06a848072df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b51d4b9abc2b53e9c5f20615a48a6fc" id="r_a4b51d4b9abc2b53e9c5f20615a48a6fc"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a4b51d4b9abc2b53e9c5f20615a48a6fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4b51d4b9abc2b53e9c5f20615a48a6fc">dyn_cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a4b51d4b9abc2b53e9c5f20615a48a6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc262ae3f77bf173e5a1dab52a76512" id="r_a6cc262ae3f77bf173e5a1dab52a76512"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </td></tr>
<tr class="memitem:a6cc262ae3f77bf173e5a1dab52a76512"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cc262ae3f77bf173e5a1dab52a76512">dyn_cast</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>)</td></tr>
<tr class="separator:a6cc262ae3f77bf173e5a1dab52a76512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b432d1a6e3f8ddd7a3505f7b7a8cd3" id="r_ad8b432d1a6e3f8ddd7a3505f7b7a8cd3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a> ()</td></tr>
<tr class="memdesc:ad8b432d1a6e3f8ddd7a3505f7b7a8cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite llvm::outs()  <br /></td></tr>
<tr class="separator:ad8b432d1a6e3f8ddd7a3505f7b7a8cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f76b6289e99c6660a34475c4b66074" id="r_aa4f76b6289e99c6660a34475c4b66074"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa4f76b6289e99c6660a34475c4b66074">errs</a> ()</td></tr>
<tr class="memdesc:aa4f76b6289e99c6660a34475c4b66074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite llvm::errs()  <br /></td></tr>
<tr class="separator:aa4f76b6289e99c6660a34475c4b66074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab" id="r_aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a> (<a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">To</a>, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1" id="r_a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">To</a>, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3" id="r_abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">dumpPointsToSet</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">To</a>)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442" id="r_ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">dumpSparseSet</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">To</a>)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61" id="r_a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">dumpAliasSet</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">To</a>)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc00b2bd9a8176aae31b6cfffe725d" id="r_a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a05dc00b2bd9a8176aae31b6cfffe725d">sucMsg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="memdesc:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <br /></td></tr>
<tr class="separator:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71522e8c55f84cfc6c13a0ddff18436" id="r_ac71522e8c55f84cfc6c13a0ddff18436"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">wrnMsg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="memdesc:ac71522e8c55f84cfc6c13a0ddff18436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <br /></td></tr>
<tr class="separator:ac71522e8c55f84cfc6c13a0ddff18436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e0196e0ce547ab4a483cc6d2646b24" id="r_ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">writeWrnMsg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="memdesc:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <br /></td></tr>
<tr class="separator:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7655b13bbfe720ca2b8a25e0a72528e6" id="r_a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7655b13bbfe720ca2b8a25e0a72528e6">errMsg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="memdesc:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <br /></td></tr>
<tr class="separator:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10504db25b86bc7f74aebb9c54f04cb3" id="r_a10504db25b86bc7f74aebb9c54f04cb3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a10504db25b86bc7f74aebb9c54f04cb3">bugMsg1</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="separator:a10504db25b86bc7f74aebb9c54f04cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f6dfcc9118ffd80244a771bdee535" id="r_ac25f6dfcc9118ffd80244a771bdee535"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac25f6dfcc9118ffd80244a771bdee535">bugMsg2</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="separator:ac25f6dfcc9118ffd80244a771bdee535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76909ad87f59eb9a9cfd1913e13da264" id="r_a76909ad87f59eb9a9cfd1913e13da264"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a76909ad87f59eb9a9cfd1913e13da264">bugMsg3</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="separator:a76909ad87f59eb9a9cfd1913e13da264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550f2fb815882edfb666ac818792064" id="r_a4550f2fb815882edfb666ac818792064"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4550f2fb815882edfb666ac818792064">pasMsg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>)</td></tr>
<tr class="memdesc:a4550f2fb815882edfb666ac818792064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <br /></td></tr>
<tr class="separator:a4550f2fb815882edfb666ac818792064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3" id="r_a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">reportMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">infor</a>, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c" id="r_a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmrss_kb</a>, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmsize_kb</a>)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1" id="r_a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3" id="r_aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">cmpPts</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5" id="r_a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">cmpNodeBS</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642" id="r_a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">ptsToNodeBS</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pts</a>)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810" id="r_af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">dumpPointsToList</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptl</a>)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2b3538ed321e5fa17b98e01c9175fc" id="r_a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">isIntrinsicInst</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="memdesc:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an llvm intrinsic instruction.  <br /></td></tr>
<tr class="separator:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f286ff865a778dc2af5410ed9b24e" id="r_ac69f286ff865a778dc2af5410ed9b24e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">isCallSite</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="separator:ac69f286ff865a778dc2af5410ed9b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd7753901074b660eda3166180a356" id="r_ad4bd7753901074b660eda3166180a356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad4bd7753901074b660eda3166180a356">isRetInstNode</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:ad4bd7753901074b660eda3166180a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b337f84cae7ae0ec4597b077aee08c" id="r_a86b337f84cae7ae0ec4597b077aee08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86b337f84cae7ae0ec4597b077aee08c">isNonInstricCallSite</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="memdesc:a86b337f84cae7ae0ec4597b077aee08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <br /></td></tr>
<tr class="separator:a86b337f84cae7ae0ec4597b077aee08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae911c0261d0a35cbae8a3cce294ba10" id="r_aae911c0261d0a35cbae8a3cce294ba10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aae911c0261d0a35cbae8a3cce294ba10">matchArgs</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callee</a>)</td></tr>
<tr class="separator:aae911c0261d0a35cbae8a3cce294ba10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c71fedd13e67b220b669c1697684e3" id="r_af3c71fedd13e67b220b669c1697684e3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3c71fedd13e67b220b669c1697684e3">split</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">s</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">char</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">separator</a>)</td></tr>
<tr class="memdesc:af3c71fedd13e67b220b669c1697684e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <br /></td></tr>
<tr class="separator:af3c71fedd13e67b220b669c1697684e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2" id="r_a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a> &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">mergePtsOccMaps</a> (<a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> &gt; &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">to</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> &gt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">from</a>)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160" id="r_a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">method</a>)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7" id="r_aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">insertKey</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471" id="r_a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">insertKey</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9" id="r_aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">removeKey</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">erase</a>).  <br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e" id="r_aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">removeKey</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9" id="r_add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">int</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">signum</a>)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70" id="r_a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">startAnalysisLimitTimer</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">timeLimit</a>)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5" id="r_a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">stopAnalysisLimitTimer</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">limitTimerSet</a>)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b83d34488eaa1d6613568dd8394bdd" id="r_aa6b83d34488eaa1d6613568dd8394bdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa6b83d34488eaa1d6613568dd8394bdd">isExtCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="separator:aa6b83d34488eaa1d6613568dd8394bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3e7c8b2fead4dfccfae74207e3fac5" id="r_a3e3e7c8b2fead4dfccfae74207e3fac5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3e3e7c8b2fead4dfccfae74207e3fac5">isHeapAllocExtFunViaRet</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="memdesc:a3e3e7c8b2fead4dfccfae74207e3fac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <br /></td></tr>
<tr class="separator:a3e3e7c8b2fead4dfccfae74207e3fac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a9663da66e3a2226058e57356d3d8f" id="r_a58a9663da66e3a2226058e57356d3d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a58a9663da66e3a2226058e57356d3d8f">isHeapAllocExtFunViaArg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="separator:a58a9663da66e3a2226058e57356d3d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222ecd1c0c7fdf21d680b1605370392c" id="r_a222ecd1c0c7fdf21d680b1605370392c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a222ecd1c0c7fdf21d680b1605370392c">getHeapAllocHoldingArgPosition</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="memdesc:a222ecd1c0c7fdf21d680b1605370392c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <br /></td></tr>
<tr class="separator:a222ecd1c0c7fdf21d680b1605370392c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecc9c27333b0e7ed3e222207dc735b4" id="r_acecc9c27333b0e7ed3e222207dc735b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acecc9c27333b0e7ed3e222207dc735b4">isReallocExtFun</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="memdesc:acecc9c27333b0e7ed3e222207dc735b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <br /></td></tr>
<tr class="separator:acecc9c27333b0e7ed3e222207dc735b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1071e5fd17b686b62d37f11a848d731c" id="r_a1071e5fd17b686b62d37f11a848d731c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1071e5fd17b686b62d37f11a848d731c">isProgEntryFunction</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *)</td></tr>
<tr class="memdesc:a1071e5fd17b686b62d37f11a848d731c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <br /></td></tr>
<tr class="separator:a1071e5fd17b686b62d37f11a848d731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c79c51defc11fd2e666cc89648bc0d" id="r_af7c79c51defc11fd2e666cc89648bc0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af7c79c51defc11fd2e666cc89648bc0d">getProgFunction</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">funName</a>)</td></tr>
<tr class="memdesc:af7c79c51defc11fd2e666cc89648bc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from function name.  <br /></td></tr>
<tr class="separator:af7c79c51defc11fd2e666cc89648bc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826f7ecf6dfd1eb9646602f1db77841" id="r_a2826f7ecf6dfd1eb9646602f1db77841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2826f7ecf6dfd1eb9646602f1db77841">getProgEntryFunction</a> ()</td></tr>
<tr class="memdesc:a2826f7ecf6dfd1eb9646602f1db77841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function.  <br /></td></tr>
<tr class="separator:a2826f7ecf6dfd1eb9646602f1db77841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e36235204eb1e16394ee5c37f947d" id="r_af78e36235204eb1e16394ee5c37f947d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af78e36235204eb1e16394ee5c37f947d">isProgExitFunction</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *fun)</td></tr>
<tr class="memdesc:af78e36235204eb1e16394ee5c37f947d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <br /></td></tr>
<tr class="separator:af78e36235204eb1e16394ee5c37f947d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf54f0e0bd3a1171fd89719375b55be" id="r_a8bf54f0e0bd3a1171fd89719375b55be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8bf54f0e0bd3a1171fd89719375b55be">isArgOfUncalledFunction</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1SVFVar.html">SVFVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfvar</a>)</td></tr>
<tr class="separator:a8bf54f0e0bd3a1171fd89719375b55be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4bd4503b296c44bc6f397237abc46c" id="r_a0f4bd4503b296c44bc6f397237abc46c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ObjVar.html">ObjVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0f4bd4503b296c44bc6f397237abc46c">getObjVarOfValVar</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> *<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">valVar</a>)</td></tr>
<tr class="separator:a0f4bd4503b296c44bc6f397237abc46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa1298393769239472e919a3c52c0de" id="r_acfa1298393769239472e919a3c52c0de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acfa1298393769239472e919a3c52c0de">getForkedFun</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *inst)</td></tr>
<tr class="memdesc:acfa1298393769239472e919a3c52c0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <br /></td></tr>
<tr class="separator:acfa1298393769239472e919a3c52c0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d203b5b7749ce51583d39a503407db" id="r_aa2d203b5b7749ce51583d39a503407db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa2d203b5b7749ce51583d39a503407db">isExtCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:aa2d203b5b7749ce51583d39a503407db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f888dfee60a63eb0711fcdd63430e8f" id="r_a3f888dfee60a63eb0711fcdd63430e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3f888dfee60a63eb0711fcdd63430e8f">isExtCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:a3f888dfee60a63eb0711fcdd63430e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a75e8eda99da5d45ccf0188e2d876d" id="r_a83a75e8eda99da5d45ccf0188e2d876d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a83a75e8eda99da5d45ccf0188e2d876d">isHeapAllocExtCallViaArg</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a83a75e8eda99da5d45ccf0188e2d876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3bde29364d65428ee2c4eb22063828" id="r_aeb3bde29364d65428ee2c4eb22063828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb3bde29364d65428ee2c4eb22063828">isHeapAllocExtCallViaRet</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:aeb3bde29364d65428ee2c4eb22063828"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces to be used externally  <br /></td></tr>
<tr class="separator:aeb3bde29364d65428ee2c4eb22063828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b308e08dd0837b9401ada40349ac32" id="r_a85b308e08dd0837b9401ada40349ac32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a85b308e08dd0837b9401ada40349ac32">isHeapAllocExtCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *cs)</td></tr>
<tr class="separator:a85b308e08dd0837b9401ada40349ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd908aab5f4e0352c50a36381ae85f3" id="r_a5bd908aab5f4e0352c50a36381ae85f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5bd908aab5f4e0352c50a36381ae85f3">getHeapAllocHoldingArgPosition</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a5bd908aab5f4e0352c50a36381ae85f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f4cd58f733d71c9bbd7dcc40194c0b" id="r_a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a01f4cd58f733d71c9bbd7dcc40194c0b">isReallocExtCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06" id="r_a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a811faa9c2095f44e3e5b6e50aa6f6e06">is_sequence_container_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5" id="r_a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8c57ab480c497cbd21a49778d0e59bd5">is_map_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2" id="r_a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a08e67d68b1da116b2c51cb60bdb6dae2">is_set_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06" id="r_ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad37880353cffc950d5b9417bc41c0b06">void_t</a> = <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a>&lt; Ts... &gt;<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">::type</a></td></tr>
<tr class="separator:ad37880353cffc950d5b9417bc41c0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588" id="r_aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt; </td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa32219da7a5c3d7517ec5026afdac588">is_iterable_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a>&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a>&gt;::value</td></tr>
<tr class="separator:aa32219da7a5c3d7517ec5026afdac588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a03aaeb26832c69f95a9a96a2d31a" id="r_aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aac9a03aaeb26832c69f95a9a96a2d31a">isThreadForkCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *inst)</td></tr>
<tr class="separator:aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c79a20405d3a31b309a14bd68f1166" id="r_a86c79a20405d3a31b309a14bd68f1166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c79a20405d3a31b309a14bd68f1166">isThreadJoinCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a86c79a20405d3a31b309a14bd68f1166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b7843d49df58cf1bf3725076702c07" id="r_ac1b7843d49df58cf1bf3725076702c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac1b7843d49df58cf1bf3725076702c07">isThreadExitCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:ac1b7843d49df58cf1bf3725076702c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191cbe16e7e32dd136cff438752b3029" id="r_a191cbe16e7e32dd136cff438752b3029"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a191cbe16e7e32dd136cff438752b3029">isLockAquireCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a191cbe16e7e32dd136cff438752b3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7be6fe5d9c277583eaeab46282b62" id="r_abaa7be6fe5d9c277583eaeab46282b62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abaa7be6fe5d9c277583eaeab46282b62">isLockReleaseCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:abaa7be6fe5d9c277583eaeab46282b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0066d96179c6d7e9a1e42608ecb73" id="r_a34f0066d96179c6d7e9a1e42608ecb73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a34f0066d96179c6d7e9a1e42608ecb73">isBarrierWaitCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:a34f0066d96179c6d7e9a1e42608ecb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a barrier wait call.  <br /></td></tr>
<tr class="separator:a34f0066d96179c6d7e9a1e42608ecb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7764f2af867180da0a0b08c239a10d0" id="r_ab7764f2af867180da0a0b08c239a10d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab7764f2af867180da0a0b08c239a10d0">getActualParmAtForkSite</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:ab7764f2af867180da0a0b08c239a10d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sole argument of the thread routine.  <br /></td></tr>
<tr class="separator:ab7764f2af867180da0a0b08c239a10d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6586774af88b61f367ba43d126f38ac" id="r_ac6586774af88b61f367ba43d126f38ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac6586774af88b61f367ba43d126f38ac">isProgExitCall</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:ac6586774af88b61f367ba43d126f38ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83719194c43227aecd0642ce9e988bf" id="r_ae83719194c43227aecd0642ce9e988bf"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt; </td></tr>
<tr class="memitem:ae83719194c43227aecd0642ce9e988bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> std::remove_reference&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt;<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">::type</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae83719194c43227aecd0642ce9e988bf">move</a> (<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &amp;&amp;t) <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">noexcept</a></td></tr>
<tr class="separator:ae83719194c43227aecd0642ce9e988bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acb66b86171786cc34b798f05f67f321e" name="acb66b86171786cc34b798f05f67f321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb66b86171786cc34b798f05f67f321e">&#9670;&#160;</a></span>equalNodeBS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">struct</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac047d963ed4b701c83958868ab36202f" name="ac047d963ed4b701c83958868ab36202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac047d963ed4b701c83958868ab36202f">&#9670;&#160;</a></span>equalPointsTo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">struct</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4740b14abf7d308e7806a0d6d6c42ee2" name="a4740b14abf7d308e7806a0d6d6c42ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b14abf7d308e7806a0d6d6c42ee2">&#9670;&#160;</a></span>PointsToList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt;<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a>&gt; <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00168">168</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="ad37880353cffc950d5b9417bc41c0b06" name="ad37880353cffc950d5b9417bc41c0b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37880353cffc950d5b9417bc41c0b06">&#9670;&#160;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">using</a> <a class="el" href="namespaceSVF_1_1SVFUtil.html#ad37880353cffc950d5b9417bc41c0b06">SVF::SVFUtil::void_t</a> = <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typedef</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a>&lt;Ts...&gt;<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">::type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00430">430</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a10504db25b86bc7f74aebb9c54f04cb3" name="a10504db25b86bc7f74aebb9c54f04cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10504db25b86bc7f74aebb9c54f04cb3">&#9670;&#160;</a></span>bugMsg1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg1 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00083">83</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   84</span>{</div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   86</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
<div class="ttc" id="aSVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00044">SVFUtil.cpp:44</a></div></div>
<div class="ttc" id="anamespaceSVF_html_a94824519e439aeef1568d415b6f7331c"><div class="ttname"><a href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">SVF::IRBuilder</a></div><div class="ttdeci">llvm::IRBuilder IRBuilder</div><div class="ttdef"><b>Definition</b> <a href="BasicTypes_8h_source.html#l00074">BasicTypes.h:74</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac25f6dfcc9118ffd80244a771bdee535" name="ac25f6dfcc9118ffd80244a771bdee535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f6dfcc9118ffd80244a771bdee535">&#9670;&#160;</a></span>bugMsg2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00088">88</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   89</span>{</div>
<div class="line"><span class="lineno">   90</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   91</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a326cbc9ef8d75aa44a591bf476c9835b"><div class="ttname"><a href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a></div><div class="ttdeci">#define KPUR</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00046">SVFUtil.cpp:46</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a76909ad87f59eb9a9cfd1913e13da264" name="a76909ad87f59eb9a9cfd1913e13da264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76909ad87f59eb9a9cfd1913e13da264">&#9670;&#160;</a></span>bugMsg3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::bugMsg3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00093">93</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   94</span>{</div>
<div class="line"><span class="lineno">   95</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   96</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_add84f76d7bfbbc2b00215d7195f8d3bd"><div class="ttname"><a href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a></div><div class="ttdeci">#define KCYA</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00047">SVFUtil.cpp:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ac2d264d80b8bfdbeaf120c5d6778d0" name="a5ac2d264d80b8bfdbeaf120c5d6778d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac2d264d80b8bfdbeaf120c5d6778d0">&#9670;&#160;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::value, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type &gt; SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00360">360</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  361</span>{</div>
<div class="line"><span class="lineno">  362</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><span class="lineno">  363</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a>&lt;</div>
<div class="line"><span class="lineno">  364</span>           <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a>, <span class="keyword">typename</span> <a class="code hl_typedef" href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">simplify_type&lt;const Y&gt;::SimpleType</a>&gt;::doit(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>);</div>
<div class="line"><span class="lineno">  365</span>}</div>
<div class="ttc" id="astructSVF_1_1SVFUtil_1_1cast__convert__val_html"><div class="ttname"><a href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">SVF::SVFUtil::cast_convert_val</a></div><div class="ttdef"><b>Definition</b> <a href="Casting_8h_source.html#l00322">Casting.h:323</a></div></div>
<div class="ttc" id="astructSVF_1_1SVFUtil_1_1simplify__type_html_a40c0d9a74681d3eaa7172ba137d489e4"><div class="ttname"><a href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">SVF::SVFUtil::simplify_type::SimpleType</a></div><div class="ttdeci">From SimpleType</div><div class="ttdef"><b>Definition</b> <a href="Casting_8h_source.html#l00105">Casting.h:105</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c81ab179a570e6a4f16dbc776cad360" name="a3c81ab179a570e6a4f16dbc776cad360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c81ab179a570e6a4f16dbc776cad360">&#9670;&#160;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, std::unique_ptr&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00385">385</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  386</span>{</div>
<div class="line"><span class="lineno">  387</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>.get()) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><span class="lineno">  388</span>    <span class="keyword">using </span>ret_type = <span class="keyword">typename</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">cast_retty&lt;X, std::unique_ptr&lt;Y&gt;</a>&gt;::ret_type;</div>
<div class="line"><span class="lineno">  389</span>    <span class="keywordflow">return</span> ret_type(</div>
<div class="line"><span class="lineno">  390</span>               <a class="code hl_struct" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a>&lt;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> *, <span class="keyword">typename</span> <a class="code hl_typedef" href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">simplify_type&lt;Y *&gt;::SimpleType</a>&gt;::doit(</div>
<div class="line"><span class="lineno">  391</span>                   <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>.release()));</div>
<div class="line"><span class="lineno">  392</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3fad7cd816cf65f5909aaaec37808018" name="a3fad7cd816cf65f5909aaaec37808018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fad7cd816cf65f5909aaaec37808018">&#9670;&#160;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00368">368</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  369</span>{</div>
<div class="line"><span class="lineno">  370</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a>&lt;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a>,</div>
<div class="line"><span class="lineno">  372</span>           <span class="keyword">typename</span> <a class="code hl_typedef" href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">simplify_type&lt;Y&gt;::SimpleType</a>&gt;::doit(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>);</div>
<div class="line"><span class="lineno">  373</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74798437de126220947080e9fed0e90c" name="a74798437de126220947080e9fed0e90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74798437de126220947080e9fed0e90c">&#9670;&#160;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> * &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00376">376</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  377</span>{</div>
<div class="line"><span class="lineno">  378</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><span class="lineno">  379</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a>&lt;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a>*,</div>
<div class="line"><span class="lineno">  380</span>           <span class="keyword">typename</span> <a class="code hl_typedef" href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">simplify_type&lt;Y*&gt;::SimpleType</a>&gt;::doit(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>);</div>
<div class="line"><span class="lineno">  381</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f749354b7e882ef3e5bf5081fa715b5" name="a8f749354b7e882ef3e5bf5081fa715b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f749354b7e882ef3e5bf5081fa715b5">&#9670;&#160;</a></span>cmpNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::cmpNodeBS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00127">127</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  128</span>{</div>
<div class="line"><span class="lineno">  129</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.count() != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.count())</div>
<div class="line"><span class="lineno">  130</span>        <span class="keywordflow">return</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.count() &lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.count());</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  132</span>    {</div>
<div class="line"><span class="lineno">  133</span>        <a class="code hl_class" href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">NodeBS::iterator</a> bit = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.end();</div>
<div class="line"><span class="lineno">  134</span>        <a class="code hl_class" href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">NodeBS::iterator</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">reit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.end();</div>
<div class="line"><span class="lineno">  135</span>        <span class="keywordflow">for</span> (; bit != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eit</a> &amp;&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a> != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">reit</a>; bit++, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>++)</div>
<div class="line"><span class="lineno">  136</span>        {</div>
<div class="line"><span class="lineno">  137</span>            <span class="keywordflow">if</span> (*bit != *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>)</div>
<div class="line"><span class="lineno">  138</span>                <span class="keywordflow">return</span> (*bit &lt; *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>);</div>
<div class="line"><span class="lineno">  139</span>        }</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  142</span>    }</div>
<div class="line"><span class="lineno">  143</span>}</div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_1_1SparseBitVectorIterator_html"><div class="ttname"><a href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">SVF::SparseBitVector::SparseBitVectorIterator</a></div><div class="ttdef"><b>Definition</b> <a href="SparseBitVector_8h_source.html#l00578">SparseBitVector.h:579</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5ce14119a6e3b0b6022753ddd5890f3" name="aa5ce14119a6e3b0b6022753ddd5890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ce14119a6e3b0b6022753ddd5890f3">&#9670;&#160;</a></span>cmpPts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::cmpPts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> according to their size and points-to elements.</p><ol type="1">
<li><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> with smaller size is smaller than the other;</li>
<li>If the sizes are equal, comparing the points-to targets. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00109">109</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  110</span>{</div>
<div class="line"><span class="lineno">  111</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.count() != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.count())</div>
<div class="line"><span class="lineno">  112</span>        <span class="keywordflow">return</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.count() &lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.count());</div>
<div class="line"><span class="lineno">  113</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  114</span>    {</div>
<div class="line"><span class="lineno">  115</span>        <a class="code hl_class" href="classSVF_1_1PointsTo_1_1PointsToIterator.html">PointsTo::iterator</a> bit = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">lpts</a>.end();</div>
<div class="line"><span class="lineno">  116</span>        <a class="code hl_class" href="classSVF_1_1PointsTo_1_1PointsToIterator.html">PointsTo::iterator</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">reit</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rpts</a>.end();</div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">for</span> (; bit != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">eit</a> &amp;&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a> != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">reit</a>; bit++, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>++)</div>
<div class="line"><span class="lineno">  118</span>        {</div>
<div class="line"><span class="lineno">  119</span>            <span class="keywordflow">if</span> (*bit != *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>)</div>
<div class="line"><span class="lineno">  120</span>                <span class="keywordflow">return</span> (*bit &lt; *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rbit</a>);</div>
<div class="line"><span class="lineno">  121</span>        }</div>
<div class="line"><span class="lineno">  122</span> </div>
<div class="line"><span class="lineno">  123</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  124</span>    }</div>
<div class="line"><span class="lineno">  125</span>}</div>
<div class="ttc" id="aclassSVF_1_1PointsTo_1_1PointsToIterator_html"><div class="ttname"><a href="classSVF_1_1PointsTo_1_1PointsToIterator.html">SVF::PointsTo::PointsToIterator</a></div><div class="ttdef"><b>Definition</b> <a href="PointsTo_8h_source.html#l00181">PointsTo.h:182</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a15cc5570eed12dd6ee766213e11d61" name="a4a15cc5570eed12dd6ee766213e11d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15cc5570eed12dd6ee766213e11d61">&#9670;&#160;</a></span>dumpAliasSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpAliasSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump alias set. </p>
<p>Dump alias set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00139">139</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  140</span>{</div>
<div class="line"><span class="lineno">  141</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; alias set: {&quot;</span>;</div>
<div class="line"><span class="lineno">  142</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>);</div>
<div class="line"><span class="lineno">  143</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  144</span>}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ad8b432d1a6e3f8ddd7a3505f7b7a8cd3"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs()</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00052">SVFUtil.h:52</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00149">SVFUtil.cpp:149</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af4ceddbe4d57b24e80201bc895f73810" name="af4ceddbe4d57b24e80201bc895f73810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ceddbe4d57b24e80201bc895f73810">&#9670;&#160;</a></span>dumpPointsToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;&#160;</td>
          <td class="paramname"><em>ptl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00124">124</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  125</span>{</div>
<div class="line"><span class="lineno">  126</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">for</span> (PointsToList::const_iterator <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptl</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ie</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptl</a>.end();</div>
<div class="line"><span class="lineno">  128</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a> != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ie</a>; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a>++)</div>
<div class="line"><span class="lineno">  129</span>    {</div>
<div class="line"><span class="lineno">  130</span>        <span class="keyword">auto</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a> = *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a>;</div>
<div class="line"><span class="lineno">  131</span>        <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>);</div>
<div class="line"><span class="lineno">  132</span>    }</div>
<div class="line"><span class="lineno">  133</span>    outs() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  134</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd0a9ee845a455f9354d24a8b84a0bb3" name="abd0a9ee845a455f9354d24a8b84a0bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0a9ee845a455f9354d24a8b84a0bb3">&#9670;&#160;</a></span>dumpPointsToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump points-to set. </p>
<p>Dump points-to set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00109">109</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  110</span>{</div>
<div class="line"><span class="lineno">  111</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; points-to: {&quot;</span>;</div>
<div class="line"><span class="lineno">  112</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>);</div>
<div class="line"><span class="lineno">  113</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  114</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb570e9267fd7b189bd1bc877896d7ab" name="aeb570e9267fd7b189bd1bc877896d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb570e9267fd7b189bd1bc877896d7ab">&#9670;&#160;</a></span>dumpSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump sparse bitvector set. </p>
<p>Dump bit vector set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00149">149</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  150</span>{</div>
<div class="line"><span class="lineno">  151</span>    <span class="keywordflow">for</span> (<a class="code hl_class" href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">NodeBS::iterator</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>.begin(), <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ie</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>.end();</div>
<div class="line"><span class="lineno">  152</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a> != <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ie</a>; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a>++)</div>
<div class="line"><span class="lineno">  153</span>    {</div>
<div class="line"><span class="lineno">  154</span>        O &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ii</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  155</span>    }</div>
<div class="line"><span class="lineno">  156</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a04aa23b4982662d98c56af3e8ba16cb1" name="a04aa23b4982662d98c56af3e8ba16cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa23b4982662d98c56af3e8ba16cb1">&#9670;&#160;</a></span>dumpSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00158">158</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  159</span>{</div>
<div class="line"><span class="lineno">  160</span>    <span class="keywordflow">for</span> (<a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_variable" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> : pt)</div>
<div class="line"><span class="lineno">  161</span>    {</div>
<div class="line"><span class="lineno">  162</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">o</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code hl_variable" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><span class="lineno">  163</span>    }</div>
<div class="line"><span class="lineno">  164</span>}</div>
<div class="ttc" id="acJSON_8cpp_html_ab6e2ea6dc7bd57d1483413449998230a"><div class="ttname"><a href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a></div><div class="ttdeci">cJSON * n</div><div class="ttdef"><b>Definition</b> <a href="cJSON_8cpp_source.html#l02558">cJSON.cpp:2558</a></div></div>
<div class="ttc" id="anamespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">u32_t NodeID</div><div class="ttdef"><b>Definition</b> <a href="GeneralType_8h_source.html#l00056">GeneralType.h:56</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab30a35713852a0a525c52ae5dd463442" name="ab30a35713852a0a525c52ae5dd463442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a35713852a0a525c52ae5dd463442">&#9670;&#160;</a></span>dumpSparseSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSparseSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>To</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00117">117</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  118</span>{</div>
<div class="line"><span class="lineno">  119</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><span class="lineno">  120</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bs</a>);</div>
<div class="line"><span class="lineno">  121</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><span class="lineno">  122</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aefeaa1d67563fbf00b9f06a848072df1" name="aefeaa1d67563fbf00b9f06a848072df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefeaa1d67563fbf00b9f06a848072df1">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::value, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type &gt; SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00405">405</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  406</span>{</div>
<div class="line"><span class="lineno">  407</span>    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) ? SVFUtil::cast&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nullptr</a>;</div>
<div class="line"><span class="lineno">  408</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b51d4b9abc2b53e9c5f20615a48a6fc" name="a4b51d4b9abc2b53e9c5f20615a48a6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b51d4b9abc2b53e9c5f20615a48a6fc">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00411">411</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  412</span>{</div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) ? SVFUtil::cast&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nullptr</a>;</div>
<div class="line"><span class="lineno">  414</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cc262ae3f77bf173e5a1dab52a76512" name="a6cc262ae3f77bf173e5a1dab52a76512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc262ae3f77bf173e5a1dab52a76512">&#9670;&#160;</a></span>dyn_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> * &gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00417">417</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  418</span>{</div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) ? SVFUtil::cast&lt;X&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nullptr</a>;</div>
<div class="line"><span class="lineno">  420</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7655b13bbfe720ca2b8a25e0a72528e6" name="a7655b13bbfe720ca2b8a25e0a72528e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7655b13bbfe720ca2b8a25e0a72528e6">&#9670;&#160;</a></span>errMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::errMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print error message by converting a string into red string output. </p>
<p>print error message by converting a string into red string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00078">78</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   79</span>{</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   81</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a66290957baed5df3930ada4cb8caccf1"><div class="ttname"><a href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a></div><div class="ttdeci">#define KRED</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00042">SVFUtil.cpp:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa4f76b6289e99c6660a34475c4b66074" name="aa4f76b6289e99c6660a34475c4b66074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f76b6289e99c6660a34475c4b66074">&#9670;&#160;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; SVF::SVFUtil::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite llvm::errs() </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00058">58</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   59</span>{</div>
<div class="line"><span class="lineno">   60</span>    <span class="keywordflow">return</span> std::cerr;</div>
<div class="line"><span class="lineno">   61</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab7764f2af867180da0a0b08c239a10d0" name="ab7764f2af867180da0a0b08c239a10d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7764f2af867180da0a0b08c239a10d0">&#9670;&#160;</a></span>getActualParmAtForkSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> * SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sole argument of the thread routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00408">408</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  409</span>{</div>
<div class="line"><span class="lineno">  410</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(cs);</div>
<div class="line"><span class="lineno">  411</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acfa1298393769239472e919a3c52c0de" name="acfa1298393769239472e919a3c52c0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa1298393769239472e919a3c52c0de">&#9670;&#160;</a></span>getForkedFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> * SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return thread fork function. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00331">331</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  332</span>{</div>
<div class="line"><span class="lineno">  333</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(inst);</div>
<div class="line"><span class="lineno">  334</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bd908aab5f4e0352c50a36381ae85f3" name="a5bd908aab5f4e0352c50a36381ae85f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd908aab5f4e0352c50a36381ae85f3">&#9670;&#160;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00345">345</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  346</span>{</div>
<div class="line"><span class="lineno">  347</span>    <span class="keywordflow">return</span> getHeapAllocHoldingArgPosition(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  348</span>}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_a55c4e8d302f61aa9a46ac7daa318b849"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">SVF::CallICFGNode::getCalledFunction</a></div><div class="ttdeci">const FunObjVar * getCalledFunction() const</div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00512">ICFGNode.h:512</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a222ecd1c0c7fdf21d680b1605370392c" name="a222ecd1c0c7fdf21d680b1605370392c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a222ecd1c0c7fdf21d680b1605370392c">&#9670;&#160;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of argument that holds an allocated heap object. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00293">293</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  294</span>{</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">return</span> ExtAPI::getExtAPI()-&gt;get_alloc_arg_pos(fun);</div>
<div class="line"><span class="lineno">  296</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a630ff9c47f58f9b8df7c8a2b3711477c" name="a630ff9c47f58f9b8df7c8a2b3711477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ff9c47f58f9b8df7c8a2b3711477c">&#9670;&#160;</a></span>getMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::getMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmrss_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmsize_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory usage from system file. Return TRUE if succeed. </p>
<p>Get memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00179">179</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  180</span>{</div>
<div class="line"><span class="lineno">  181</span>    <span class="comment">/* Get the current process&#39; status file from the proc filesystem */</span></div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordtype">char</span> <a class="code hl_variable" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>[8192];</div>
<div class="line"><span class="lineno">  183</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">FILE</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">procfile</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">fopen</a>(<span class="stringliteral">&quot;/proc/self/status&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">if</span>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">procfile</a>)</div>
<div class="line"><span class="lineno">  185</span>    {</div>
<div class="line"><span class="lineno">  186</span>        <a class="code hl_typedef" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">fread</a>(<a class="code hl_variable" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), 8192, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">procfile</a>);</div>
<div class="line"><span class="lineno">  187</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> == 0)</div>
<div class="line"><span class="lineno">  188</span>        {</div>
<div class="line"><span class="lineno">  189</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">fputs</a> (<span class="stringliteral">&quot;Reading error\n&quot;</span>,<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">stderr</a>);</div>
<div class="line"><span class="lineno">  190</span>        }</div>
<div class="line"><span class="lineno">  191</span>    }</div>
<div class="line"><span class="lineno">  192</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  193</span>    {</div>
<div class="line"><span class="lineno">  194</span>        <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">SVFUtil::writeWrnMsg</a>(<span class="stringliteral">&quot; /proc/self/status file not exit!&quot;</span>);</div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  196</span>    }</div>
<div class="line"><span class="lineno">  197</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">fclose</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">procfile</a>);</div>
<div class="line"><span class="lineno">  198</span> </div>
<div class="line"><span class="lineno">  199</span>    <span class="comment">/* Look through proc status contents line by line */</span></div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordtype">char</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">delims</a>[] = <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordtype">char</span>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a> = <a class="code hl_function" href="extapi_8c.html#a7548679e9171d4873e7699282ba8dd30">strtok</a>(<a class="code hl_variable" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">delims</a>);</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>    <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmrss</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  204</span>    <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmsize</a> = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  205</span> </div>
<div class="line"><span class="lineno">  206</span>    <span class="keywordflow">while</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a> != <span class="keyword">nullptr</span> &amp;&amp; (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmrss</a> == <span class="keyword">false</span> || <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmsize</a> == <span class="keyword">false</span>))</div>
<div class="line"><span class="lineno">  207</span>    {</div>
<div class="line"><span class="lineno">  208</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="extapi_8c.html#ab57319b670052e4c93c1f6822c28d5ce">strstr</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a>, <span class="stringliteral">&quot;VmRSS:&quot;</span>) != <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  209</span>        {</div>
<div class="line"><span class="lineno">  210</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">sscanf</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a>, <span class="stringliteral">&quot;%*s %u&quot;</span>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmrss_kb</a>);</div>
<div class="line"><span class="lineno">  211</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmrss</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  212</span>        }</div>
<div class="line"><span class="lineno">  213</span> </div>
<div class="line"><span class="lineno">  214</span>        <span class="keywordflow">if</span> (<a class="code hl_function" href="extapi_8c.html#ab57319b670052e4c93c1f6822c28d5ce">strstr</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a>, <span class="stringliteral">&quot;VmSize:&quot;</span>) != <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  215</span>        {</div>
<div class="line"><span class="lineno">  216</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">sscanf</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a>, <span class="stringliteral">&quot;%*s %u&quot;</span>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmsize_kb</a>);</div>
<div class="line"><span class="lineno">  217</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmsize</a> = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  218</span>        }</div>
<div class="line"><span class="lineno">  219</span> </div>
<div class="line"><span class="lineno">  220</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">line</a> = <a class="code hl_function" href="extapi_8c.html#a7548679e9171d4873e7699282ba8dd30">strtok</a>(<span class="keyword">nullptr</span>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">delims</a>);</div>
<div class="line"><span class="lineno">  221</span>    }</div>
<div class="line"><span class="lineno">  222</span> </div>
<div class="line"><span class="lineno">  223</span>    <span class="keywordflow">return</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmrss</a> &amp;&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">found_vmsize</a>);</div>
<div class="line"><span class="lineno">  224</span>}</div>
<div class="ttc" id="acJSON_8h_html_a503753140aa27b00f99a3501280b2746"><div class="ttname"><a href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a></div><div class="ttdeci">char * buffer</div><div class="ttdef"><b>Definition</b> <a href="cJSON_8h_source.html#l00163">cJSON.h:163</a></div></div>
<div class="ttc" id="aextapi_8c_html_a7548679e9171d4873e7699282ba8dd30"><div class="ttname"><a href="extapi_8c.html#a7548679e9171d4873e7699282ba8dd30">strtok</a></div><div class="ttdeci">char * strtok(char *str, const char *delim)</div><div class="ttdef"><b>Definition</b> <a href="extapi_8c_source.html#l00463">extapi.c:463</a></div></div>
<div class="ttc" id="aextapi_8c_html_ab57319b670052e4c93c1f6822c28d5ce"><div class="ttname"><a href="extapi_8c.html#ab57319b670052e4c93c1f6822c28d5ce">strstr</a></div><div class="ttdeci">char * strstr(const char *haystack, const char *needle)</div><div class="ttdef"><b>Definition</b> <a href="extapi_8c_source.html#l00821">extapi.c:821</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ab2e0196e0ce547ab4a483cc6d2646b24"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">SVF::SVFUtil::writeWrnMsg</a></div><div class="ttdeci">void writeWrnMsg(const std::string &amp;msg)</div><div class="ttdoc">Writes a message run through wrnMsg.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00068">SVFUtil.cpp:68</a></div></div>
<div class="ttc" id="anamespaceSVF_html_ad42bff8d0a7d60a085aa32d10f4955af"><div class="ttname"><a href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">SVF::u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition</b> <a href="GeneralType_8h_source.html#l00047">GeneralType.h:47</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f4bd4503b296c44bc6f397237abc46c" name="a0f4bd4503b296c44bc6f397237abc46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4bd4503b296c44bc6f397237abc46c">&#9670;&#160;</a></span>getObjVarOfValVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ObjVar.html">ObjVar</a> * SVF::SVFUtil::getObjVarOfValVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ValVar.html">ValVar</a> *&#160;</td>
          <td class="paramname"><em>valVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00431">431</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  432</span>{</div>
<div class="line"><span class="lineno">  433</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">valVar</a>-&gt;getInEdges().size() == 1);</div>
<div class="line"><span class="lineno">  434</span>    <span class="keywordflow">return</span> SVFUtil::dyn_cast&lt;ObjVar&gt;((*<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">valVar</a>-&gt;getInEdges().begin())-&gt;getSrcNode());</div>
<div class="line"><span class="lineno">  435</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2826f7ecf6dfd1eb9646602f1db77841" name="a2826f7ecf6dfd1eb9646602f1db77841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2826f7ecf6dfd1eb9646602f1db77841">&#9670;&#160;</a></span>getProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> * SVF::SVFUtil::getProgEntryFunction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get program entry function. </p>
<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00410">410</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  411</span>{</div>
<div class="line"><span class="lineno">  412</span>    <a class="code hl_class" href="classSVF_1_1CallGraph.html">CallGraph</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfirCallGraph</a> = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a173b6516fba3f12bf19622afdbea1837">getCallGraph</a>();</div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_variable" href="cJSON_8h.html#ac76cea59d438ba893d2f82aabb367d14">item</a>: *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfirCallGraph</a>)</div>
<div class="line"><span class="lineno">  414</span>    {</div>
<div class="line"><span class="lineno">  415</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1CallGraphNode.html">CallGraphNode</a>*fun = <a class="code hl_variable" href="cJSON_8h.html#ac76cea59d438ba893d2f82aabb367d14">item</a>.second;</div>
<div class="line"><span class="lineno">  416</span>        <span class="keywordflow">if</span> (isProgEntryFunction(fun-&gt;<a class="code hl_function" href="classSVF_1_1CallGraphNode.html#a200bbf3e2ea4133606b7b8adb4863657">getFunction</a>()))</div>
<div class="line"><span class="lineno">  417</span>            <span class="keywordflow">return</span> (fun-&gt;<a class="code hl_function" href="classSVF_1_1CallGraphNode.html#a200bbf3e2ea4133606b7b8adb4863657">getFunction</a>());</div>
<div class="line"><span class="lineno">  418</span>    }</div>
<div class="line"><span class="lineno">  419</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  420</span>}</div>
<div class="ttc" id="acJSON_8h_html_ac76cea59d438ba893d2f82aabb367d14"><div class="ttname"><a href="cJSON_8h.html#ac76cea59d438ba893d2f82aabb367d14">item</a></div><div class="ttdeci">cJSON * item</div><div class="ttdef"><b>Definition</b> <a href="cJSON_8h_source.html#l00222">cJSON.h:222</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallGraphNode_html"><div class="ttname"><a href="classSVF_1_1CallGraphNode.html">SVF::CallGraphNode</a></div><div class="ttdef"><b>Definition</b> <a href="CallGraph_8h_source.html#l00176">CallGraph.h:177</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallGraphNode_html_a200bbf3e2ea4133606b7b8adb4863657"><div class="ttname"><a href="classSVF_1_1CallGraphNode.html#a200bbf3e2ea4133606b7b8adb4863657">SVF::CallGraphNode::getFunction</a></div><div class="ttdeci">const FunObjVar * getFunction() const</div><div class="ttdoc">Get function of this call node.</div><div class="ttdef"><b>Definition</b> <a href="CallGraph_8h_source.html#l00191">CallGraph.h:191</a></div></div>
<div class="ttc" id="aclassSVF_1_1CallGraph_html"><div class="ttname"><a href="classSVF_1_1CallGraph.html">SVF::CallGraph</a></div><div class="ttdef"><b>Definition</b> <a href="CallGraph_8h_source.html#l00234">CallGraph.h:235</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html_a173b6516fba3f12bf19622afdbea1837"><div class="ttname"><a href="classSVF_1_1SVFIR.html#a173b6516fba3f12bf19622afdbea1837">SVF::SVFIR::getCallGraph</a></div><div class="ttdeci">CallGraph * getCallGraph()</div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00184">SVFIR.h:184</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html_acdb6795e102e7c03a61b7a4d2044c348"><div class="ttname"><a href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">SVF::SVFIR::getPAG</a></div><div class="ttdeci">static SVFIR * getPAG(bool buildFromFile=false)</div><div class="ttdoc">Singleton design here to make sure we only have one instance during any analysis.</div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00116">SVFIR.h:116</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af7c79c51defc11fd2e666cc89648bc0d" name="af7c79c51defc11fd2e666cc89648bc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c79c51defc11fd2e666cc89648bc0d">&#9670;&#160;</a></span>getProgFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> * SVF::SVFUtil::getProgFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>funName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get program entry function from function name. </p>
<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00397">397</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  398</span>{</div>
<div class="line"><span class="lineno">  399</span>    <a class="code hl_class" href="classSVF_1_1CallGraph.html">CallGraph</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfirCallGraph</a> = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#a173b6516fba3f12bf19622afdbea1837">getCallGraph</a>();</div>
<div class="line"><span class="lineno">  400</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_variable" href="cJSON_8h.html#ac76cea59d438ba893d2f82aabb367d14">item</a>: *<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfirCallGraph</a>)</div>
<div class="line"><span class="lineno">  401</span>    {</div>
<div class="line"><span class="lineno">  402</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1CallGraphNode.html">CallGraphNode</a>*fun = <a class="code hl_variable" href="cJSON_8h.html#ac76cea59d438ba893d2f82aabb367d14">item</a>.second;</div>
<div class="line"><span class="lineno">  403</span>        <span class="keywordflow">if</span> (fun-&gt;<a class="code hl_function" href="classSVF_1_1CallGraphNode.html#a2122144ce2e7acc0bbee39efee9a3663">getName</a>()==<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">funName</a>)</div>
<div class="line"><span class="lineno">  404</span>            <span class="keywordflow">return</span> fun-&gt;<a class="code hl_function" href="classSVF_1_1CallGraphNode.html#a200bbf3e2ea4133606b7b8adb4863657">getFunction</a>();</div>
<div class="line"><span class="lineno">  405</span>    }</div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  407</span>}</div>
<div class="ttc" id="aclassSVF_1_1CallGraphNode_html_a2122144ce2e7acc0bbee39efee9a3663"><div class="ttname"><a href="classSVF_1_1CallGraphNode.html#a2122144ce2e7acc0bbee39efee9a3663">SVF::CallGraphNode::getName</a></div><div class="ttdeci">const std::string &amp; getName() const</div><div class="ttdef"><b>Definition</b> <a href="CallGraph_8cpp_source.html#l00045">CallGraph.cpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a14a4c5124f2fd03ca3d898e2acd54160" name="a14a4c5124f2fd03ca3d898e2acd54160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4c5124f2fd03ca3d898e2acd54160">&#9670;&#160;</a></span>hclustMethodToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::hclustMethodToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a hclust method. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00248">248</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  249</span>{</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">switch</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">method</a>)</div>
<div class="line"><span class="lineno">  251</span>    {</div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a>:</div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;single&quot;</span>;</div>
<div class="line"><span class="lineno">  254</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a>:</div>
<div class="line"><span class="lineno">  255</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;complete&quot;</span>;</div>
<div class="line"><span class="lineno">  256</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a>:</div>
<div class="line"><span class="lineno">  257</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;average&quot;</span>;</div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a>:</div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;median&quot;</span>;</div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>:</div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot;svf-best&quot;</span>;</div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  263</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">assert</a>(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;SVFUtil::hclustMethodToString: unknown method&quot;</span>);</div>
<div class="line"><span class="lineno">  264</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">abort</a>();</div>
<div class="line"><span class="lineno">  265</span>    }</div>
<div class="line"><span class="lineno">  266</span>}</div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a></div><div class="ttdeci">@ HCLUST_METHOD_AVERAGE</div><div class="ttdef"><b>Definition</b> <a href="fastcluster_8h_source.html#l00072">fastcluster.h:72</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a></div><div class="ttdeci">@ HCLUST_METHOD_COMPLETE</div><div class="ttdef"><b>Definition</b> <a href="fastcluster_8h_source.html#l00070">fastcluster.h:70</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdeci">@ HCLUST_METHOD_SVF_BEST</div><div class="ttdef"><b>Definition</b> <a href="fastcluster_8h_source.html#l00077">fastcluster.h:76</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a></div><div class="ttdeci">@ HCLUST_METHOD_MEDIAN</div><div class="ttdef"><b>Definition</b> <a href="fastcluster_8h_source.html#l00074">fastcluster.h:74</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a></div><div class="ttdeci">@ HCLUST_METHOD_SINGLE</div><div class="ttdef"><b>Definition</b> <a href="fastcluster_8h_source.html#l00068">fastcluster.h:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7588578735679773493ff2d5e458e1" name="a0d7588578735679773493ff2d5e458e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7588578735679773493ff2d5e458e1">&#9670;&#160;</a></span>increaseStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::increaseStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the stack size limit. </p>
<p>Increase stack size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00229">229</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  230</span>{</div>
<div class="line"><span class="lineno">  231</span>    <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rlim_t</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">kStackSize</a> = 256L * 1024L * 1024L;   <span class="comment">// min stack size = 256 Mb</span></div>
<div class="line"><span class="lineno">  232</span>    <span class="keyword">struct </span><a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rlimit</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rl</a>;</div>
<div class="line"><span class="lineno">  233</span>    <span class="keywordtype">int</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">getrlimit</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">RLIMIT_STACK</a>, &amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rl</a>);</div>
<div class="line"><span class="lineno">  234</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> == 0)</div>
<div class="line"><span class="lineno">  235</span>    {</div>
<div class="line"><span class="lineno">  236</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rl</a>.rlim_cur &lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">kStackSize</a>)</div>
<div class="line"><span class="lineno">  237</span>        {</div>
<div class="line"><span class="lineno">  238</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rl</a>.rlim_cur = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">kStackSize</a>;</div>
<div class="line"><span class="lineno">  239</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">setrlimit</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">RLIMIT_STACK</a>, &amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">rl</a>);</div>
<div class="line"><span class="lineno">  240</span>            <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">result</a> != 0)</div>
<div class="line"><span class="lineno">  241</span>                <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">writeWrnMsg</a>(<span class="stringliteral">&quot;setrlimit returned result !=0 \n&quot;</span>);</div>
<div class="line"><span class="lineno">  242</span>        }</div>
<div class="line"><span class="lineno">  243</span>    }</div>
<div class="line"><span class="lineno">  244</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeecfaf26800dcebf0b079395126bc7f7" name="aeecfaf26800dcebf0b079395126bc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecfaf26800dcebf0b079395126bc7f7">&#9670;&#160;</a></span>insertKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into a Set/CondSet (with ::insert). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00232">232</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  233</span>{</div>
<div class="line"><span class="lineno">  234</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>.insert(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>);</div>
<div class="line"><span class="lineno">  235</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f75b8313eb2b1e5a4c798a01cb99471" name="a4f75b8313eb2b1e5a4c798a01cb99471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f75b8313eb2b1e5a4c798a01cb99471">&#9670;&#160;</a></span>insertKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a NodeID into a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00238">238</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  239</span>{</div>
<div class="line"><span class="lineno">  240</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>.set(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>);</div>
<div class="line"><span class="lineno">  241</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c8cbc986cccb9d84f87aae162df3737" name="a5c8cbc986cccb9d84f87aae162df3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8cbc986cccb9d84f87aae162df3737">&#9670;&#160;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">class</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00241">241</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  242</span>{</div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">return</span> <a class="code hl_struct" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">isa_impl_wrap</a>&lt;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">X</a>, <span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a>,</div>
<div class="line"><span class="lineno">  244</span>           <span class="keyword">typename</span> <a class="code hl_typedef" href="structSVF_1_1SVFUtil_1_1simplify__type.html#a40c0d9a74681d3eaa7172ba137d489e4">simplify_type&lt;const Y&gt;::SimpleType</a>&gt;::doit(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>);</div>
<div class="line"><span class="lineno">  245</span>}</div>
<div class="ttc" id="astructSVF_1_1SVFUtil_1_1isa__impl__wrap_html"><div class="ttname"><a href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">SVF::SVFUtil::isa_impl_wrap</a></div><div class="ttdef"><b>Definition</b> <a href="Casting_8h_source.html#l00213">Casting.h:214</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a13729076054a2977670b05a338a6763d" name="a13729076054a2977670b05a338a6763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13729076054a2977670b05a338a6763d">&#9670;&#160;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">First</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Second</a> , typename... Rest, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Y</a> &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00248">248</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  249</span>{</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">return</span> SVFUtil::isa&lt;First&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>) || SVFUtil::isa&lt;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Second</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Rest</a>...&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Val</a>);</div>
<div class="line"><span class="lineno">  251</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bf54f0e0bd3a1171fd89719375b55be" name="a8bf54f0e0bd3a1171fd89719375b55be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf54f0e0bd3a1171fd89719375b55be">&#9670;&#160;</a></span>isArgOfUncalledFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isArgOfUncalledFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1SVFVar.html">SVFVar</a> *&#160;</td>
          <td class="paramname"><em>svfvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00422">422</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  423</span>{</div>
<div class="line"><span class="lineno">  424</span>    <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1ValVar.html">ValVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pVar</a> = <a class="code hl_function" href="classSVF_1_1SVFIR.html#acdb6795e102e7c03a61b7a4d2044c348">PAG::getPAG</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFIR.html#ad7ddcc528fd896c7850c8dd0ec03741d">getBaseValVar</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">svfvar</a>-&gt;getId());</div>
<div class="line"><span class="lineno">  425</span>    <span class="keywordflow">if</span>(<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1ArgValVar.html">ArgValVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a> = SVFUtil::dyn_cast&lt;ArgValVar&gt;(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pVar</a>))</div>
<div class="line"><span class="lineno">  426</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">arg</a>-&gt;isArgOfUncalledFunction();</div>
<div class="line"><span class="lineno">  427</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  428</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  429</span>}</div>
<div class="ttc" id="aclassSVF_1_1ArgValVar_html"><div class="ttname"><a href="classSVF_1_1ArgValVar.html">SVF::ArgValVar</a></div><div class="ttdoc">Class representing a function argument variable in the SVFIR.</div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00353">SVFVariables.h:354</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFIR_html_ad7ddcc528fd896c7850c8dd0ec03741d"><div class="ttname"><a href="classSVF_1_1SVFIR.html#ad7ddcc528fd896c7850c8dd0ec03741d">SVF::SVFIR::getBaseValVar</a></div><div class="ttdeci">const ValVar * getBaseValVar(NodeID id) const</div><div class="ttdef"><b>Definition</b> <a href="SVFIR_8h_source.html#l00433">SVFIR.h:433</a></div></div>
<div class="ttc" id="aclassSVF_1_1ValVar_html"><div class="ttname"><a href="classSVF_1_1ValVar.html">SVF::ValVar</a></div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00247">SVFVariables.h:248</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a34f0066d96179c6d7e9a1e42608ecb73" name="a34f0066d96179c6d7e9a1e42608ecb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f0066d96179c6d7e9a1e42608ecb73">&#9670;&#160;</a></span>isBarrierWaitCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a barrier wait call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00400">400</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  401</span>{</div>
<div class="line"><span class="lineno">  402</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(cs);</div>
<div class="line"><span class="lineno">  403</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac69f286ff865a778dc2af5410ed9b24e" name="ac69f286ff865a778dc2af5410ed9b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69f286ff865a778dc2af5410ed9b24e">&#9670;&#160;</a></span>isCallSite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00316">316</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  317</span>{</div>
<div class="line"><span class="lineno">  318</span>    <span class="keywordflow">return</span> SVFUtil::isa&lt;CallICFGNode&gt;(inst);</div>
<div class="line"><span class="lineno">  319</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2d203b5b7749ce51583d39a503407db" name="aa2d203b5b7749ce51583d39a503407db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d203b5b7749ce51583d39a503407db">&#9670;&#160;</a></span>isExtCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00334">334</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  335</span>{</div>
<div class="line"><span class="lineno">  336</span>    <span class="keywordflow">return</span> isExtCall(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  337</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6b83d34488eaa1d6613568dd8394bdd" name="aa6b83d34488eaa1d6613568dd8394bdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b83d34488eaa1d6613568dd8394bdd">&#9670;&#160;</a></span>isExtCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the call is an external call (external library in function summary table) If the library function is redefined in the application code (e.g., memcpy), it will return false and will not be treated as an external call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00437">437</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  438</span>{</div>
<div class="line"><span class="lineno">  439</span>    <span class="keywordflow">return</span> fun &amp;&amp; <a class="code hl_function" href="classSVF_1_1ExtAPI.html#a58a764c27354d5f9b70995d30de65f1d">ExtAPI::getExtAPI</a>()-&gt;<a class="code hl_function" href="classSVF_1_1ExtAPI.html#a5e4aade6ff82863a92787be612776707">is_ext</a>(fun);</div>
<div class="line"><span class="lineno">  440</span>}</div>
<div class="ttc" id="aclassSVF_1_1ExtAPI_html_a58a764c27354d5f9b70995d30de65f1d"><div class="ttname"><a href="classSVF_1_1ExtAPI.html#a58a764c27354d5f9b70995d30de65f1d">SVF::ExtAPI::getExtAPI</a></div><div class="ttdeci">static ExtAPI * getExtAPI()</div><div class="ttdef"><b>Definition</b> <a href="ExtAPI_8cpp_source.html#l00043">ExtAPI.cpp:43</a></div></div>
<div class="ttc" id="aclassSVF_1_1ExtAPI_html_a5e4aade6ff82863a92787be612776707"><div class="ttname"><a href="classSVF_1_1ExtAPI.html#a5e4aade6ff82863a92787be612776707">SVF::ExtAPI::is_ext</a></div><div class="ttdeci">bool is_ext(const FunObjVar *funObjVar)</div><div class="ttdef"><b>Definition</b> <a href="ExtAPI_8cpp_source.html#l00257">ExtAPI.cpp:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f888dfee60a63eb0711fcdd63430e8f" name="a3f888dfee60a63eb0711fcdd63430e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f888dfee60a63eb0711fcdd63430e8f">&#9670;&#160;</a></span>isExtCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00351">351</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  352</span>{</div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">if</span>(!isCallSite(node)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  354</span>    <span class="keywordflow">return</span> isExtCall(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">cast&lt;CallICFGNode&gt;</a>(node)-&gt;getCalledFunction());</div>
<div class="line"><span class="lineno">  355</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85b308e08dd0837b9401ada40349ac32" name="a85b308e08dd0837b9401ada40349ac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b308e08dd0837b9401ada40349ac32">&#9670;&#160;</a></span>isHeapAllocExtCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00357">357</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  358</span>{</div>
<div class="line"><span class="lineno">  359</span>    <span class="keywordflow">if</span>(!isCallSite(cs)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  360</span>    <span class="keywordflow">return</span> isHeapAllocExtCallViaRet(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">cast&lt;CallICFGNode&gt;</a>(cs)) || isHeapAllocExtCallViaArg(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">cast&lt;CallICFGNode&gt;</a>(cs));</div>
<div class="line"><span class="lineno">  361</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a83a75e8eda99da5d45ccf0188e2d876d" name="a83a75e8eda99da5d45ccf0188e2d876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a75e8eda99da5d45ccf0188e2d876d">&#9670;&#160;</a></span>isHeapAllocExtCallViaArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00339">339</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  340</span>{</div>
<div class="line"><span class="lineno">  341</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#a58a9663da66e3a2226058e57356d3d8f">isHeapAllocExtFunViaArg</a>(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  342</span>}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a58a9663da66e3a2226058e57356d3d8f"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a58a9663da66e3a2226058e57356d3d8f">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const FunObjVar *fun)</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00285">SVFUtil.h:285</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb3bde29364d65428ee2c4eb22063828" name="aeb3bde29364d65428ee2c4eb22063828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3bde29364d65428ee2c4eb22063828">&#9670;&#160;</a></span>isHeapAllocExtCallViaRet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interfaces to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00363">363</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  364</span>{</div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isPtrTy</a> = cs-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a66658e192dd21a3b4ad9b787d8ea2e59">getType</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">isPointerTy</a>();</div>
<div class="line"><span class="lineno">  366</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isPtrTy</a> &amp;&amp; <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#a3e3e7c8b2fead4dfccfae74207e3fac5">isHeapAllocExtFunViaRet</a>(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  367</span>}</div>
<div class="ttc" id="aclassSVF_1_1SVFType_html_a870b63af2bf9fe43cdf1df3d56b20f6c"><div class="ttname"><a href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">SVF::SVFType::isPointerTy</a></div><div class="ttdeci">bool isPointerTy() const</div><div class="ttdef"><b>Definition</b> <a href="SVFType_8h_source.html#l00249">SVFType.h:249</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFValue_html_a66658e192dd21a3b4ad9b787d8ea2e59"><div class="ttname"><a href="classSVF_1_1SVFValue.html#a66658e192dd21a3b4ad9b787d8ea2e59">SVF::SVFValue::getType</a></div><div class="ttdeci">virtual const SVFType * getType() const</div><div class="ttdef"><b>Definition</b> <a href="SVFValue_8h_source.html#l00169">SVFValue.h:169</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a3e3e7c8b2fead4dfccfae74207e3fac5"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a3e3e7c8b2fead4dfccfae74207e3fac5">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const FunObjVar *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00279">SVFUtil.h:279</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a58a9663da66e3a2226058e57356d3d8f" name="a58a9663da66e3a2226058e57356d3d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a9663da66e3a2226058e57356d3d8f">&#9670;&#160;</a></span>isHeapAllocExtFunViaArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isHeapAllocExtFunViaArg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00285">285</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  286</span>{</div>
<div class="line"><span class="lineno">  287</span>    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_arg_alloc(fun);</div>
<div class="line"><span class="lineno">  288</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3e3e7c8b2fead4dfccfae74207e3fac5" name="a3e3e7c8b2fead4dfccfae74207e3fac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e7c8b2fead4dfccfae74207e3fac5">&#9670;&#160;</a></span>isHeapAllocExtFunViaRet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isHeapAllocExtFunViaRet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap allocator/reallocator. </p>
<p>note that these two functions are not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00279">279</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  280</span>{</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_alloc(fun)</div>
<div class="line"><span class="lineno">  282</span>                   || ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div>
<div class="line"><span class="lineno">  283</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a2b3538ed321e5fa17b98e01c9175fc" name="a1a2b3538ed321e5fa17b98e01c9175fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2b3538ed321e5fa17b98e01c9175fc">&#9670;&#160;</a></span>isIntrinsicInst()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isIntrinsicInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is an llvm intrinsic instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00321">321</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  322</span>{</div>
<div class="line"><span class="lineno">  323</span>    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a>* call = SVFUtil::dyn_cast&lt;CallICFGNode&gt;(inst))</div>
<div class="line"><span class="lineno">  324</span>    {</div>
<div class="line"><span class="lineno">  325</span>        <span class="keyword">const</span> <a class="code hl_class" href="classSVF_1_1FunObjVar.html">FunObjVar</a>* <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">func</a> = call-&gt;getCalledFunction();</div>
<div class="line"><span class="lineno">  326</span>        <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">func</a> &amp;&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">func</a>-&gt;isIntrinsic())</div>
<div class="line"><span class="lineno">  327</span>        {</div>
<div class="line"><span class="lineno">  328</span>            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  329</span>        }</div>
<div class="line"><span class="lineno">  330</span>    }</div>
<div class="line"><span class="lineno">  331</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  332</span>}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html">SVF::CallICFGNode</a></div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00416">ICFGNode.h:417</a></div></div>
<div class="ttc" id="aclassSVF_1_1FunObjVar_html"><div class="ttname"><a href="classSVF_1_1FunObjVar.html">SVF::FunObjVar</a></div><div class="ttdef"><b>Definition</b> <a href="SVFVariables_8h_source.html#l00953">SVFVariables.h:954</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a191cbe16e7e32dd136cff438752b3029" name="a191cbe16e7e32dd136cff438752b3029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191cbe16e7e32dd136cff438752b3029">&#9670;&#160;</a></span>isLockAquireCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00384">384</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  385</span>{</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(cs);</div>
<div class="line"><span class="lineno">  387</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abaa7be6fe5d9c277583eaeab46282b62" name="abaa7be6fe5d9c277583eaeab46282b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa7be6fe5d9c277583eaeab46282b62">&#9670;&#160;</a></span>isLockReleaseCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00392">392</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  393</span>{</div>
<div class="line"><span class="lineno">  394</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(cs);</div>
<div class="line"><span class="lineno">  395</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a86b337f84cae7ae0ec4597b077aee08c" name="a86b337f84cae7ae0ec4597b077aee08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b337f84cae7ae0ec4597b077aee08c">&#9670;&#160;</a></span>isNonInstricCallSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isNonInstricCallSite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00182">182</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  183</span>{</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">if</span>(isIntrinsicInst(inst))</div>
<div class="line"><span class="lineno">  185</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  186</span>    <span class="keywordflow">return</span> isCallSite(inst);</div>
<div class="line"><span class="lineno">  187</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1071e5fd17b686b62d37f11a848d731c" name="a1071e5fd17b686b62d37f11a848d731c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1071e5fd17b686b62d37f11a848d731c">&#9670;&#160;</a></span>isProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>funObjVar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program entry function e.g. main. </p>
<p>Return true if this is a program entry function (e.g. main) </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00442">442</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  443</span>{</div>
<div class="line"><span class="lineno">  444</span>    <span class="keywordflow">return</span> funObjVar &amp;&amp; funObjVar-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a80044bf8c6eebee7cbe2d6d3abfa3732">getName</a>() == <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line"><span class="lineno">  445</span>}</div>
<div class="ttc" id="aclassSVF_1_1SVFValue_html_a80044bf8c6eebee7cbe2d6d3abfa3732"><div class="ttname"><a href="classSVF_1_1SVFValue.html#a80044bf8c6eebee7cbe2d6d3abfa3732">SVF::SVFValue::getName</a></div><div class="ttdeci">virtual const std::string &amp; getName() const</div><div class="ttdef"><b>Definition</b> <a href="SVFValue_8h_source.html#l00184">SVFValue.h:184</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6586774af88b61f367ba43d126f38ac" name="ac6586774af88b61f367ba43d126f38ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6586774af88b61f367ba43d126f38ac">&#9670;&#160;</a></span>isProgExitCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00391">391</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  392</span>{</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#af78e36235204eb1e16394ee5c37f947d">isProgExitFunction</a>(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  394</span>}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_af78e36235204eb1e16394ee5c37f947d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#af78e36235204eb1e16394ee5c37f947d">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const FunObjVar *fun)</div><div class="ttdoc">Return true if this is a program exit function call.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00384">SVFUtil.cpp:384</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af78e36235204eb1e16394ee5c37f947d" name="af78e36235204eb1e16394ee5c37f947d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78e36235204eb1e16394ee5c37f947d">&#9670;&#160;</a></span>isProgExitFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isProgExitFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is a program exit function call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00384">384</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  385</span>{</div>
<div class="line"><span class="lineno">  386</span>    <span class="keywordflow">return</span> fun &amp;&amp; (fun-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a80044bf8c6eebee7cbe2d6d3abfa3732">getName</a>() == <span class="stringliteral">&quot;exit&quot;</span> ||</div>
<div class="line"><span class="lineno">  387</span>                   fun-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a80044bf8c6eebee7cbe2d6d3abfa3732">getName</a>() == <span class="stringliteral">&quot;__assert_rtn&quot;</span> ||</div>
<div class="line"><span class="lineno">  388</span>                   fun-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a80044bf8c6eebee7cbe2d6d3abfa3732">getName</a>() == <span class="stringliteral">&quot;__assert_fail&quot;</span>);</div>
<div class="line"><span class="lineno">  389</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01f4cd58f733d71c9bbd7dcc40194c0b" name="a01f4cd58f733d71c9bbd7dcc40194c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f4cd58f733d71c9bbd7dcc40194c0b">&#9670;&#160;</a></span>isReallocExtCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00369">369</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  370</span>{</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordtype">bool</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isPtrTy</a> = cs-&gt;<a class="code hl_function" href="classSVF_1_1SVFValue.html#a66658e192dd21a3b4ad9b787d8ea2e59">getType</a>()-&gt;<a class="code hl_function" href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">isPointerTy</a>();</div>
<div class="line"><span class="lineno">  372</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">isPtrTy</a> &amp;&amp; <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#acecc9c27333b0e7ed3e222207dc735b4">isReallocExtFun</a>(cs-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#a55c4e8d302f61aa9a46ac7daa318b849">getCalledFunction</a>());</div>
<div class="line"><span class="lineno">  373</span>}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_acecc9c27333b0e7ed3e222207dc735b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#acecc9c27333b0e7ed3e222207dc735b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const FunObjVar *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8h_source.html#l00301">SVFUtil.h:301</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="acecc9c27333b0e7ed3e222207dc735b4" name="acecc9c27333b0e7ed3e222207dc735b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc9c27333b0e7ed3e222207dc735b4">&#9670;&#160;</a></span>isReallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isReallocExtFun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap reallocator. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00301">301</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  302</span>{</div>
<div class="line"><span class="lineno">  303</span>    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div>
<div class="line"><span class="lineno">  304</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4bd7753901074b660eda3166180a356" name="ad4bd7753901074b660eda3166180a356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bd7753901074b660eda3166180a356">&#9670;&#160;</a></span>isRetInstNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isRetInstNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00376">376</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  377</span>{</div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">intraNode</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">dyn_cast&lt;IntraICFGNode&gt;</a>(node))</div>
<div class="line"><span class="lineno">  379</span>        <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">intraNode</a>-&gt;isRetInst();</div>
<div class="line"><span class="lineno">  380</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  381</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  382</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1b7843d49df58cf1bf3725076702c07" name="ac1b7843d49df58cf1bf3725076702c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b7843d49df58cf1bf3725076702c07">&#9670;&#160;</a></span>isThreadExitCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread exit call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00376">376</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  377</span>{</div>
<div class="line"><span class="lineno">  378</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(cs);</div>
<div class="line"><span class="lineno">  379</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac9a03aaeb26832c69f95a9a96a2d31a" name="aac9a03aaeb26832c69f95a9a96a2d31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9a03aaeb26832c69f95a9a96a2d31a">&#9670;&#160;</a></span>isThreadForkCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread creation call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00360">360</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  361</span>{</div>
<div class="line"><span class="lineno">  362</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(inst);</div>
<div class="line"><span class="lineno">  363</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a86c79a20405d3a31b309a14bd68f1166" name="a86c79a20405d3a31b309a14bd68f1166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c79a20405d3a31b309a14bd68f1166">&#9670;&#160;</a></span>isThreadJoinCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread join call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00368">368</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  369</span>{</div>
<div class="line"><span class="lineno">  370</span>    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(cs);</div>
<div class="line"><span class="lineno">  371</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aae911c0261d0a35cbae8a3cce294ba10" name="aae911c0261d0a35cbae8a3cce294ba10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae911c0261d0a35cbae8a3cce294ba10">&#9670;&#160;</a></span>matchArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::matchArgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1FunObjVar.html">FunObjVar</a> *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match arguments for callsite at caller and callee if the arg size does not match then we do not need to connect this parameter unless the callee is a variadic function (the first parameter of variadic function is its parameter number)</p>
<p>Match arguments for callsite at caller and callee if the arg size does not match then we do not need to connect this parameter unless the callee is a variadic function (the first parameter of variadic function is its parameter number) e.g., void <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">variadicFoo(int num, ...)</a>; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">variadicFoo(5, 1,2,3,4,5)</a> for variadic function, callsite arg size must be greater than or equal to callee arg size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00308">308</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  309</span>{</div>
<div class="line"><span class="lineno">  310</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callee</a>-&gt;isVarArg() || <a class="code hl_function" href="classSVF_1_1ThreadAPI.html#ac9ed9694b46f68c972beb43724c07c51">ThreadAPI::getThreadAPI</a>()-&gt;<a class="code hl_function" href="classSVF_1_1ThreadAPI.html#a22ab1079dd72f743cd15bd5982628a31">isTDFork</a>(call))</div>
<div class="line"><span class="lineno">  311</span>        <span class="keywordflow">return</span> call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">arg_size</a>() &gt;= <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callee</a>-&gt;arg_size();</div>
<div class="line"><span class="lineno">  312</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  313</span>        <span class="keywordflow">return</span> call-&gt;<a class="code hl_function" href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">arg_size</a>() == <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">callee</a>-&gt;arg_size();</div>
<div class="line"><span class="lineno">  314</span>}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_ada0b68a709fde6d41a5e067b87642937"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">SVF::CallICFGNode::arg_size</a></div><div class="ttdeci">u32_t arg_size() const</div><div class="ttdef"><b>Definition</b> <a href="ICFGNode_8h_source.html#l00499">ICFGNode.h:499</a></div></div>
<div class="ttc" id="aclassSVF_1_1ThreadAPI_html_a22ab1079dd72f743cd15bd5982628a31"><div class="ttname"><a href="classSVF_1_1ThreadAPI.html#a22ab1079dd72f743cd15bd5982628a31">SVF::ThreadAPI::isTDFork</a></div><div class="ttdeci">bool isTDFork(const CallICFGNode *inst) const</div><div class="ttdoc">Return true if this call create a new thread.</div><div class="ttdef"><b>Definition</b> <a href="ThreadAPI_8cpp_source.html#l00145">ThreadAPI.cpp:145</a></div></div>
<div class="ttc" id="aclassSVF_1_1ThreadAPI_html_ac9ed9694b46f68c972beb43724c07c51"><div class="ttname"><a href="classSVF_1_1ThreadAPI.html#ac9ed9694b46f68c972beb43724c07c51">SVF::ThreadAPI::getThreadAPI</a></div><div class="ttdeci">static ThreadAPI * getThreadAPI()</div><div class="ttdoc">Return a static reference.</div><div class="ttdef"><b>Definition</b> <a href="ThreadAPI_8h_source.html#l00098">ThreadAPI.h:98</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36c91f952a69875c33d4bd0b05a27ff2" name="a36c91f952a69875c33d4bd0b05a27ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c91f952a69875c33d4bd0b05a27ff2">&#9670;&#160;</a></span>mergePtsOccMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::mergePtsOccMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Data</a>, <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a> &gt;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a map mapping points-to sets to a count, adds from into to. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00219">219</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  220</span>{</div>
<div class="line"><span class="lineno">  221</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code hl_typedef" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map&lt;Data, unsigned&gt;::value_type</a> &amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptocc</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">from</a>)</div>
<div class="line"><span class="lineno">  222</span>    {</div>
<div class="line"><span class="lineno">  223</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">to</a>[<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptocc</a>.first] += <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">ptocc</a>.second;</div>
<div class="line"><span class="lineno">  224</span>    }</div>
<div class="line"><span class="lineno">  225</span>}</div>
<div class="ttc" id="anamespaceSVF_html_a8234d4b959abc9123993bcff4eee34c1"><div class="ttname"><a href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">SVF::Map</a></div><div class="ttdeci">std::unordered_map&lt; Key, Value, Hash, KeyEqual, Allocator &gt; Map</div><div class="ttdef"><b>Definition</b> <a href="GeneralType_8h_source.html#l00101">GeneralType.h:101</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae83719194c43227aecd0642ce9e988bf" name="ae83719194c43227aecd0642ce9e988bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83719194c43227aecd0642ce9e988bf">&#9670;&#160;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> std::remove_reference&lt; <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt;<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">::type</a> &amp;&amp; SVF::SVFUtil::move </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00420">420</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  421</span>{</div>
<div class="line"><span class="lineno">  422</span>    <span class="keywordflow">return</span> std::move(t);</div>
<div class="line"><span class="lineno">  423</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8b432d1a6e3f8ddd7a3505f7b7a8cd3" name="ad8b432d1a6e3f8ddd7a3505f7b7a8cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">&#9670;&#160;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; SVF::SVFUtil::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite llvm::outs() </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00052">52</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   53</span>{</div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordflow">return</span> std::cout;</div>
<div class="line"><span class="lineno">   55</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4550f2fb815882edfb666ac818792064" name="a4550f2fb815882edfb666ac818792064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4550f2fb815882edfb666ac818792064">&#9670;&#160;</a></span>pasMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::pasMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each pass/phase message by converting a string into blue string output. </p>
<p>print each pass/phase message by converting a string into blue string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00101">101</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  102</span>{</div>
<div class="line"><span class="lineno">  103</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">  104</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a3f838f2fc3a9a3b434be606fc908964b"><div class="ttname"><a href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a></div><div class="ttdeci">#define KBLU</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00045">SVFUtil.cpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86ebab122895189be57637b84adc7642" name="a86ebab122895189be57637b84adc7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebab122895189be57637b84adc7642">&#9670;&#160;</a></span>ptsToNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> SVF::SVFUtil::ptsToNodeBS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00161">161</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  162</span>{</div>
<div class="line"><span class="lineno">  163</span>    <a class="code hl_class" href="classSVF_1_1SparseBitVector.html">NodeBS</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nbs</a>;</div>
<div class="line"><span class="lineno">  164</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code hl_typedef" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">o</a> : <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pts</a>) <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nbs</a>.<a class="code hl_function" href="WPA_2CMakeLists_8txt.html#a5b660868031b6dee85d01fea51ef09a5">set</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">o</a>);</div>
<div class="line"><span class="lineno">  165</span>    <span class="keywordflow">return</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">nbs</a>;</div>
<div class="line"><span class="lineno">  166</span>}</div>
<div class="ttc" id="aWPA_2CMakeLists_8txt_html_a5b660868031b6dee85d01fea51ef09a5"><div class="ttname"><a href="WPA_2CMakeLists_8txt.html#a5b660868031b6dee85d01fea51ef09a5">set</a></div><div class="ttdeci">set(THREADS_PREFER_PTHREAD_FLAG ON) find_package(Threads REQUIRED) add_llvm_executable(wpa wpa.cpp) target_link_libraries(wpa PUBLIC $</div><div class="ttdef"><b>Definition</b> <a href="WPA_2CMakeLists_8txt_source.html#l00001">CMakeLists.txt:1</a></div></div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_html"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html">SVF::SparseBitVector</a></div><div class="ttdef"><b>Definition</b> <a href="SparseBitVector_8h_source.html#l00501">SparseBitVector.h:502</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee74719d33695e4da6fee5fc83f745d9" name="aee74719d33695e4da6fee5fc83f745d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74719d33695e4da6fee5fc83f745d9">&#9670;&#160;</a></span>removeKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> , <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">Key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">KeySet</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from a Set/CondSet (or anything implementing <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">erase</a>). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00245">245</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  246</span>{</div>
<div class="line"><span class="lineno">  247</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>.erase(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>);</div>
<div class="line"><span class="lineno">  248</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa59af7fc01a534662b3b1524186ef97e" name="aa59af7fc01a534662b3b1524186ef97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59af7fc01a534662b3b1524186ef97e">&#9670;&#160;</a></span>removeKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a NodeID from a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00251">251</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  252</span>{</div>
<div class="line"><span class="lineno">  253</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">keySet</a>.reset(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">key</a>);</div>
<div class="line"><span class="lineno">  254</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cfe12afa463d0ceddeee11540c33ab3" name="a6cfe12afa463d0ceddeee11540c33ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe12afa463d0ceddeee11540c33ab3">&#9670;&#160;</a></span>reportMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::reportMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>infor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print memory usage in KB. </p>
<p>Print memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00169">169</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  170</span>{</div>
<div class="line"><span class="lineno">  171</span>    <a class="code hl_typedef" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmrss</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmsize</a>;</div>
<div class="line"><span class="lineno">  172</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a>(&amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmrss</a>, &amp;<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmsize</a>))</div>
<div class="line"><span class="lineno">  173</span>        O &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">infor</a> &lt;&lt; <span class="stringliteral">&quot;\tVmRSS: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmrss</a> &lt;&lt; <span class="stringliteral">&quot;\tVmSize: &quot;</span> &lt;&lt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">vmsize</a> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">  174</span>}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a630ff9c47f58f9b8df7c8a2b3711477c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a></div><div class="ttdeci">bool getMemoryUsageKB(u32_t *vmrss_kb, u32_t *vmsize_kb)</div><div class="ttdoc">Get memory usage from system file. Return TRUE if succeed.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00179">SVFUtil.cpp:179</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af3c71fedd13e67b220b669c1697684e3" name="af3c71fedd13e67b220b669c1697684e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c71fedd13e67b220b669c1697684e3">&#9670;&#160;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; SVF::SVFUtil::split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">char</a>&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00196">196</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  197</span>{</div>
<div class="line"><span class="lineno">  198</span>    std::vector&lt;std::string&gt; <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">output</a>;</div>
<div class="line"><span class="lineno">  199</span>    std::string::size_type <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">prev_pos</a> = 0, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pos</a> = 0;</div>
<div class="line"><span class="lineno">  200</span>    <span class="keywordflow">while</span> ((<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pos</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">s</a>.find(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">separator</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pos</a>)) != std::string::npos)</div>
<div class="line"><span class="lineno">  201</span>    {</div>
<div class="line"><span class="lineno">  202</span>        std::string <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">substring</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">s</a>.substr(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">prev_pos</a>, <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pos</a> - <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">prev_pos</a>));</div>
<div class="line"><span class="lineno">  203</span>        <span class="keywordflow">if</span> (!<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">substring</a>.empty())</div>
<div class="line"><span class="lineno">  204</span>        {</div>
<div class="line"><span class="lineno">  205</span>            <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">output</a>.push_back(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">substring</a>);</div>
<div class="line"><span class="lineno">  206</span>        }</div>
<div class="line"><span class="lineno">  207</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">prev_pos</a> = ++<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">pos</a>;</div>
<div class="line"><span class="lineno">  208</span>    }</div>
<div class="line"><span class="lineno">  209</span>    std::string lastSubstring(s.substr(prev_pos, pos - prev_pos));</div>
<div class="line"><span class="lineno">  210</span>    <span class="keywordflow">if</span> (!lastSubstring.empty())</div>
<div class="line"><span class="lineno">  211</span>    {</div>
<div class="line"><span class="lineno">  212</span>        output.push_back(lastSubstring);</div>
<div class="line"><span class="lineno">  213</span>    }</div>
<div class="line"><span class="lineno">  214</span>    <span class="keywordflow">return</span> output;</div>
<div class="line"><span class="lineno">  215</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a757815a2c758695176120509ceb0ce70" name="a757815a2c758695176120509ceb0ce70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757815a2c758695176120509ceb0ce70">&#9670;&#160;</a></span>startAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::startAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">unsigned</a>&#160;</td>
          <td class="paramname"><em>timeLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an analysis timer. If timeLimit is 0, sets no timer. If an alarm has already been set, does not set another. Returns whether we set a timer or not. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00277">277</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  278</span>{</div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">timeLimit</a> == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>    <span class="comment">// If an alarm is already set, don&#39;t set another. That means this analysis</span></div>
<div class="line"><span class="lineno">  282</span>    <span class="comment">// is part of another which has a time limit.</span></div>
<div class="line"><span class="lineno">  283</span>    <span class="keywordtype">unsigned</span> <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">remainingSeconds</a> = <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">alarm</a>(0);</div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">remainingSeconds</a> != 0)</div>
<div class="line"><span class="lineno">  285</span>    {</div>
<div class="line"><span class="lineno">  286</span>        <span class="comment">// Continue the previous alarm and move on.</span></div>
<div class="line"><span class="lineno">  287</span>        <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">alarm</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">remainingSeconds</a>);</div>
<div class="line"><span class="lineno">  288</span>        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  289</span>    }</div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">signal</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">SIGALRM</a>, &amp;timeLimitReached);</div>
<div class="line"><span class="lineno">  292</span>    <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">alarm</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">timeLimit</a>);</div>
<div class="line"><span class="lineno">  293</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  294</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a168f7f7a3a8c70dbf2b5b4269cd4c7c5" name="a168f7f7a3a8c70dbf2b5b4269cd4c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">&#9670;&#160;</a></span>stopAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::stopAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a>&#160;</td>
          <td class="paramname"><em>limitTimerSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops an analysis timer. limitTimerSet indicates whether the caller set the timer or not (return value of startLimitTimer). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00298">298</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  299</span>{</div>
<div class="line"><span class="lineno">  300</span>    <span class="keywordflow">if</span> (<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">limitTimerSet</a>) <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">alarm</a>(0);</div>
<div class="line"><span class="lineno">  301</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a05dc00b2bd9a8176aae31b6cfffe725d" name="a05dc00b2bd9a8176aae31b6cfffe725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dc00b2bd9a8176aae31b6cfffe725d">&#9670;&#160;</a></span>sucMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::sucMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns successful message by converting a string into green string output. </p>
<p>print successful message by converting a string into green string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00055">55</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   56</span>{</div>
<div class="line"><span class="lineno">   57</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   58</span>}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_ac081c83b067273757f7a2e54a5957d41"><div class="ttname"><a href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a></div><div class="ttdeci">#define KGRN</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00043">SVFUtil.cpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add4cd21115988f9f5eec12e268ddf1d9" name="add4cd21115988f9f5eec12e268ddf1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4cd21115988f9f5eec12e268ddf1d9">&#9670;&#160;</a></span>timeLimitReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::timeLimitReached </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">int</a>&#160;</td>
          <td class="paramname"><em>signum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call when alarm for time limit hits. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00268">268</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  269</span>{</div>
<div class="line"><span class="lineno">  270</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>().flush();</div>
<div class="line"><span class="lineno">  271</span>    <span class="comment">// TODO: output does not indicate which time limit is reached.</span></div>
<div class="line"><span class="lineno">  272</span>    <span class="comment">//       This can be better in the future.</span></div>
<div class="line"><span class="lineno">  273</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">SVFUtil::outs</a>() &lt;&lt; <span class="stringliteral">&quot;WPA: time limit reached\n&quot;</span>;</div>
<div class="line"><span class="lineno">  274</span>    exit(101);</div>
<div class="line"><span class="lineno">  275</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2e0196e0ce547ab4a483cc6d2646b24" name="ab2e0196e0ce547ab4a483cc6d2646b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e0196e0ce547ab4a483cc6d2646b24">&#9670;&#160;</a></span>writeWrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::writeWrnMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message run through wrnMsg. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00068">68</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   69</span>{</div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classSVF_1_1Options.html#a1721ff576ad641d862f29b038f31db28">Options::DisableWarn</a>())</div>
<div class="line"><span class="lineno">   71</span>        <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">   72</span>    <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ad8b432d1a6e3f8ddd7a3505f7b7a8cd3">outs</a>() &lt;&lt; <a class="code hl_function" href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">wrnMsg</a>(<a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a>) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><span class="lineno">   73</span>}</div>
<div class="ttc" id="aclassSVF_1_1Options_html_a1721ff576ad641d862f29b038f31db28"><div class="ttname"><a href="classSVF_1_1Options.html#a1721ff576ad641d862f29b038f31db28">SVF::Options::DisableWarn</a></div><div class="ttdeci">static const Option&lt; bool &gt; DisableWarn</div><div class="ttdef"><b>Definition</b> <a href="Options_8h_source.html#l00206">Options.h:206</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ac71522e8c55f84cfc6c13a0ddff18436"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">SVF::SVFUtil::wrnMsg</a></div><div class="ttdeci">std::string wrnMsg(const std::string &amp;msg)</div><div class="ttdoc">Returns warning message by converting a string into yellow string output.</div><div class="ttdef"><b>Definition</b> <a href="SVFUtil_8cpp_source.html#l00063">SVFUtil.cpp:63</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac71522e8c55f84cfc6c13a0ddff18436" name="ac71522e8c55f84cfc6c13a0ddff18436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71522e8c55f84cfc6c13a0ddff18436">&#9670;&#160;</a></span>wrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string SVF::SVFUtil::wrnMsg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">const</a> std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns warning message by converting a string into yellow string output. </p>
<p>print warning message by converting a string into yellow string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00063">63</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   64</span>{</div>
<div class="line"><span class="lineno">   65</span>    <span class="keywordflow">return</span> <a class="code hl_define" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + <a class="code hl_typedef" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">msg</a> + <a class="code hl_define" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><span class="lineno">   66</span>}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa32219da7a5c3d7517ec5026afdac588" name="aa32219da7a5c3d7517ec5026afdac588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32219da7a5c3d7517ec5026afdac588">&#9670;&#160;</a></span>is_iterable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">typename</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::is_iterable_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a>&lt;<a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">T</a>&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00440">440</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a8c57ab480c497cbd21a49778d0e59bd5" name="a8c57ab480c497cbd21a49778d0e59bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c57ab480c497cbd21a49778d0e59bd5">&#9670;&#160;</a></span>is_map_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::is_map_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00449">449</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a811faa9c2095f44e3e5b6e50aa6f6e06" name="a811faa9c2095f44e3e5b6e50aa6f6e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811faa9c2095f44e3e5b6e50aa6f6e06">&#9670;&#160;</a></span>is_sequence_container_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::is_sequence_container_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00470">470</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a08e67d68b1da116b2c51cb60bdb6dae2" name="a08e67d68b1da116b2c51cb60bdb6dae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e67d68b1da116b2c51cb60bdb6dae2">&#9670;&#160;</a></span>is_set_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">constexpr</a> <a class="el" href="namespaceSVF.html#a94824519e439aeef1568d415b6f7331c">bool</a> SVF::SVFUtil::is_set_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00458">458</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
