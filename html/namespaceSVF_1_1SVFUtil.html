<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Static Value-Flow Analysis: SVF::SVFUtil Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Static Value-Flow Analysis
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSVF.html">SVF</a></li><li class="navelem"><a class="el" href="namespaceSVF_1_1SVFUtil.html">SVFUtil</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SVF::SVFUtil Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__const__past__pointer.html">add_const_past_pointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__const__past__pointer_3_01T_00_01std_1_1enable__if__t_3_01std_1_1is_7fffc8df953a67082a10c9027356ecdf.html">add_const_past_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer.html">add_lvalue_reference_if_not_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If T is a pointer, just return it. If it is not, return T&amp;.  <a href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1add__lvalue__reference__if__not__pointer_3_01T_00_01std_1_1enable__if__t915410d772a4855ec3d21a633a25ee09.html">add_lvalue_reference_if_not_pointer&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type.html">simplify_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1simplify__type_3_01const_01From_01_4.html">simplify_type&lt; const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl.html">isa_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__baseacbe8554d65d479d86c5b7d994311309.html">isa_impl&lt; To, From, std::enable_if_t&lt; std::is_base_of&lt; To, From &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always allow upcasts, and perform no dynamic check for them.  <a href="structSVF_1_1SVFUtil_1_1isa__impl_3_01To_00_01From_00_01std_1_1enable__if__t_3_01std_1_1is__baseacbe8554d65d479d86c5b7d994311309.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl.html">isa_impl_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_4.html">isa_impl_cl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01std_1_1unique__ptr_3_01From_01_4_01_4.html">isa_impl_cl&lt; To, const std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5_01_4.html">isa_impl_cl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01From_01_5const_01_4.html">isa_impl_cl&lt; To, From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5_01_4.html">isa_impl_cl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__cl_3_01To_00_01const_01From_01_5const_01_4.html">isa_impl_cl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap.html">isa_impl_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1isa__impl__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">isa_impl_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl.html">cast_retty_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_4.html">cast_retty_impl&lt; To, const From &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01From_01_5_01_4.html">cast_retty_impl&lt; To, From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5_01_4.html">cast_retty_impl&lt; To, const From * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01const_01From_01_5const_01_4.html">cast_retty_impl&lt; To, const From *const &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__impl_3_01To_00_01std_1_1unique__ptr_3_01From_01_4_01_4.html">cast_retty_impl&lt; To, std::unique_ptr&lt; From &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap.html">cast_retty_wrap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty__wrap_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_retty_wrap&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val.html">cast_convert_val</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__convert__val_3_01To_00_01FromTy_00_01FromTy_01_4.html">cast_convert_val&lt; To, FromTy, FromTy &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">equalNodeBS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">void_t is not available until C++17. We define it here for C++11/14.  <a href="structSVF_1_1SVFUtil_1_1make__void.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait that checks if a type is iterable (can be applied on a range-based for loop)  <a href="structSVF_1_1SVFUtil_1_1is__iterable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable_3_01T_00_01void__t_3_01decltype_07std_1_1begin_07std_1_1dec794949348c8e1e00603fd8633b6dd1f3.html">is_iterable&lt; T, void_t&lt; decltype(std::begin(std::declval&lt; T &amp; &gt;()) !=std::end(std::declval&lt; T &amp; &gt;()))&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a map or unordered_map.  <a href="structSVF_1_1SVFUtil_1_1is__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1map_3_01Ts_8_8_8_01_4_01_4.html">is_map&lt; std::map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__map_3_01std_1_1unordered__map_3_01Ts_8_8_8_01_4_01_4.html">is_map&lt; std::unordered_map&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is a set or unordered_set.  <a href="structSVF_1_1SVFUtil_1_1is__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1set_3_01Ts_8_8_8_01_4_01_4.html">is_set&lt; std::set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__set_3_01std_1_1unordered__set_3_01Ts_8_8_8_01_4_01_4.html">is_set&lt; std::unordered_set&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type trait to check if a type is vector or list.  <a href="structSVF_1_1SVFUtil_1_1is__sequence__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1vector_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::vector&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1deque_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::deque&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container_3_01std_1_1list_3_01Ts_8_8_8_01_4_01_4.html">is_sequence_container&lt; std::list&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac047d963ed4b701c83958868ab36202f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac047d963ed4b701c83958868ab36202f">equalPointsTo</a></td></tr>
<tr class="separator:ac047d963ed4b701c83958868ab36202f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66b86171786cc34b798f05f67f321e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acb66b86171786cc34b798f05f67f321e">equalNodeBS</a></td></tr>
<tr class="separator:acb66b86171786cc34b798f05f67f321e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt; <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a></td></tr>
<tr class="separator:a4740b14abf7d308e7806a0d6d6c42ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a5c8cbc986cccb9d84f87aae162df3737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5c8cbc986cccb9d84f87aae162df3737">isa</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a5c8cbc986cccb9d84f87aae162df3737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13729076054a2977670b05a338a6763d"><td class="memTemplParams" colspan="2">template&lt;typename First , typename Second , typename... Rest, typename Y &gt; </td></tr>
<tr class="memitem:a13729076054a2977670b05a338a6763d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a13729076054a2977670b05a338a6763d">isa</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a13729076054a2977670b05a338a6763d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ddf7041e685da8ede81cd773dd47761"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a3ddf7041e685da8ede81cd773dd47761"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3ddf7041e685da8ede81cd773dd47761">cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:a3ddf7041e685da8ede81cd773dd47761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a406dd9baf2ce66235d482fd6c6121b2c">cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a406dd9baf2ce66235d482fd6c6121b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:acc2419a55c0427571f11ad14db2fe481"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acc2419a55c0427571f11ad14db2fe481">cast</a> (Y *Val)</td></tr>
<tr class="separator:acc2419a55c0427571f11ad14db2fe481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, std::unique_ptr&lt; Y &gt; &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af3ca049b4ce83c874e231f5e13bf36a8">cast</a> (std::unique_ptr&lt; Y &gt; &amp;&amp;Val)</td></tr>
<tr class="separator:af3ca049b4ce83c874e231f5e13bf36a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e96694d983643a66c238cce01bff0e"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:af6e96694d983643a66c238cce01bff0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt; Y &gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, const Y &gt;::ret_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af6e96694d983643a66c238cce01bff0e">dyn_cast</a> (const Y &amp;Val)</td></tr>
<tr class="separator:af6e96694d983643a66c238cce01bff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a52d852ba8fa569e858565b3bba403656"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a52d852ba8fa569e858565b3bba403656">dyn_cast</a> (Y &amp;Val)</td></tr>
<tr class="separator:a52d852ba8fa569e858565b3bba403656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt; X, Y * &gt;::ret_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a105c5c5e97d56533fb2b3ba7a0bc59f3">dyn_cast</a> (Y *Val)</td></tr>
<tr class="separator:a105c5c5e97d56533fb2b3ba7a0bc59f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0b0b9f035057552a6a82154fd88e61"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a> ()</td></tr>
<tr class="memdesc:aed0b0b9f035057552a6a82154fd88e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs()">llvm::outs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">More...</a><br /></td></tr>
<tr class="separator:aed0b0b9f035057552a6a82154fd88e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">errs</a> ()</td></tr>
<tr class="memdesc:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs()">llvm::errs()</a>  <a href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc">More...</a><br /></td></tr>
<tr class="separator:ab65033f068bfbeb0a1c52dcec3beb6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a> (<a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:aeb570e9267fd7b189bd1bc877896d7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump sparse bitvector set.  <a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">More...</a><br /></td></tr>
<tr class="separator:aeb570e9267fd7b189bd1bc877896d7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a04aa23b4982662d98c56af3e8ba16cb1">dumpSet</a> (<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> To, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="separator:a04aa23b4982662d98c56af3e8ba16cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">dumpPointsToSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump points-to set.  <a href="namespaceSVF_1_1SVFUtil.html#abd0a9ee845a455f9354d24a8b84a0bb3">More...</a><br /></td></tr>
<tr class="separator:abd0a9ee845a455f9354d24a8b84a0bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30a35713852a0a525c52ae5dd463442"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab30a35713852a0a525c52ae5dd463442">dumpSparseSet</a> (const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;To)</td></tr>
<tr class="separator:ab30a35713852a0a525c52ae5dd463442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a15cc5570eed12dd6ee766213e11d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">dumpAliasSet</a> (unsigned node, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> To)</td></tr>
<tr class="memdesc:a4a15cc5570eed12dd6ee766213e11d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump alias set.  <a href="namespaceSVF_1_1SVFUtil.html#a4a15cc5570eed12dd6ee766213e11d61">More...</a><br /></td></tr>
<tr class="separator:a4a15cc5570eed12dd6ee766213e11d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a05dc00b2bd9a8176aae31b6cfffe725d">sucMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns successful message by converting a string into green string output.  <a href="namespaceSVF_1_1SVFUtil.html#a05dc00b2bd9a8176aae31b6cfffe725d">More...</a><br /></td></tr>
<tr class="separator:a05dc00b2bd9a8176aae31b6cfffe725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71522e8c55f84cfc6c13a0ddff18436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">wrnMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:ac71522e8c55f84cfc6c13a0ddff18436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns warning message by converting a string into yellow string output.  <a href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">More...</a><br /></td></tr>
<tr class="separator:ac71522e8c55f84cfc6c13a0ddff18436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">writeWrnMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a message run through wrnMsg.  <a href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">More...</a><br /></td></tr>
<tr class="separator:ab2e0196e0ce547ab4a483cc6d2646b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a7655b13bbfe720ca2b8a25e0a72528e6">errMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print error message by converting a string into red string output.  <a href="namespaceSVF_1_1SVFUtil.html#a7655b13bbfe720ca2b8a25e0a72528e6">More...</a><br /></td></tr>
<tr class="separator:a7655b13bbfe720ca2b8a25e0a72528e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10504db25b86bc7f74aebb9c54f04cb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a10504db25b86bc7f74aebb9c54f04cb3">bugMsg1</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:a10504db25b86bc7f74aebb9c54f04cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25f6dfcc9118ffd80244a771bdee535"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac25f6dfcc9118ffd80244a771bdee535">bugMsg2</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:ac25f6dfcc9118ffd80244a771bdee535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76909ad87f59eb9a9cfd1913e13da264"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a76909ad87f59eb9a9cfd1913e13da264">bugMsg3</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="separator:a76909ad87f59eb9a9cfd1913e13da264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4550f2fb815882edfb666ac818792064"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4550f2fb815882edfb666ac818792064">pasMsg</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;msg)</td></tr>
<tr class="memdesc:a4550f2fb815882edfb666ac818792064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print each pass/phase message by converting a string into blue string output.  <a href="namespaceSVF_1_1SVFUtil.html#a4550f2fb815882edfb666ac818792064">More...</a><br /></td></tr>
<tr class="separator:a4550f2fb815882edfb666ac818792064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">reportMemoryUsageKB</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;infor, <a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;O=<a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>())</td></tr>
<tr class="memdesc:a6cfe12afa463d0ceddeee11540c33ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print memory usage in KB.  <a href="namespaceSVF_1_1SVFUtil.html#a6cfe12afa463d0ceddeee11540c33ab3">More...</a><br /></td></tr>
<tr class="separator:a6cfe12afa463d0ceddeee11540c33ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a> (<a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmrss_kb, <a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *vmsize_kb)</td></tr>
<tr class="memdesc:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get memory usage from system file. Return TRUE if succeed.  <a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">More...</a><br /></td></tr>
<tr class="separator:a630ff9c47f58f9b8df7c8a2b3711477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7588578735679773493ff2d5e458e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">increaseStackSize</a> ()</td></tr>
<tr class="memdesc:a0d7588578735679773493ff2d5e458e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increase the stack size limit.  <a href="namespaceSVF_1_1SVFUtil.html#a0d7588578735679773493ff2d5e458e1">More...</a><br /></td></tr>
<tr class="separator:a0d7588578735679773493ff2d5e458e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa5ce14119a6e3b0b6022753ddd5890f3">cmpPts</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;lpts, const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;rpts)</td></tr>
<tr class="separator:aa5ce14119a6e3b0b6022753ddd5890f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8f749354b7e882ef3e5bf5081fa715b5">cmpNodeBS</a> (const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;lpts, const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;rpts)</td></tr>
<tr class="separator:a8f749354b7e882ef3e5bf5081fa715b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86ebab122895189be57637b84adc7642"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86ebab122895189be57637b84adc7642">ptsToNodeBS</a> (const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;pts)</td></tr>
<tr class="separator:a86ebab122895189be57637b84adc7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ceddbe4d57b24e80201bc895f73810"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#af4ceddbe4d57b24e80201bc895f73810">dumpPointsToList</a> (const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;ptl)</td></tr>
<tr class="separator:af4ceddbe4d57b24e80201bc895f73810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2bbf6e0dc5adae2140a519259e6f17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abb2bbf6e0dc5adae2140a519259e6f17">isIntrinsicInst</a> (const <a class="el" href="classSVF_1_1SVFInstruction.html">SVFInstruction</a> *inst)</td></tr>
<tr class="memdesc:abb2bbf6e0dc5adae2140a519259e6f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if it is an llvm intrinsic instruction.  <a href="namespaceSVF_1_1SVFUtil.html#abb2bbf6e0dc5adae2140a519259e6f17">More...</a><br /></td></tr>
<tr class="separator:abb2bbf6e0dc5adae2140a519259e6f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">isIntrinsicInst</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="separator:a1a2b3538ed321e5fa17b98e01c9175fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb755f339ad1650f8ae2155451d9c0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8cb755f339ad1650f8ae2155451d9c0d">isCallSite</a> (const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *val)</td></tr>
<tr class="memdesc:a8cb755f339ad1650f8ae2155451d9c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a call or invoke instruction.  <a href="namespaceSVF_1_1SVFUtil.html#a8cb755f339ad1650f8ae2155451d9c0d">More...</a><br /></td></tr>
<tr class="separator:a8cb755f339ad1650f8ae2155451d9c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f286ff865a778dc2af5410ed9b24e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">isCallSite</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="separator:ac69f286ff865a778dc2af5410ed9b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bd7753901074b660eda3166180a356"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad4bd7753901074b660eda3166180a356">isRetInstNode</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:ad4bd7753901074b660eda3166180a356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af4db2fe43846609d2ed1d7022b1be1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4af4db2fe43846609d2ed1d7022b1be1">isNonInstricCallSite</a> (const <a class="el" href="classSVF_1_1SVFInstruction.html">SVFInstruction</a> *inst)</td></tr>
<tr class="memdesc:a4af4db2fe43846609d2ed1d7022b1be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="namespaceSVF_1_1SVFUtil.html#a4af4db2fe43846609d2ed1d7022b1be1">More...</a><br /></td></tr>
<tr class="separator:a4af4db2fe43846609d2ed1d7022b1be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b337f84cae7ae0ec4597b077aee08c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86b337f84cae7ae0ec4597b077aee08c">isNonInstricCallSite</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *inst)</td></tr>
<tr class="memdesc:a86b337f84cae7ae0ec4597b077aee08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls.  <a href="namespaceSVF_1_1SVFUtil.html#a86b337f84cae7ae0ec4597b077aee08c">More...</a><br /></td></tr>
<tr class="separator:a86b337f84cae7ae0ec4597b077aee08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7f7c7f60a7ad6c053012a74f2dcc1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ada7f7c7f60a7ad6c053012a74f2dcc1c">matchArgs</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs, const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *callee)</td></tr>
<tr class="separator:ada7f7c7f60a7ad6c053012a74f2dcc1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18227f257c9881541b84ca186680dfd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ae18227f257c9881541b84ca186680dfd">split</a> (const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;s, char separator)</td></tr>
<tr class="memdesc:ae18227f257c9881541b84ca186680dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split into two substrings around the first occurrence of a separator string.  <a href="namespaceSVF_1_1SVFUtil.html#ae18227f257c9881541b84ca186680dfd">More...</a><br /></td></tr>
<tr class="separator:ae18227f257c9881541b84ca186680dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplParams" colspan="2">template&lt;typename Data &gt; </td></tr>
<tr class="memitem:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">mergePtsOccMaps</a> (<a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;to, const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; from)</td></tr>
<tr class="memdesc:a36c91f952a69875c33d4bd0b05a27ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map mapping points-to sets to a count, adds from into to.  <a href="namespaceSVF_1_1SVFUtil.html#a36c91f952a69875c33d4bd0b05a27ff2">More...</a><br /></td></tr>
<tr class="separator:a36c91f952a69875c33d4bd0b05a27ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">hclustMethodToString</a> (<a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a> method)</td></tr>
<tr class="memdesc:a14a4c5124f2fd03ca3d898e2acd54160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a hclust method.  <a href="namespaceSVF_1_1SVFUtil.html#a14a4c5124f2fd03ca3d898e2acd54160">More...</a><br /></td></tr>
<tr class="separator:a14a4c5124f2fd03ca3d898e2acd54160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aeecfaf26800dcebf0b079395126bc7f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">insertKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aeecfaf26800dcebf0b079395126bc7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element into a Set/CondSet (with ::insert).  <a href="namespaceSVF_1_1SVFUtil.html#aeecfaf26800dcebf0b079395126bc7f7">More...</a><br /></td></tr>
<tr class="separator:aeecfaf26800dcebf0b079395126bc7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">insertKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a NodeID into a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#a4f75b8313eb2b1e5a4c798a01cb99471">More...</a><br /></td></tr>
<tr class="separator:a4f75b8313eb2b1e5a4c798a01cb99471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename KeySet &gt; </td></tr>
<tr class="memitem:aee74719d33695e4da6fee5fc83f745d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">removeKey</a> (const Key &amp;key, KeySet &amp;keySet)</td></tr>
<tr class="memdesc:aee74719d33695e4da6fee5fc83f745d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from a Set/CondSet (or anything implementing ::erase).  <a href="namespaceSVF_1_1SVFUtil.html#aee74719d33695e4da6fee5fc83f745d9">More...</a><br /></td></tr>
<tr class="separator:aee74719d33695e4da6fee5fc83f745d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59af7fc01a534662b3b1524186ef97e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">removeKey</a> (const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;key, <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;keySet)</td></tr>
<tr class="memdesc:aa59af7fc01a534662b3b1524186ef97e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a NodeID from a NodeBS.  <a href="namespaceSVF_1_1SVFUtil.html#aa59af7fc01a534662b3b1524186ef97e">More...</a><br /></td></tr>
<tr class="separator:aa59af7fc01a534662b3b1524186ef97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4cd21115988f9f5eec12e268ddf1d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a> (int signum)</td></tr>
<tr class="memdesc:add4cd21115988f9f5eec12e268ddf1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call when alarm for time limit hits.  <a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">More...</a><br /></td></tr>
<tr class="separator:add4cd21115988f9f5eec12e268ddf1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757815a2c758695176120509ceb0ce70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a757815a2c758695176120509ceb0ce70">startAnalysisLimitTimer</a> (unsigned timeLimit)</td></tr>
<tr class="separator:a757815a2c758695176120509ceb0ce70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">stopAnalysisLimitTimer</a> (bool limitTimerSet)</td></tr>
<tr class="separator:a168f7f7a3a8c70dbf2b5b4269cd4c7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ef185e767ff76c098e75126c885400"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">isExtCall</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:a22ef185e767ff76c098e75126c885400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688bd5e1bf36b3e75bfcea9388871dc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a688bd5e1bf36b3e75bfcea9388871dc4">isMemcpyExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:a688bd5e1bf36b3e75bfcea9388871dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54098ea73555caa682287f8e3c9e8fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a54098ea73555caa682287f8e3c9e8fcb">isMemsetExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:a54098ea73555caa682287f8e3c9e8fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b96a872d9096037f20e25122e469ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a19b96a872d9096037f20e25122e469ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap allocator/reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">More...</a><br /></td></tr>
<tr class="separator:a19b96a872d9096037f20e25122e469ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a69173f50ebe48e69103befe516245"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="separator:ab4a69173f50ebe48e69103befe516245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86491999a479a611489469b3e69d7cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a86491999a479a611489469b3e69d7cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the position of argument that holds an allocated heap object.  <a href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">More...</a><br /></td></tr>
<tr class="separator:a86491999a479a611489469b3e69d7cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the call is a heap reallocator.  <a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">More...</a><br /></td></tr>
<tr class="separator:a97c74c642ad43d955ac8a3f3ad8907b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c97c2b79b795465490512e267a9309b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:a2c97c2b79b795465490512e267a9309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program entry function e.g. main.  <a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">More...</a><br /></td></tr>
<tr class="separator:a2c97c2b79b795465490512e267a9309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f82e03d880257527bd9cb5978e05604"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">getProgFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule, const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;funName)</td></tr>
<tr class="memdesc:a6f82e03d880257527bd9cb5978e05604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#a6f82e03d880257527bd9cb5978e05604">More...</a><br /></td></tr>
<tr class="separator:a6f82e03d880257527bd9cb5978e05604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8017e3e5100b3f63ee338b66118d266"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">getProgEntryFunction</a> (<a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *svfModule)</td></tr>
<tr class="memdesc:aa8017e3e5100b3f63ee338b66118d266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get program entry function from module.  <a href="namespaceSVF_1_1SVFUtil.html#aa8017e3e5100b3f63ee338b66118d266">More...</a><br /></td></tr>
<tr class="separator:aa8017e3e5100b3f63ee338b66118d266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ee60be22e8f9397db108131696d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a> (const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *fun)</td></tr>
<tr class="memdesc:aec7ee60be22e8f9397db108131696d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a program exit function call.  <a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">More...</a><br /></td></tr>
<tr class="separator:aec7ee60be22e8f9397db108131696d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a1a34958ca60ed98ad228c1d46cf95aeb">isArgOfUncalledFunction</a> (const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *svfval)</td></tr>
<tr class="memdesc:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this argument belongs to an uncalled function.  <a href="namespaceSVF_1_1SVFUtil.html#a1a34958ca60ed98ad228c1d46cf95aeb">More...</a><br /></td></tr>
<tr class="separator:a1a34958ca60ed98ad228c1d46cf95aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceaa01be78180abcef82edeff0027eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#acceaa01be78180abcef82edeff0027eb">getForkedFun</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *inst)</td></tr>
<tr class="memdesc:acceaa01be78180abcef82edeff0027eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return thread fork function.  <a href="namespaceSVF_1_1SVFUtil.html#acceaa01be78180abcef82edeff0027eb">More...</a><br /></td></tr>
<tr class="separator:acceaa01be78180abcef82edeff0027eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d203b5b7749ce51583d39a503407db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa2d203b5b7749ce51583d39a503407db">isExtCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:aa2d203b5b7749ce51583d39a503407db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f888dfee60a63eb0711fcdd63430e8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a3f888dfee60a63eb0711fcdd63430e8f">isExtCall</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *node)</td></tr>
<tr class="separator:a3f888dfee60a63eb0711fcdd63430e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a75e8eda99da5d45ccf0188e2d876d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a83a75e8eda99da5d45ccf0188e2d876d">isHeapAllocExtCallViaArg</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a83a75e8eda99da5d45ccf0188e2d876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3bde29364d65428ee2c4eb22063828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aeb3bde29364d65428ee2c4eb22063828">isHeapAllocExtCallViaRet</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:aeb3bde29364d65428ee2c4eb22063828"><td class="mdescLeft">&#160;</td><td class="mdescRight">interfaces to be used externally  <a href="namespaceSVF_1_1SVFUtil.html#aeb3bde29364d65428ee2c4eb22063828">More...</a><br /></td></tr>
<tr class="separator:aeb3bde29364d65428ee2c4eb22063828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b308e08dd0837b9401ada40349ac32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a85b308e08dd0837b9401ada40349ac32">isHeapAllocExtCall</a> (const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *cs)</td></tr>
<tr class="separator:a85b308e08dd0837b9401ada40349ac32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd908aab5f4e0352c50a36381ae85f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a5bd908aab5f4e0352c50a36381ae85f3">getHeapAllocHoldingArgPosition</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a5bd908aab5f4e0352c50a36381ae85f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a01f4cd58f733d71c9bbd7dcc40194c0b">isReallocExtCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a01f4cd58f733d71c9bbd7dcc40194c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a811faa9c2095f44e3e5b6e50aa6f6e06">is_sequence_container_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a811faa9c2095f44e3e5b6e50aa6f6e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a8c57ab480c497cbd21a49778d0e59bd5">is_map_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a8c57ab480c497cbd21a49778d0e59bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a08e67d68b1da116b2c51cb60bdb6dae2">is_set_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a>&lt;Ts...&gt;::value</td></tr>
<tr class="separator:a08e67d68b1da116b2c51cb60bdb6dae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ad37880353cffc950d5b9417bc41c0b06"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ad37880353cffc950d5b9417bc41c0b06">void_t</a> = typename <a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a>&lt; Ts... &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a></td></tr>
<tr class="separator:ad37880353cffc950d5b9417bc41c0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa32219da7a5c3d7517ec5026afdac588"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aa32219da7a5c3d7517ec5026afdac588">is_iterable_v</a> = <a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a>&lt;T&gt;::value</td></tr>
<tr class="separator:aa32219da7a5c3d7517ec5026afdac588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#aac9a03aaeb26832c69f95a9a96a2d31a">isThreadForkCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *inst)</td></tr>
<tr class="separator:aac9a03aaeb26832c69f95a9a96a2d31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c79a20405d3a31b309a14bd68f1166"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a86c79a20405d3a31b309a14bd68f1166">isThreadJoinCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a86c79a20405d3a31b309a14bd68f1166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b7843d49df58cf1bf3725076702c07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac1b7843d49df58cf1bf3725076702c07">isThreadExitCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:ac1b7843d49df58cf1bf3725076702c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191cbe16e7e32dd136cff438752b3029"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a191cbe16e7e32dd136cff438752b3029">isLockAquireCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:a191cbe16e7e32dd136cff438752b3029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7be6fe5d9c277583eaeab46282b62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#abaa7be6fe5d9c277583eaeab46282b62">isLockReleaseCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:abaa7be6fe5d9c277583eaeab46282b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f0066d96179c6d7e9a1e42608ecb73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a34f0066d96179c6d7e9a1e42608ecb73">isBarrierWaitCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:a34f0066d96179c6d7e9a1e42608ecb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is a barrier wait call.  <a href="namespaceSVF_1_1SVFUtil.html#a34f0066d96179c6d7e9a1e42608ecb73">More...</a><br /></td></tr>
<tr class="separator:a34f0066d96179c6d7e9a1e42608ecb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745fb5ab70cf73fd4655e3e10b1d847d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a745fb5ab70cf73fd4655e3e10b1d847d">getActualParmAtForkSite</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="memdesc:a745fb5ab70cf73fd4655e3e10b1d847d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sole argument of the thread routine.  <a href="namespaceSVF_1_1SVFUtil.html#a745fb5ab70cf73fd4655e3e10b1d847d">More...</a><br /></td></tr>
<tr class="separator:a745fb5ab70cf73fd4655e3e10b1d847d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6586774af88b61f367ba43d126f38ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#ac6586774af88b61f367ba43d126f38ac">isProgExitCall</a> (const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *cs)</td></tr>
<tr class="separator:ac6586774af88b61f367ba43d126f38ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72502f7f536418621485e90ab98c2016"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::remove_reference&lt; T &gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a> &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">move</a> (T &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a72502f7f536418621485e90ab98c2016"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acb66b86171786cc34b798f05f67f321e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb66b86171786cc34b798f05f67f321e">&#9670;&nbsp;</a></span>equalNodeBS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalNodeBS.html">SVF::SVFUtil::equalNodeBS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac047d963ed4b701c83958868ab36202f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac047d963ed4b701c83958868ab36202f">&#9670;&nbsp;</a></span>equalPointsTo</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a> <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">SVF::SVFUtil::equalPointsTo</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4740b14abf7d308e7806a0d6d6c42ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4740b14abf7d308e7806a0d6d6c42ee2">&#9670;&nbsp;</a></span>PointsToList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespaceSVF.html#a4f21e91ff8eaea5207afe5c60dbd78d7">OrderedSet</a>&lt;<a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>, <a class="el" href="structSVF_1_1SVFUtil_1_1equalPointsTo.html">equalPointsTo</a>&gt; <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">SVF::SVFUtil::PointsToList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00166">166</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="ad37880353cffc950d5b9417bc41c0b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37880353cffc950d5b9417bc41c0b06">&#9670;&nbsp;</a></span>void_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceSVF_1_1SVFUtil.html#ad37880353cffc950d5b9417bc41c0b06">SVF::SVFUtil::void_t</a> = typedef typename <a class="el" href="structSVF_1_1SVFUtil_1_1make__void.html">make_void</a>&lt;Ts...&gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00482">482</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a10504db25b86bc7f74aebb9c54f04cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10504db25b86bc7f74aebb9c54f04cb3">&#9670;&nbsp;</a></span>bugMsg1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00081">81</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;{</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a137aa83ec74421d226a90c92ec032ac9"><div class="ttname"><a href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a></div><div class="ttdeci">#define KNRM</div><div class="ttdoc">Color for output format.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00039">SVFUtil.cpp:39</a></div></div>
<div class="ttc" id="aSVFUtil_8cpp_html_a897b10d246533c95ba86cb79f92e465a"><div class="ttname"><a href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a></div><div class="ttdeci">#define KYEL</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00042">SVFUtil.cpp:42</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac25f6dfcc9118ffd80244a771bdee535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25f6dfcc9118ffd80244a771bdee535">&#9670;&nbsp;</a></span>bugMsg2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00086">86</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;{</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a326cbc9ef8d75aa44a591bf476c9835b"><div class="ttname"><a href="SVFUtil_8cpp.html#a326cbc9ef8d75aa44a591bf476c9835b">KPUR</a></div><div class="ttdeci">#define KPUR</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00044">SVFUtil.cpp:44</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a76909ad87f59eb9a9cfd1913e13da264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76909ad87f59eb9a9cfd1913e13da264">&#9670;&nbsp;</a></span>bugMsg3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::bugMsg3 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00091">91</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;{</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_add84f76d7bfbbc2b00215d7195f8d3bd"><div class="ttname"><a href="SVFUtil_8cpp.html#add84f76d7bfbbc2b00215d7195f8d3bd">KCYA</a></div><div class="ttdeci">#define KCYA</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00045">SVFUtil.cpp:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ddf7041e685da8ede81cd773dd47761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ddf7041e685da8ede81cd773dd47761">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt; SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00360">360</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;{</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;    assert(SVFUtil::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;           X, <span class="keyword">const</span> Y, <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af3ca049b4ce83c874e231f5e13bf36a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3ca049b4ce83c874e231f5e13bf36a8">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, std::unique_ptr&lt;Y&gt; &gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; Y &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00385">385</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;{</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    assert(SVFUtil::isa&lt;X&gt;(Val.get()) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="keyword">using</span> ret_type = <span class="keyword">typename</span> cast_retty&lt;X, std::unique_ptr&lt;Y&gt;&gt;::ret_type;</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">return</span> ret_type(</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;               cast_convert_val&lt;X, Y *, <span class="keyword">typename</span> simplify_type&lt;Y *&gt;::SimpleType&gt;::doit(</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;                   Val.release()));</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a406dd9baf2ce66235d482fd6c6121b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406dd9baf2ce66235d482fd6c6121b2c">&#9670;&nbsp;</a></span>cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00368">368</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;{</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    assert(SVFUtil::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y,</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y&gt;::SimpleType&gt;::doit(Val);</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acc2419a55c0427571f11ad14db2fe481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2419a55c0427571f11ad14db2fe481">&#9670;&nbsp;</a></span>cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00376">376</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;{</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    assert(SVFUtil::isa&lt;X&gt;(Val) &amp;&amp; <span class="stringliteral">&quot;cast&lt;Ty&gt;() argument of incompatible type!&quot;</span>);</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;    <span class="keywordflow">return</span> cast_convert_val&lt;X, Y*,</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;Y*&gt;::SimpleType&gt;::doit(Val);</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f749354b7e882ef3e5bf5081fa715b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f749354b7e882ef3e5bf5081fa715b5">&#9670;&nbsp;</a></span>cmpNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00125">125</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;{</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    {</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        NodeBS::iterator bit = lpts.begin(), eit = lpts.end();</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        NodeBS::iterator rbit = rpts.begin(), reit = rpts.end();</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        {</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        }</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160; </div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    }</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5ce14119a6e3b0b6022753ddd5890f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ce14119a6e3b0b6022753ddd5890f3">&#9670;&nbsp;</a></span>cmpPts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::cmpPts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>lpts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>rpts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare two <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> according to their size and points-to elements.</p><ol type="1">
<li><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> with smaller size is smaller than the other;</li>
<li>If the sizes are equal, comparing the points-to targets. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00107">107</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <span class="keywordflow">if</span> (lpts.count() != rpts.count())</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;        <span class="keywordflow">return</span> (lpts.count() &lt; rpts.count());</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    {</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;        PointsTo::iterator bit = lpts.begin(), eit = lpts.end();</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;        PointsTo::iterator rbit = rpts.begin(), reit = rpts.end();</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;        <span class="keywordflow">for</span> (; bit != eit &amp;&amp; rbit != reit; bit++, rbit++)</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;        {</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;            <span class="keywordflow">if</span> (*bit != *rbit)</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                <span class="keywordflow">return</span> (*bit &lt; *rbit);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        }</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160; </div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;    }</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a15cc5570eed12dd6ee766213e11d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a15cc5570eed12dd6ee766213e11d61">&#9670;&nbsp;</a></span>dumpAliasSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpAliasSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump alias set. </p>
<p>Dump alias set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00137">137</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;{</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; alias set: {&quot;</span>;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_aeb570e9267fd7b189bd1bc877896d7ab"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">SVF::SVFUtil::dumpSet</a></div><div class="ttdeci">void dumpSet(NodeBS To, OutStream &amp;O=SVFUtil::outs())</div><div class="ttdoc">Dump sparse bitvector set.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00147">SVFUtil.cpp:147</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_aed0b0b9f035057552a6a82154fd88e61"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVF::SVFUtil::outs</a></div><div class="ttdeci">std::ostream &amp; outs()</div><div class="ttdoc">Overwrite llvm::outs()</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00050">SVFUtil.h:50</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af4ceddbe4d57b24e80201bc895f73810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ceddbe4d57b24e80201bc895f73810">&#9670;&nbsp;</a></span>dumpPointsToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF_1_1SVFUtil.html#a4740b14abf7d308e7806a0d6d6c42ee2">PointsToList</a> &amp;&#160;</td>
          <td class="paramname"><em>ptl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00122">122</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;{</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <span class="keywordflow">for</span> (PointsToList::const_iterator ii = ptl.begin(), ie = ptl.end();</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;            ii != ie; ii++)</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    {</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;        <span class="keyword">auto</span> bs = *ii;</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abd0a9ee845a455f9354d24a8b84a0bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0a9ee845a455f9354d24a8b84a0bb3">&#9670;&nbsp;</a></span>dumpPointsToSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpPointsToSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump points-to set. </p>
<p>Dump points-to set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00107">107</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;{</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;node &quot;</span> &lt;&lt; node &lt;&lt; <span class="stringliteral">&quot; points-to: {&quot;</span>;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb570e9267fd7b189bd1bc877896d7ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb570e9267fd7b189bd1bc877896d7ab">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a>&#160;</td>
          <td class="paramname"><em>bs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump sparse bitvector set. </p>
<p>Dump bit vector set </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00147">147</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">NodeBS::iterator</a> ii = bs.<a class="code" href="classSVF_1_1SparseBitVector.html#abf76d8157c49ddba24bdc9dab3655772">begin</a>(), ie = bs.<a class="code" href="classSVF_1_1SparseBitVector.html#a1b5abe09fd0fcd337385653cb47343c1">end</a>();</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;            ii != ie; ii++)</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;    {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;        O &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; *ii &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;    }</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_1_1SparseBitVectorIterator_html"><div class="ttname"><a href="classSVF_1_1SparseBitVector_1_1SparseBitVectorIterator.html">SVF::SparseBitVector::SparseBitVectorIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l00578">SparseBitVector.h:579</a></div></div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_html_a1b5abe09fd0fcd337385653cb47343c1"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#a1b5abe09fd0fcd337385653cb47343c1">SVF::SparseBitVector::end</a></div><div class="ttdeci">iterator end() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l01162">SparseBitVector.h:1162</a></div></div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_html_abf76d8157c49ddba24bdc9dab3655772"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#abf76d8157c49ddba24bdc9dab3655772">SVF::SparseBitVector::begin</a></div><div class="ttdeci">iterator begin() const</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l01157">SparseBitVector.h:1157</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a04aa23b4982662d98c56af3e8ba16cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04aa23b4982662d98c56af3e8ba16cb1">&#9670;&nbsp;</a></span>dumpSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a>&#160;</td>
          <td class="paramname"><em>To</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00156">156</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;{</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> <a class="code" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> : pt)</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    {</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;        o &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; <a class="code" href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a> &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    }</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div>
<div class="ttc" id="acJSON_8cpp_html_ab6e2ea6dc7bd57d1483413449998230a"><div class="ttname"><a href="cJSON_8cpp.html#ab6e2ea6dc7bd57d1483413449998230a">n</a></div><div class="ttdeci">cJSON * n</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8cpp_source.html#l02558">cJSON.cpp:2558</a></div></div>
<div class="ttc" id="anamespaceSVF_html_a43a65e0d33af3c743294f7a1139d2301"><div class="ttname"><a href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">SVF::NodeID</a></div><div class="ttdeci">u32_t NodeID</div><div class="ttdef"><b>Definition:</b> <a href="GeneralType_8h_source.html#l00055">GeneralType.h:55</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab30a35713852a0a525c52ae5dd463442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30a35713852a0a525c52ae5dd463442">&#9670;&nbsp;</a></span>dumpSparseSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::dumpSparseSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>To</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00115">115</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;{</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;{&quot;</span>;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aeb570e9267fd7b189bd1bc877896d7ab">dumpSet</a>(bs);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <span class="stringliteral">&quot;}\n&quot;</span>;</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af6e96694d983643a66c238cce01bff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6e96694d983643a66c238cce01bff0e">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> std::enable_if_t&lt;!<a class="el" href="structSVF_1_1SVFUtil_1_1is__simple__type.html">is_simple_type</a>&lt;Y&gt;::value, typename <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, const Y&gt;::ret_type&gt; SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00405">405</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;{</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(Val) ? SVFUtil::cast&lt;X&gt;(Val) : nullptr;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a52d852ba8fa569e858565b3bba403656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d852ba8fa569e858565b3bba403656">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00411">411</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;{</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(Val) ? SVFUtil::cast&lt;X&gt;(Val) : nullptr;</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a105c5c5e97d56533fb2b3ba7a0bc59f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105c5c5e97d56533fb2b3ba7a0bc59f3">&#9670;&nbsp;</a></span>dyn_cast() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> <a class="el" href="structSVF_1_1SVFUtil_1_1cast__retty.html">cast_retty</a>&lt;X, Y *&gt;::ret_type SVF::SVFUtil::dyn_cast </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00417">417</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;{</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;X&gt;(Val) ? SVFUtil::cast&lt;X&gt;(Val) : nullptr;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7655b13bbfe720ca2b8a25e0a72528e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7655b13bbfe720ca2b8a25e0a72528e6">&#9670;&nbsp;</a></span>errMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::errMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print error message by converting a string into red string output. </p>
<p>print error message by converting a string into red string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00076">76</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;{</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a66290957baed5df3930ada4cb8caccf1"><div class="ttname"><a href="SVFUtil_8cpp.html#a66290957baed5df3930ada4cb8caccf1">KRED</a></div><div class="ttdeci">#define KRED</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00040">SVFUtil.cpp:40</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab65033f068bfbeb0a1c52dcec3beb6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65033f068bfbeb0a1c52dcec3beb6bc">&#9670;&nbsp;</a></span>errs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::errs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#ab65033f068bfbeb0a1c52dcec3beb6bc" title="Overwrite llvm::errs()">llvm::errs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00056">56</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;{</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    <span class="keywordflow">return</span> std::cerr;</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a745fb5ab70cf73fd4655e3e10b1d847d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745fb5ab70cf73fd4655e3e10b1d847d">&#9670;&nbsp;</a></span>getActualParmAtForkSite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a>* SVF::SVFUtil::getActualParmAtForkSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return sole argument of the thread routine. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00460">460</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;{</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getActualParmAtForkSite(cs);</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acceaa01be78180abcef82edeff0027eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acceaa01be78180abcef82edeff0027eb">&#9670;&nbsp;</a></span>getForkedFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a>* SVF::SVFUtil::getForkedFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return thread fork function. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00381">381</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;{</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;getForkedFun(inst);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bd908aab5f4e0352c50a36381ae85f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd908aab5f4e0352c50a36381ae85f3">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00357">357</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;{</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">getHeapAllocHoldingArgPosition</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_a01da4df6aae8e660f9a97e91e42c397f"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">SVF::CallICFGNode::getCalledFunction</a></div><div class="ttdeci">const SVFFunction * getCalledFunction() const</div><div class="ttdef"><b>Definition:</b> <a href="ICFGNode_8h_source.html#l00505">ICFGNode.h:505</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a86491999a479a611489469b3e69d7cf2"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a86491999a479a611489469b3e69d7cf2">SVF::SVFUtil::getHeapAllocHoldingArgPosition</a></div><div class="ttdeci">u32_t getHeapAllocHoldingArgPosition(const SVFFunction *fun)</div><div class="ttdoc">Get the position of argument that holds an allocated heap object.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00316">SVFUtil.h:316</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86491999a479a611489469b3e69d7cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86491999a479a611489469b3e69d7cf2">&#9670;&nbsp;</a></span>getHeapAllocHoldingArgPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> SVF::SVFUtil::getHeapAllocHoldingArgPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the position of argument that holds an allocated heap object. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00316">316</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;{</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;    <span class="keywordflow">return</span> ExtAPI::getExtAPI()-&gt;get_alloc_arg_pos(fun);</div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a630ff9c47f58f9b8df7c8a2b3711477c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ff9c47f58f9b8df7c8a2b3711477c">&#9670;&nbsp;</a></span>getMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::getMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmrss_kb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#ad42bff8d0a7d60a085aa32d10f4955af">u32_t</a> *&#160;</td>
          <td class="paramname"><em>vmsize_kb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get memory usage from system file. Return TRUE if succeed. </p>
<p>Get memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00177">177</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;{</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="comment">/* Get the current process&#39; status file from the proc filesystem */</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordtype">char</span> <a class="code" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>[8192];</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    FILE* procfile = fopen(<span class="stringliteral">&quot;/proc/self/status&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;    <span class="keywordflow">if</span>(procfile)</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;    {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        <a class="code" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> result = fread(<a class="code" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span>), 8192, procfile);</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">if</span> (result == 0)</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;        {</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;            fputs (<span class="stringliteral">&quot;Reading error\n&quot;</span>,stderr);</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;        }</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    }</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;    {</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;        <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">SVFUtil::writeWrnMsg</a>(<span class="stringliteral">&quot; /proc/self/status file not exit!&quot;</span>);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;    }</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;    fclose(procfile);</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160; </div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;    <span class="comment">/* Look through proc status contents line by line */</span></div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordtype">char</span> delims[] = <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;    <span class="keywordtype">char</span>* line = <a class="code" href="extapi_8c.html#a8cb460f64c449f2a9b9b7a40569ce0fe">strtok</a>(<a class="code" href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a>, delims);</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160; </div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    <span class="keywordtype">bool</span> found_vmrss = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    <span class="keywordtype">bool</span> found_vmsize = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160; </div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keywordflow">while</span> (line != <span class="keyword">nullptr</span> &amp;&amp; (found_vmrss == <span class="keyword">false</span> || found_vmsize == <span class="keyword">false</span>))</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    {</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="extapi_8c.html#a4a710d86541afc6b7dafddcdb4b1c94f">strstr</a>(line, <span class="stringliteral">&quot;VmRSS:&quot;</span>) != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;        {</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmrss_kb);</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;            found_vmrss = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        }</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160; </div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="extapi_8c.html#a4a710d86541afc6b7dafddcdb4b1c94f">strstr</a>(line, <span class="stringliteral">&quot;VmSize:&quot;</span>) != <span class="keyword">nullptr</span>)</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;        {</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;            sscanf(line, <span class="stringliteral">&quot;%*s %u&quot;</span>, vmsize_kb);</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;            found_vmsize = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        }</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160; </div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        line = <a class="code" href="extapi_8c.html#a8cb460f64c449f2a9b9b7a40569ce0fe">strtok</a>(<span class="keyword">nullptr</span>, delims);</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;    }</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160; </div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;    <span class="keywordflow">return</span> (found_vmrss &amp;&amp; found_vmsize);</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;}</div>
<div class="ttc" id="aCommandLine_8h_html_a2429346d37bd4c40889bd7c6d319d9da"><div class="ttname"><a href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a></div><div class="ttdeci">unsigned u32_t</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00018">CommandLine.h:18</a></div></div>
<div class="ttc" id="acJSON_8h_html_a503753140aa27b00f99a3501280b2746"><div class="ttname"><a href="cJSON_8h.html#a503753140aa27b00f99a3501280b2746">buffer</a></div><div class="ttdeci">char * buffer</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00163">cJSON.h:163</a></div></div>
<div class="ttc" id="aextapi_8c_html_a4a710d86541afc6b7dafddcdb4b1c94f"><div class="ttname"><a href="extapi_8c.html#a4a710d86541afc6b7dafddcdb4b1c94f">strstr</a></div><div class="ttdeci">char * strstr(const char *haystack, const char *needle)</div><div class="ttdef"><b>Definition:</b> <a href="extapi_8c_source.html#l00821">extapi.c:821</a></div></div>
<div class="ttc" id="aextapi_8c_html_a8cb460f64c449f2a9b9b7a40569ce0fe"><div class="ttname"><a href="extapi_8c.html#a8cb460f64c449f2a9b9b7a40569ce0fe">strtok</a></div><div class="ttdeci">char * strtok(char *str, const char *delim)</div><div class="ttdef"><b>Definition:</b> <a href="extapi_8c_source.html#l00463">extapi.c:463</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ab2e0196e0ce547ab4a483cc6d2646b24"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">SVF::SVFUtil::writeWrnMsg</a></div><div class="ttdeci">void writeWrnMsg(const std::string &amp;msg)</div><div class="ttdoc">Writes a message run through wrnMsg.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00066">SVFUtil.cpp:66</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa8017e3e5100b3f63ee338b66118d266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8017e3e5100b3f63ee338b66118d266">&#9670;&nbsp;</a></span>getProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00350">350</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;{</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    {</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">isProgEntryFunction</a>(fun))</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;            <span class="keywordflow">return</span> (fun);</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    }</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a2c97c2b79b795465490512e267a9309b"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a2c97c2b79b795465490512e267a9309b">SVF::SVFUtil::isProgEntryFunction</a></div><div class="ttdeci">bool isProgEntryFunction(const SVFFunction *fun)</div><div class="ttdoc">Program entry function e.g. main.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00332">SVFUtil.h:332</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f82e03d880257527bd9cb5978e05604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f82e03d880257527bd9cb5978e05604">&#9670;&nbsp;</a></span>getProgFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* SVF::SVFUtil::getProgFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSVF_1_1SVFModule.html">SVFModule</a> *&#160;</td>
          <td class="paramname"><em>svfModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>funName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get program entry function from module. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00338">338</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;{</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;    <span class="keywordflow">for</span> (SVFModule::const_iterator it = svfModule-&gt;begin(), eit = svfModule-&gt;end(); it != eit; ++it)</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    {</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;        <span class="keyword">const</span> SVFFunction *fun = *it;</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;        <span class="keywordflow">if</span> (fun-&gt;getName()==funName)</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;            <span class="keywordflow">return</span> fun;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;    }</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14a4c5124f2fd03ca3d898e2acd54160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a4c5124f2fd03ca3d898e2acd54160">&#9670;&nbsp;</a></span>hclustMethodToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::hclustMethodToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dd">hclust_fast_methods</a>&#160;</td>
          <td class="paramname"><em>method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a hclust method. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00260">260</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;{</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    <span class="keywordflow">switch</span> (method)</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;    {</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a>:</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;single&quot;</span>;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a>:</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;complete&quot;</span>;</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a>:</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;average&quot;</span>;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a>:</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;median&quot;</span>;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="keywordflow">case</span> <a class="code" href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a>:</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        <span class="keywordflow">return</span> <span class="stringliteral">&quot;svf-best&quot;</span>;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">default</span>:</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        assert(<span class="keyword">false</span> &amp;&amp; <span class="stringliteral">&quot;SVFUtil::hclustMethodToString: unknown method&quot;</span>);</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        abort();</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    }</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;}</div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda3ab72664fc61704a1ba46bddbc347115">HCLUST_METHOD_AVERAGE</a></div><div class="ttdeci">@ HCLUST_METHOD_AVERAGE</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00072">fastcluster.h:72</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda44ce22fdfc560f27242e9b8f8e7009f4">HCLUST_METHOD_COMPLETE</a></div><div class="ttdeci">@ HCLUST_METHOD_COMPLETE</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00070">fastcluster.h:70</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913dda66ab3fde95842ef6da0dae1f702a9618">HCLUST_METHOD_SVF_BEST</a></div><div class="ttdeci">@ HCLUST_METHOD_SVF_BEST</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00077">fastcluster.h:76</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddaa453b79910d9c6f7f57a179bcdf63474">HCLUST_METHOD_MEDIAN</a></div><div class="ttdeci">@ HCLUST_METHOD_MEDIAN</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00074">fastcluster.h:74</a></div></div>
<div class="ttc" id="afastcluster_8h_html_a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024"><div class="ttname"><a href="fastcluster_8h.html#a4205a14ad66b3320d2e94c61d74913ddad16cc6362447cc32292c4af4c6fe8024">HCLUST_METHOD_SINGLE</a></div><div class="ttdeci">@ HCLUST_METHOD_SINGLE</div><div class="ttdef"><b>Definition:</b> <a href="fastcluster_8h_source.html#l00068">fastcluster.h:68</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d7588578735679773493ff2d5e458e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7588578735679773493ff2d5e458e1">&#9670;&nbsp;</a></span>increaseStackSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::increaseStackSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increase the stack size limit. </p>
<p>Increase stack size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00227">227</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;{</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;    <span class="keyword">const</span> rlim_t kStackSize = 256L * 1024L * 1024L;   <span class="comment">// min stack size = 256 Mb</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;    <span class="keyword">struct </span>rlimit rl;</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <span class="keywordtype">int</span> result = getrlimit(RLIMIT_STACK, &amp;rl);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">if</span> (result == 0)</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;    {</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">if</span> (rl.rlim_cur &lt; kStackSize)</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        {</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;            rl.rlim_cur = kStackSize;</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;            result = setrlimit(RLIMIT_STACK, &amp;rl);</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;            <span class="keywordflow">if</span> (result != 0)</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;                <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab2e0196e0ce547ab4a483cc6d2646b24">writeWrnMsg</a>(<span class="stringliteral">&quot;setrlimit returned result !=0 \n&quot;</span>);</div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        }</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;    }</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeecfaf26800dcebf0b079395126bc7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecfaf26800dcebf0b079395126bc7f7">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts an element into a Set/CondSet (with ::insert). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00246">246</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;{</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;    keySet.insert(key);</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f75b8313eb2b1e5a4c798a01cb99471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f75b8313eb2b1e5a4c798a01cb99471">&#9670;&nbsp;</a></span>insertKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::insertKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a NodeID into a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00252">252</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;    keySet.set(key);</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5c8cbc986cccb9d84f87aae162df3737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8cbc986cccb9d84f87aae162df3737">&#9670;&nbsp;</a></span>isa() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> bool SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00241">241</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;{</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;    <span class="keywordflow">return</span> isa_impl_wrap&lt;X, <span class="keyword">const</span> Y,</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;           <span class="keyword">typename</span> simplify_type&lt;const Y&gt;::SimpleType&gt;::doit(Val);</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a13729076054a2977670b05a338a6763d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13729076054a2977670b05a338a6763d">&#9670;&nbsp;</a></span>isa() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename First , typename Second , typename... Rest, typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Casting_8h.html#a8ce3b3743bf423cf00a9eb18a3f0f139">LLVM_NODISCARD</a> bool SVF::SVFUtil::isa </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>Val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Casting_8h_source.html#l00248">248</a> of file <a class="el" href="Casting_8h_source.html">Casting.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;{</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;First&gt;(Val) || <a class="code" href="namespaceSVF_1_1SVFUtil.html#a13729076054a2977670b05a338a6763d">SVFUtil::isa</a>&lt;Second, Rest...&gt;(Val);</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a13729076054a2977670b05a338a6763d"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a13729076054a2977670b05a338a6763d">SVF::SVFUtil::isa</a></div><div class="ttdeci">LLVM_NODISCARD bool isa(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00248">Casting.h:248</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a34958ca60ed98ad228c1d46cf95aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a34958ca60ed98ad228c1d46cf95aeb">&#9670;&nbsp;</a></span>isArgOfUncalledFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isArgOfUncalledFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *&#160;</td>
          <td class="paramname"><em>svfval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this argument belongs to an uncalled function. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00371">371</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;{</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">if</span>(<span class="keyword">const</span> SVFArgument* arg = SVFUtil::dyn_cast&lt;SVFArgument&gt;(svfval))</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;        <span class="keywordflow">return</span> arg-&gt;isArgOfUncalledFunction();</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a34f0066d96179c6d7e9a1e42608ecb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f0066d96179c6d7e9a1e42608ecb73">&#9670;&nbsp;</a></span>isBarrierWaitCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isBarrierWaitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a barrier wait call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00452">452</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;{</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDBarWait(cs);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac69f286ff865a778dc2af5410ed9b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69f286ff865a778dc2af5410ed9b24e">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00328">328</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;{</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;    <span class="keywordflow">return</span> SVFUtil::isa&lt;CallICFGNode&gt;(inst);</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8cb755f339ad1650f8ae2155451d9c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb755f339ad1650f8ae2155451d9c0d">&#9670;&nbsp;</a></span>isCallSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFValue.html">SVFValue</a> *&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a call or invoke instruction. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00175">175</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;{</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    <span class="keywordflow">if</span>(SVFUtil::isa&lt;SVFCallInst&gt;(val))</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa2d203b5b7749ce51583d39a503407db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d203b5b7749ce51583d39a503407db">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00346">346</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;{</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">isExtCall</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a22ef185e767ff76c098e75126c885400"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">SVF::SVFUtil::isExtCall</a></div><div class="ttdeci">bool isExtCall(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00285">SVFUtil.h:285</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f888dfee60a63eb0711fcdd63430e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f888dfee60a63eb0711fcdd63430e8f">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00363">363</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;{</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="namespaceSVF_1_1LLVMUtil.html#a5a7dc8680a9714e08b01dd339b85bb20">isCallSite</a>(node)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a22ef185e767ff76c098e75126c885400">isExtCall</a>(cast&lt;CallICFGNode&gt;(node)-&gt;getCalledFunction());</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1LLVMUtil_html_a5a7dc8680a9714e08b01dd339b85bb20"><div class="ttname"><a href="namespaceSVF_1_1LLVMUtil.html#a5a7dc8680a9714e08b01dd339b85bb20">SVF::LLVMUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const Instruction *inst)</div><div class="ttdoc">Whether an instruction is a call or invoke instruction.</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8h_source.html#l00045">LLVMUtil.h:45</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a22ef185e767ff76c098e75126c885400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ef185e767ff76c098e75126c885400">&#9670;&nbsp;</a></span>isExtCall() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the call is an external call (external library in function summary table) If the library function is redefined in the application code (e.g., memcpy), it will return false and will not be treated as an external call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00285">285</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;{</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_ext(fun);</div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a85b308e08dd0837b9401ada40349ac32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b308e08dd0837b9401ada40349ac32">&#9670;&nbsp;</a></span>isHeapAllocExtCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00369">369</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;{</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">if</span>(!<a class="code" href="namespaceSVF_1_1LLVMUtil.html#a5a7dc8680a9714e08b01dd339b85bb20">isCallSite</a>(cs)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1LLVMUtil.html#a08bc070978163ca2309810bda61a15b1">isHeapAllocExtCallViaRet</a>(cast&lt;CallICFGNode&gt;(cs)) || <a class="code" href="namespaceSVF_1_1LLVMUtil.html#ac8086fb69cc73b558d99a83ea99f8a58">isHeapAllocExtCallViaArg</a>(cast&lt;CallICFGNode&gt;(cs));</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1LLVMUtil_html_a08bc070978163ca2309810bda61a15b1"><div class="ttname"><a href="namespaceSVF_1_1LLVMUtil.html#a08bc070978163ca2309810bda61a15b1">SVF::LLVMUtil::isHeapAllocExtCallViaRet</a></div><div class="ttdeci">bool isHeapAllocExtCallViaRet(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00618">LLVMUtil.cpp:618</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1LLVMUtil_html_ac8086fb69cc73b558d99a83ea99f8a58"><div class="ttname"><a href="namespaceSVF_1_1LLVMUtil.html#ac8086fb69cc73b558d99a83ea99f8a58">SVF::LLVMUtil::isHeapAllocExtCallViaArg</a></div><div class="ttdeci">bool isHeapAllocExtCallViaArg(const Instruction *inst)</div><div class="ttdef"><b>Definition:</b> <a href="LLVMUtil_8cpp_source.html#l00634">LLVMUtil.cpp:634</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a83a75e8eda99da5d45ccf0188e2d876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a75e8eda99da5d45ccf0188e2d876d">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaArg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00351">351</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;{</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">isHeapAllocExtFunViaArg</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ab4a69173f50ebe48e69103befe516245"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ab4a69173f50ebe48e69103befe516245">SVF::SVFUtil::isHeapAllocExtFunViaArg</a></div><div class="ttdeci">bool isHeapAllocExtFunViaArg(const SVFFunction *fun)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00309">SVFUtil.h:309</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb3bde29364d65428ee2c4eb22063828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3bde29364d65428ee2c4eb22063828">&#9670;&nbsp;</a></span>isHeapAllocExtCallViaRet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtCallViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>interfaces to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00375">375</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;{</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a90fd0b8e44fba1a7eb76d15bce085d66">getCallSite</a>()-&gt;<a class="code" href="classSVF_1_1SVFValue.html#a11f2d9b6e969ede6fca2c204cc15b821">getType</a>()-&gt;<a class="code" href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">isPointerTy</a>();</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">isHeapAllocExtFunViaRet</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_a90fd0b8e44fba1a7eb76d15bce085d66"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#a90fd0b8e44fba1a7eb76d15bce085d66">SVF::CallICFGNode::getCallSite</a></div><div class="ttdeci">const SVFInstruction * getCallSite() const</div><div class="ttdoc">Return callsite.</div><div class="ttdef"><b>Definition:</b> <a href="ICFGNode_8h_source.html#l00432">ICFGNode.h:432</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFType_html_a870b63af2bf9fe43cdf1df3d56b20f6c"><div class="ttname"><a href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">SVF::SVFType::isPointerTy</a></div><div class="ttdeci">bool isPointerTy() const</div><div class="ttdef"><b>Definition:</b> <a href="SVFType_8h_source.html#l00249">SVFType.h:249</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFValue_html_a11f2d9b6e969ede6fca2c204cc15b821"><div class="ttname"><a href="classSVF_1_1SVFValue.html#a11f2d9b6e969ede6fca2c204cc15b821">SVF::SVFValue::getType</a></div><div class="ttdeci">virtual const SVFType * getType() const</div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8h_source.html#l00256">SVFValue.h:256</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a19b96a872d9096037f20e25122e469ea"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a19b96a872d9096037f20e25122e469ea">SVF::SVFUtil::isHeapAllocExtFunViaRet</a></div><div class="ttdeci">bool isHeapAllocExtFunViaRet(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap allocator/reallocator.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00303">SVFUtil.h:303</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ab4a69173f50ebe48e69103befe516245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a69173f50ebe48e69103befe516245">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00309">309</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;{</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_arg_alloc(fun);</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a19b96a872d9096037f20e25122e469ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b96a872d9096037f20e25122e469ea">&#9670;&nbsp;</a></span>isHeapAllocExtFunViaRet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isHeapAllocExtFunViaRet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap allocator/reallocator. </p>
<p>note that these two functions are not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00303">303</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;{</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_alloc(fun)</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                   || ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1a2b3538ed321e5fa17b98e01c9175fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2b3538ed321e5fa17b98e01c9175fc">&#9670;&nbsp;</a></span>isIntrinsicInst() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00333">333</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;{</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a>* call = SVFUtil::dyn_cast&lt;CallICFGNode&gt;(inst))</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;    {</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;        <span class="keyword">const</span> <a class="code" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* func = call-&gt;getCalledFunction();</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;        <span class="keywordflow">if</span> (func &amp;&amp; func-&gt;<a class="code" href="classSVF_1_1SVFFunction.html#a7b4c6c7143d012802ea5ee962bec2deb">isIntrinsic</a>())</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;        {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        }</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;    }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html">SVF::CallICFGNode</a></div><div class="ttdef"><b>Definition:</b> <a href="ICFGNode_8h_source.html#l00408">ICFGNode.h:409</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFFunction_html"><div class="ttname"><a href="classSVF_1_1SVFFunction.html">SVF::SVFFunction</a></div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8h_source.html#l00297">SVFValue.h:298</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFFunction_html_a7b4c6c7143d012802ea5ee962bec2deb"><div class="ttname"><a href="classSVF_1_1SVFFunction.html#a7b4c6c7143d012802ea5ee962bec2deb">SVF::SVFFunction::isIntrinsic</a></div><div class="ttdeci">bool isIntrinsic() const</div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8h_source.html#l00371">SVFValue.h:371</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="abb2bbf6e0dc5adae2140a519259e6f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2bbf6e0dc5adae2140a519259e6f17">&#9670;&nbsp;</a></span>isIntrinsicInst() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isIntrinsicInst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFInstruction.html">SVFInstruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if it is an llvm intrinsic instruction. </p>
<p>Return true if it is an llvm intrinsic instruction </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00247">247</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;{</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <a class="code" href="classSVF_1_1SVFCallInst.html">SVFCallInst</a>* call = SVFUtil::dyn_cast&lt;SVFCallInst&gt;(inst))</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    {</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;        <span class="keyword">const</span> <a class="code" href="classSVF_1_1SVFFunction.html">SVFFunction</a>* func = call-&gt;getCalledFunction();</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">if</span> (func &amp;&amp; func-&gt;<a class="code" href="classSVF_1_1SVFFunction.html#a7b4c6c7143d012802ea5ee962bec2deb">isIntrinsic</a>())</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;        {</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;        }</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;    }</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1SVFCallInst_html"><div class="ttname"><a href="classSVF_1_1SVFCallInst.html">SVF::SVFCallInst</a></div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8h_source.html#l00664">SVFValue.h:665</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a191cbe16e7e32dd136cff438752b3029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191cbe16e7e32dd136cff438752b3029">&#9670;&nbsp;</a></span>isLockAquireCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockAquireCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00436">436</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;{</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDAcquire(cs);</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="abaa7be6fe5d9c277583eaeab46282b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa7be6fe5d9c277583eaeab46282b62">&#9670;&nbsp;</a></span>isLockReleaseCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isLockReleaseCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a lock acquire call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00444">444</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;{</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDRelease(cs);</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a688bd5e1bf36b3e75bfcea9388871dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688bd5e1bf36b3e75bfcea9388871dc4">&#9670;&nbsp;</a></span>isMemcpyExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isMemcpyExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00290">290</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;{</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_memcpy(fun);</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a54098ea73555caa682287f8e3c9e8fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54098ea73555caa682287f8e3c9e8fcb">&#9670;&nbsp;</a></span>isMemsetExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isMemsetExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00295">295</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;{</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; ExtAPI::getExtAPI()-&gt;is_memset(fun);</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a86b337f84cae7ae0ec4597b077aee08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b337f84cae7ae0ec4597b077aee08c">&#9670;&nbsp;</a></span>isNonInstricCallSite() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNonInstricCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00196">196</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;{</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">isIntrinsicInst</a>(inst))</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">isCallSite</a>(inst);</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a1a2b3538ed321e5fa17b98e01c9175fc"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">SVF::SVFUtil::isIntrinsicInst</a></div><div class="ttdeci">bool isIntrinsicInst(const ICFGNode *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00333">SVFUtil.cpp:333</a></div></div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ac69f286ff865a778dc2af5410ed9b24e"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">SVF::SVFUtil::isCallSite</a></div><div class="ttdeci">bool isCallSite(const ICFGNode *inst)</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00328">SVFUtil.cpp:328</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4af4db2fe43846609d2ed1d7022b1be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af4db2fe43846609d2ed1d7022b1be1">&#9670;&nbsp;</a></span>isNonInstricCallSite() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isNonInstricCallSite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFInstruction.html">SVFInstruction</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether an instruction is a callsite in the application code, excluding llvm intrinsic calls. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00188">188</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;{</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="keywordflow">if</span>(<a class="code" href="namespaceSVF_1_1SVFUtil.html#a1a2b3538ed321e5fa17b98e01c9175fc">isIntrinsicInst</a>(inst))</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#ac69f286ff865a778dc2af5410ed9b24e">isCallSite</a>(inst);</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c97c2b79b795465490512e267a9309b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c97c2b79b795465490512e267a9309b">&#9670;&nbsp;</a></span>isProgEntryFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgEntryFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Program entry function e.g. main. </p>
<p>Return true if this is a program entry function (e.g. main) </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00332">332</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;{</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; fun-&gt;getName() == <span class="stringliteral">&quot;main&quot;</span>;</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac6586774af88b61f367ba43d126f38ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6586774af88b61f367ba43d126f38ac">&#9670;&nbsp;</a></span>isProgExitCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00396">396</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;{</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">isProgExitFunction</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_aec7ee60be22e8f9397db108131696d57"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#aec7ee60be22e8f9397db108131696d57">SVF::SVFUtil::isProgExitFunction</a></div><div class="ttdeci">bool isProgExitFunction(const SVFFunction *fun)</div><div class="ttdoc">Return true if this is a program exit function call.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00363">SVFUtil.h:363</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec7ee60be22e8f9397db108131696d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ee60be22e8f9397db108131696d57">&#9670;&nbsp;</a></span>isProgExitFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isProgExitFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if this is a program exit function call. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00363">363</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;{</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (fun-&gt;getName() == <span class="stringliteral">&quot;exit&quot;</span> ||</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_rtn&quot;</span> ||</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;                   fun-&gt;getName() == <span class="stringliteral">&quot;__assert_fail&quot;</span> );</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a01f4cd58f733d71c9bbd7dcc40194c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f4cd58f733d71c9bbd7dcc40194c0b">&#9670;&nbsp;</a></span>isReallocExtCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00381">381</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;{</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordtype">bool</span> isPtrTy = cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a90fd0b8e44fba1a7eb76d15bce085d66">getCallSite</a>()-&gt;<a class="code" href="classSVF_1_1SVFValue.html#a11f2d9b6e969ede6fca2c204cc15b821">getType</a>()-&gt;<a class="code" href="classSVF_1_1SVFType.html#a870b63af2bf9fe43cdf1df3d56b20f6c">isPointerTy</a>();</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="keywordflow">return</span> isPtrTy &amp;&amp; <a class="code" href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">isReallocExtFun</a>(cs-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#a01da4df6aae8e660f9a97e91e42c397f">getCalledFunction</a>());</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a97c74c642ad43d955ac8a3f3ad8907b4"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a97c74c642ad43d955ac8a3f3ad8907b4">SVF::SVFUtil::isReallocExtFun</a></div><div class="ttdeci">bool isReallocExtFun(const SVFFunction *fun)</div><div class="ttdoc">Return true if the call is a heap reallocator.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00324">SVFUtil.h:324</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a97c74c642ad43d955ac8a3f3ad8907b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c74c642ad43d955ac8a3f3ad8907b4">&#9670;&nbsp;</a></span>isReallocExtFun()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isReallocExtFun </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the call is a heap reallocator. </p>
<p>note that this function is not suppose to be used externally </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00324">324</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;{</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;    <span class="keywordflow">return</span> fun &amp;&amp; (ExtAPI::getExtAPI()-&gt;is_realloc(fun));</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4bd7753901074b660eda3166180a356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bd7753901074b660eda3166180a356">&#9670;&nbsp;</a></span>isRetInstNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isRetInstNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1ICFGNode.html">ICFGNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00388">388</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;{</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; intraNode = dyn_cast&lt;IntraICFGNode&gt;(node))</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordflow">return</span> intraNode-&gt;getInst()-&gt;isRetInst();</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1b7843d49df58cf1bf3725076702c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b7843d49df58cf1bf3725076702c07">&#9670;&nbsp;</a></span>isThreadExitCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadExitCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread exit call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00428">428</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;{</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDExit(cs);</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aac9a03aaeb26832c69f95a9a96a2d31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac9a03aaeb26832c69f95a9a96a2d31a">&#9670;&nbsp;</a></span>isThreadForkCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadForkCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread creation call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00412">412</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;{</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDFork(inst);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a86c79a20405d3a31b309a14bd68f1166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c79a20405d3a31b309a14bd68f1166">&#9670;&nbsp;</a></span>isThreadJoinCall()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::isThreadJoinCall </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>cs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if this is a thread join call </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00420">420</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;{</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="keywordflow">return</span> ThreadAPI::getThreadAPI()-&gt;isTDJoin(cs);</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ada7f7c7f60a7ad6c053012a74f2dcc1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7f7c7f60a7ad6c053012a74f2dcc1c">&#9670;&nbsp;</a></span>matchArgs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::matchArgs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1CallICFGNode.html">CallICFGNode</a> *&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1SVFFunction.html">SVFFunction</a> *&#160;</td>
          <td class="paramname"><em>callee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Match arguments for callsite at caller and callee if the arg size does not match then we do not need to connect this parameter unless the callee is a variadic function (the first parameter of variadic function is its parameter number)</p>
<p>Match arguments for callsite at caller and callee if the arg size does not match then we do not need to connect this parameter unless the callee is a variadic function (the first parameter of variadic function is its parameter number) e.g., void variadicFoo(int num, ...); variadicFoo(5, 1,2,3,4,5) for variadic function, callsite arg size must be greater than or equal to callee arg size </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00320">320</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;{</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;    <span class="keywordflow">if</span> (callee-&gt;<a class="code" href="classSVF_1_1SVFFunction.html#ae578002917b4ccbf28f172dba30d1d58">isVarArg</a>() || ThreadAPI::getThreadAPI()-&gt;isTDFork(call))</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;        <span class="keywordflow">return</span> call-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">arg_size</a>() &gt;= callee-&gt;<a class="code" href="classSVF_1_1SVFFunction.html#ab8c7a9c79b0668aae604bbe54e34e46e">arg_size</a>();</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;        <span class="keywordflow">return</span> call-&gt;<a class="code" href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">arg_size</a>() == callee-&gt;<a class="code" href="classSVF_1_1SVFFunction.html#ab8c7a9c79b0668aae604bbe54e34e46e">arg_size</a>();</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1CallICFGNode_html_ada0b68a709fde6d41a5e067b87642937"><div class="ttname"><a href="classSVF_1_1CallICFGNode.html#ada0b68a709fde6d41a5e067b87642937">SVF::CallICFGNode::arg_size</a></div><div class="ttdeci">u32_t arg_size() const</div><div class="ttdef"><b>Definition:</b> <a href="ICFGNode_8h_source.html#l00489">ICFGNode.h:489</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFFunction_html_ab8c7a9c79b0668aae604bbe54e34e46e"><div class="ttname"><a href="classSVF_1_1SVFFunction.html#ab8c7a9c79b0668aae604bbe54e34e46e">SVF::SVFFunction::arg_size</a></div><div class="ttdeci">u32_t arg_size() const</div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8cpp_source.html#l00176">SVFValue.cpp:176</a></div></div>
<div class="ttc" id="aclassSVF_1_1SVFFunction_html_ae578002917b4ccbf28f172dba30d1d58"><div class="ttname"><a href="classSVF_1_1SVFFunction.html#ae578002917b4ccbf28f172dba30d1d58">SVF::SVFFunction::isVarArg</a></div><div class="ttdeci">bool isVarArg() const</div><div class="ttdef"><b>Definition:</b> <a href="SVFValue_8cpp_source.html#l00187">SVFValue.cpp:187</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a36c91f952a69875c33d4bd0b05a27ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c91f952a69875c33d4bd0b05a27ff2">&#9670;&nbsp;</a></span>mergePtsOccMaps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Data &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::mergePtsOccMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a8234d4b959abc9123993bcff4eee34c1">Map</a>&lt; Data, unsigned &gt;&#160;</td>
          <td class="paramname"><em>from</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a map mapping points-to sets to a count, adds from into to. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00233">233</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;{</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">typename</span> Map&lt;Data, unsigned&gt;::value_type &amp;ptocc : from)</div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;    {</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        to[ptocc.first] += ptocc.second;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;    }</div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a72502f7f536418621485e90ab98c2016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72502f7f536418621485e90ab98c2016">&#9670;&nbsp;</a></span>move()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::remove_reference&lt;T&gt;::<a class="el" href="cJSON_8cpp.html#a3f9a0d3265a6254722587175dac3e4dc">type</a>&amp;&amp; SVF::SVFUtil::move </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00472">472</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;{</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">std::move</a>(t);</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a72502f7f536418621485e90ab98c2016"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a72502f7f536418621485e90ab98c2016">SVF::SVFUtil::move</a></div><div class="ttdeci">constexpr std::remove_reference&lt; T &gt;::type &amp;&amp; move(T &amp;&amp;t) noexcept</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8h_source.html#l00472">SVFUtil.h:472</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aed0b0b9f035057552a6a82154fd88e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0b0b9f035057552a6a82154fd88e61">&#9670;&nbsp;</a></span>outs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; SVF::SVFUtil::outs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overwrite <a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61" title="Overwrite llvm::outs()">llvm::outs()</a> </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00050">50</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;{</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">return</span> std::cout;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4550f2fb815882edfb666ac818792064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4550f2fb815882edfb666ac818792064">&#9670;&nbsp;</a></span>pasMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::pasMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print each pass/phase message by converting a string into blue string output. </p>
<p>print each pass/phase message by converting a string into blue string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00099">99</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;{</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_a3f838f2fc3a9a3b434be606fc908964b"><div class="ttname"><a href="SVFUtil_8cpp.html#a3f838f2fc3a9a3b434be606fc908964b">KBLU</a></div><div class="ttdeci">#define KBLU</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00043">SVFUtil.cpp:43</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a86ebab122895189be57637b84adc7642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86ebab122895189be57637b84adc7642">&#9670;&nbsp;</a></span>ptsToNodeBS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> SVF::SVFUtil::ptsToNodeBS </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSVF_1_1PointsTo.html">PointsTo</a> &amp;&#160;</td>
          <td class="paramname"><em>pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00159">159</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;{</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <a class="code" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> nbs;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> o : pts) nbs.<a class="code" href="classSVF_1_1SparseBitVector.html#a61bd86909a141f9de873d92c0f904832">set</a>(o);</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;    <span class="keywordflow">return</span> nbs;</div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;}</div>
<div class="ttc" id="aclassSVF_1_1SparseBitVector_html_a61bd86909a141f9de873d92c0f904832"><div class="ttname"><a href="classSVF_1_1SparseBitVector.html#a61bd86909a141f9de873d92c0f904832">SVF::SparseBitVector::set</a></div><div class="ttdeci">void set(unsigned Idx)</div><div class="ttdef"><b>Definition:</b> <a href="SparseBitVector_8h_source.html#l00789">SparseBitVector.h:789</a></div></div>
<div class="ttc" id="anamespaceSVF_html_aa7b6a13e52671de8524b130738aeb564"><div class="ttname"><a href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">SVF::NodeBS</a></div><div class="ttdeci">SparseBitVector NodeBS</div><div class="ttdef"><b>Definition:</b> <a href="GeneralType_8h_source.html#l00062">GeneralType.h:62</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aee74719d33695e4da6fee5fc83f745d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee74719d33695e4da6fee5fc83f745d9">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename KeySet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeySet &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes an element from a Set/CondSet (or anything implementing ::erase). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00259">259</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;{</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    keySet.erase(key);</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa59af7fc01a534662b3b1524186ef97e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59af7fc01a534662b3b1524186ef97e">&#9670;&nbsp;</a></span>removeKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::removeKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceSVF.html#a43a65e0d33af3c743294f7a1139d2301">NodeID</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#aa7b6a13e52671de8524b130738aeb564">NodeBS</a> &amp;&#160;</td>
          <td class="paramname"><em>keySet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a NodeID from a NodeBS. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00265">265</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;{</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    keySet.reset(key);</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6cfe12afa463d0ceddeee11540c33ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cfe12afa463d0ceddeee11540c33ab3">&#9670;&nbsp;</a></span>reportMemoryUsageKB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::reportMemoryUsageKB </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>infor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSVF.html#a8bd74fdcb0e58d0249003df9c3fb8b31">OutStream</a> &amp;&#160;</td>
          <td class="paramname"><em>O</em> = <code><a class="el" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print memory usage in KB. </p>
<p>Print memory usage </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00167">167</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;{</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;    <a class="code" href="CommandLine_8h.html#a2429346d37bd4c40889bd7c6d319d9da">u32_t</a> vmrss, vmsize;</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">if</span> (<a class="code" href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">getMemoryUsageKB</a>(&amp;vmrss, &amp;vmsize))</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        O &lt;&lt; infor &lt;&lt; <span class="stringliteral">&quot;\tVmRSS: &quot;</span> &lt;&lt; vmrss &lt;&lt; <span class="stringliteral">&quot;\tVmSize: &quot;</span> &lt;&lt; vmsize &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_a630ff9c47f58f9b8df7c8a2b3711477c"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#a630ff9c47f58f9b8df7c8a2b3711477c">SVF::SVFUtil::getMemoryUsageKB</a></div><div class="ttdeci">bool getMemoryUsageKB(u32_t *vmrss_kb, u32_t *vmsize_kb)</div><div class="ttdoc">Get memory usage from system file. Return TRUE if succeed.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00177">SVFUtil.cpp:177</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae18227f257c9881541b84ca186680dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18227f257c9881541b84ca186680dfd">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a>&gt; SVF::SVFUtil::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split into two substrings around the first occurrence of a separator string. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00210">210</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;{</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    std::vector&lt;std::string&gt; output;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    std::string::size_type prev_pos = 0, pos = 0;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">while</span> ((pos = s.find(separator, pos)) != std::string::npos)</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;    {</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> substring(s.substr(prev_pos, pos - prev_pos));</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">if</span> (!substring.empty())</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;        {</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;            output.push_back(substring);</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;        }</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        prev_pos = ++pos;</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    }</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    <a class="code" href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">std::string</a> lastSubstring(s.substr(prev_pos, pos - prev_pos));</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="keywordflow">if</span> (!lastSubstring.empty())</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    {</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        output.push_back(lastSubstring);</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    }</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    <span class="keywordflow">return</span> output;</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;}</div>
<div class="ttc" id="acJSON_8h_html_ad4c68ea99a26b0a98ad9a79982960458"><div class="ttname"><a href="cJSON_8h.html#ad4c68ea99a26b0a98ad9a79982960458">string</a></div><div class="ttdeci">const char *const string</div><div class="ttdef"><b>Definition:</b> <a href="cJSON_8h_source.html#l00172">cJSON.h:172</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a757815a2c758695176120509ceb0ce70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757815a2c758695176120509ceb0ce70">&#9670;&nbsp;</a></span>startAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SVF::SVFUtil::startAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>timeLimit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts an analysis timer. If timeLimit is 0, sets no timer. If an alarm has already been set, does not set another. Returns whether we set a timer or not. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00289">289</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;{</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;    <span class="keywordflow">if</span> (timeLimit == 0) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160; </div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="comment">// If an alarm is already set, don&#39;t set another. That means this analysis</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="comment">// is part of another which has a time limit.</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;    <span class="keywordtype">unsigned</span> remainingSeconds = alarm(0);</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;    <span class="keywordflow">if</span> (remainingSeconds != 0)</div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    {</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;        <span class="comment">// Continue the previous alarm and move on.</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;        alarm(remainingSeconds);</div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    }</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160; </div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;    signal(SIGALRM, &amp;<a class="code" href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">timeLimitReached</a>);</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    alarm(timeLimit);</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_add4cd21115988f9f5eec12e268ddf1d9"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#add4cd21115988f9f5eec12e268ddf1d9">SVF::SVFUtil::timeLimitReached</a></div><div class="ttdeci">void timeLimitReached(int signum)</div><div class="ttdoc">Function to call when alarm for time limit hits.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00280">SVFUtil.cpp:280</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a168f7f7a3a8c70dbf2b5b4269cd4c7c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168f7f7a3a8c70dbf2b5b4269cd4c7c5">&#9670;&nbsp;</a></span>stopAnalysisLimitTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::stopAnalysisLimitTimer </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>limitTimerSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops an analysis timer. limitTimerSet indicates whether the caller set the timer or not (return value of startLimitTimer). </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00310">310</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;{</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;    <span class="keywordflow">if</span> (limitTimerSet) alarm(0);</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a05dc00b2bd9a8176aae31b6cfffe725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dc00b2bd9a8176aae31b6cfffe725d">&#9670;&nbsp;</a></span>sucMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::sucMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns successful message by converting a string into green string output. </p>
<p>print successful message by converting a string into green string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00053">53</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;{</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;}</div>
<div class="ttc" id="aSVFUtil_8cpp_html_ac081c83b067273757f7a2e54a5957d41"><div class="ttname"><a href="SVFUtil_8cpp.html#ac081c83b067273757f7a2e54a5957d41">KGRN</a></div><div class="ttdeci">#define KGRN</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00041">SVFUtil.cpp:41</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="add4cd21115988f9f5eec12e268ddf1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4cd21115988f9f5eec12e268ddf1d9">&#9670;&nbsp;</a></span>timeLimitReached()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::timeLimitReached </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call when alarm for time limit hits. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00280">280</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;{</div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>().flush();</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;    <span class="comment">// TODO: output does not indicate which time limit is reached.</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;    <span class="comment">//       This can be better in the future.</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">SVFUtil::outs</a>() &lt;&lt; <span class="stringliteral">&quot;WPA: time limit reached\n&quot;</span>;</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;    exit(101);</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2e0196e0ce547ab4a483cc6d2646b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e0196e0ce547ab4a483cc6d2646b24">&#9670;&nbsp;</a></span>writeWrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SVF::SVFUtil::writeWrnMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a message run through wrnMsg. </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00066">66</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;{</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    <span class="keywordflow">if</span> (Options::DisableWarn())</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <a class="code" href="namespaceSVF_1_1SVFUtil.html#aed0b0b9f035057552a6a82154fd88e61">outs</a>() &lt;&lt; <a class="code" href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">wrnMsg</a>(msg) &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
<div class="ttc" id="anamespaceSVF_1_1SVFUtil_html_ac71522e8c55f84cfc6c13a0ddff18436"><div class="ttname"><a href="namespaceSVF_1_1SVFUtil.html#ac71522e8c55f84cfc6c13a0ddff18436">SVF::SVFUtil::wrnMsg</a></div><div class="ttdeci">std::string wrnMsg(const std::string &amp;msg)</div><div class="ttdoc">Returns warning message by converting a string into yellow string output.</div><div class="ttdef"><b>Definition:</b> <a href="SVFUtil_8cpp_source.html#l00061">SVFUtil.cpp:61</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac71522e8c55f84cfc6c13a0ddff18436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71522e8c55f84cfc6c13a0ddff18436">&#9670;&nbsp;</a></span>wrnMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> SVF::SVFUtil::wrnMsg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cJSON_8cpp.html#ae1adbce218e7a9d09164012443191d24">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns warning message by converting a string into yellow string output. </p>
<p>print warning message by converting a string into yellow string output </p>

<p class="definition">Definition at line <a class="el" href="SVFUtil_8cpp_source.html#l00061">61</a> of file <a class="el" href="SVFUtil_8cpp_source.html">SVFUtil.cpp</a>.</p>
<div class="fragment"><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;{</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="SVFUtil_8cpp.html#a897b10d246533c95ba86cb79f92e465a">KYEL</a> + msg + <a class="code" href="SVFUtil_8cpp.html#a137aa83ec74421d226a90c92ec032ac9">KNRM</a>;</div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aa32219da7a5c3d7517ec5026afdac588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32219da7a5c3d7517ec5026afdac588">&#9670;&nbsp;</a></span>is_iterable_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool SVF::SVFUtil::is_iterable_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__iterable.html">is_iterable</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00492">492</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a8c57ab480c497cbd21a49778d0e59bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c57ab480c497cbd21a49778d0e59bd5">&#9670;&nbsp;</a></span>is_map_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool SVF::SVFUtil::is_map_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__map.html">is_map</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00501">501</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a811faa9c2095f44e3e5b6e50aa6f6e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811faa9c2095f44e3e5b6e50aa6f6e06">&#9670;&nbsp;</a></span>is_sequence_container_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool SVF::SVFUtil::is_sequence_container_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__sequence__container.html">is_sequence_container</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00522">522</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
<a id="a08e67d68b1da116b2c51cb60bdb6dae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e67d68b1da116b2c51cb60bdb6dae2">&#9670;&nbsp;</a></span>is_set_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool SVF::SVFUtil::is_set_v = <a class="el" href="structSVF_1_1SVFUtil_1_1is__set.html">is_set</a>&lt;Ts...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SVFUtil_8h_source.html#l00510">510</a> of file <a class="el" href="SVFUtil_8h_source.html">SVFUtil.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
